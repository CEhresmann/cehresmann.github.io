(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
        i(r);
    new MutationObserver(r=>{
        for (const s of r)
            if (s.type === "childList")
                for (const o of s.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && i(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(r) {
        const s = {};
        return r.integrity && (s.integrity = r.integrity),
        r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
        r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
        s
    }
    function i(r) {
        if (r.ep)
            return;
        r.ep = !0;
        const s = t(r);
        fetch(r.href, s)
    }
}
)();
function zy(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}
var XE = {
    exports: {}
}
  , Ip = {}
  , YE = {
    exports: {}
}
  , Et = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cf = Symbol.for("react.element")
  , Ib = Symbol.for("react.portal")
  , Nb = Symbol.for("react.fragment")
  , Db = Symbol.for("react.strict_mode")
  , Ub = Symbol.for("react.profiler")
  , Ob = Symbol.for("react.provider")
  , Fb = Symbol.for("react.context")
  , kb = Symbol.for("react.forward_ref")
  , zb = Symbol.for("react.suspense")
  , Bb = Symbol.for("react.memo")
  , Hb = Symbol.for("react.lazy")
  , sS = Symbol.iterator;
function Vb(n) {
    return n === null || typeof n != "object" ? null : (n = sS && n[sS] || n["@@iterator"],
    typeof n == "function" ? n : null)
}
var jE = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , qE = Object.assign
  , ZE = {};
function tu(n, e, t) {
    this.props = n,
    this.context = e,
    this.refs = ZE,
    this.updater = t || jE
}
tu.prototype.isReactComponent = {};
tu.prototype.setState = function(n, e) {
    if (typeof n != "object" && typeof n != "function" && n != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, n, e, "setState")
}
;
tu.prototype.forceUpdate = function(n) {
    this.updater.enqueueForceUpdate(this, n, "forceUpdate")
}
;
function JE() {}
JE.prototype = tu.prototype;
function By(n, e, t) {
    this.props = n,
    this.context = e,
    this.refs = ZE,
    this.updater = t || jE
}
var Hy = By.prototype = new JE;
Hy.constructor = By;
qE(Hy, tu.prototype);
Hy.isPureReactComponent = !0;
var oS = Array.isArray
  , KE = Object.prototype.hasOwnProperty
  , Vy = {
    current: null
}
  , QE = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function $E(n, e, t) {
    var i, r = {}, s = null, o = null;
    if (e != null)
        for (i in e.ref !== void 0 && (o = e.ref),
        e.key !== void 0 && (s = "" + e.key),
        e)
            KE.call(e, i) && !QE.hasOwnProperty(i) && (r[i] = e[i]);
    var a = arguments.length - 2;
    if (a === 1)
        r.children = t;
    else if (1 < a) {
        for (var c = Array(a), f = 0; f < a; f++)
            c[f] = arguments[f + 2];
        r.children = c
    }
    if (n && n.defaultProps)
        for (i in a = n.defaultProps,
        a)
            r[i] === void 0 && (r[i] = a[i]);
    return {
        $$typeof: cf,
        type: n,
        key: s,
        ref: o,
        props: r,
        _owner: Vy.current
    }
}
function Gb(n, e) {
    return {
        $$typeof: cf,
        type: n.type,
        key: e,
        ref: n.ref,
        props: n.props,
        _owner: n._owner
    }
}
function Gy(n) {
    return typeof n == "object" && n !== null && n.$$typeof === cf
}
function Wb(n) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + n.replace(/[=:]/g, function(t) {
        return e[t]
    })
}
var aS = /\/+/g;
function Pg(n, e) {
    return typeof n == "object" && n !== null && n.key != null ? Wb("" + n.key) : e.toString(36)
}
function Nd(n, e, t, i, r) {
    var s = typeof n;
    (s === "undefined" || s === "boolean") && (n = null);
    var o = !1;
    if (n === null)
        o = !0;
    else
        switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (n.$$typeof) {
            case cf:
            case Ib:
                o = !0
            }
        }
    if (o)
        return o = n,
        r = r(o),
        n = i === "" ? "." + Pg(o, 0) : i,
        oS(r) ? (t = "",
        n != null && (t = n.replace(aS, "$&/") + "/"),
        Nd(r, e, t, "", function(f) {
            return f
        })) : r != null && (Gy(r) && (r = Gb(r, t + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(aS, "$&/") + "/") + n)),
        e.push(r)),
        1;
    if (o = 0,
    i = i === "" ? "." : i + ":",
    oS(n))
        for (var a = 0; a < n.length; a++) {
            s = n[a];
            var c = i + Pg(s, a);
            o += Nd(s, e, t, c, r)
        }
    else if (c = Vb(n),
    typeof c == "function")
        for (n = c.call(n),
        a = 0; !(s = n.next()).done; )
            s = s.value,
            c = i + Pg(s, a++),
            o += Nd(s, e, t, c, r);
    else if (s === "object")
        throw e = String(n),
        Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}
function Mh(n, e, t) {
    if (n == null)
        return n;
    var i = []
      , r = 0;
    return Nd(n, i, "", "", function(s) {
        return e.call(t, s, r++)
    }),
    i
}
function Xb(n) {
    if (n._status === -1) {
        var e = n._result;
        e = e(),
        e.then(function(t) {
            (n._status === 0 || n._status === -1) && (n._status = 1,
            n._result = t)
        }, function(t) {
            (n._status === 0 || n._status === -1) && (n._status = 2,
            n._result = t)
        }),
        n._status === -1 && (n._status = 0,
        n._result = e)
    }
    if (n._status === 1)
        return n._result.default;
    throw n._result
}
var pi = {
    current: null
}
  , Dd = {
    transition: null
}
  , Yb = {
    ReactCurrentDispatcher: pi,
    ReactCurrentBatchConfig: Dd,
    ReactCurrentOwner: Vy
};
function eT() {
    throw Error("act(...) is not supported in production builds of React.")
}
Et.Children = {
    map: Mh,
    forEach: function(n, e, t) {
        Mh(n, function() {
            e.apply(this, arguments)
        }, t)
    },
    count: function(n) {
        var e = 0;
        return Mh(n, function() {
            e++
        }),
        e
    },
    toArray: function(n) {
        return Mh(n, function(e) {
            return e
        }) || []
    },
    only: function(n) {
        if (!Gy(n))
            throw Error("React.Children.only expected to receive a single React element child.");
        return n
    }
};
Et.Component = tu;
Et.Fragment = Nb;
Et.Profiler = Ub;
Et.PureComponent = By;
Et.StrictMode = Db;
Et.Suspense = zb;
Et.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Yb;
Et.act = eT;
Et.cloneElement = function(n, e, t) {
    if (n == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + n + ".");
    var i = qE({}, n.props)
      , r = n.key
      , s = n.ref
      , o = n._owner;
    if (e != null) {
        if (e.ref !== void 0 && (s = e.ref,
        o = Vy.current),
        e.key !== void 0 && (r = "" + e.key),
        n.type && n.type.defaultProps)
            var a = n.type.defaultProps;
        for (c in e)
            KE.call(e, c) && !QE.hasOwnProperty(c) && (i[c] = e[c] === void 0 && a !== void 0 ? a[c] : e[c])
    }
    var c = arguments.length - 2;
    if (c === 1)
        i.children = t;
    else if (1 < c) {
        a = Array(c);
        for (var f = 0; f < c; f++)
            a[f] = arguments[f + 2];
        i.children = a
    }
    return {
        $$typeof: cf,
        type: n.type,
        key: r,
        ref: s,
        props: i,
        _owner: o
    }
}
;
Et.createContext = function(n) {
    return n = {
        $$typeof: Fb,
        _currentValue: n,
        _currentValue2: n,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    n.Provider = {
        $$typeof: Ob,
        _context: n
    },
    n.Consumer = n
}
;
Et.createElement = $E;
Et.createFactory = function(n) {
    var e = $E.bind(null, n);
    return e.type = n,
    e
}
;
Et.createRef = function() {
    return {
        current: null
    }
}
;
Et.forwardRef = function(n) {
    return {
        $$typeof: kb,
        render: n
    }
}
;
Et.isValidElement = Gy;
Et.lazy = function(n) {
    return {
        $$typeof: Hb,
        _payload: {
            _status: -1,
            _result: n
        },
        _init: Xb
    }
}
;
Et.memo = function(n, e) {
    return {
        $$typeof: Bb,
        type: n,
        compare: e === void 0 ? null : e
    }
}
;
Et.startTransition = function(n) {
    var e = Dd.transition;
    Dd.transition = {};
    try {
        n()
    } finally {
        Dd.transition = e
    }
}
;
Et.unstable_act = eT;
Et.useCallback = function(n, e) {
    return pi.current.useCallback(n, e)
}
;
Et.useContext = function(n) {
    return pi.current.useContext(n)
}
;
Et.useDebugValue = function() {}
;
Et.useDeferredValue = function(n) {
    return pi.current.useDeferredValue(n)
}
;
Et.useEffect = function(n, e) {
    return pi.current.useEffect(n, e)
}
;
Et.useId = function() {
    return pi.current.useId()
}
;
Et.useImperativeHandle = function(n, e, t) {
    return pi.current.useImperativeHandle(n, e, t)
}
;
Et.useInsertionEffect = function(n, e) {
    return pi.current.useInsertionEffect(n, e)
}
;
Et.useLayoutEffect = function(n, e) {
    return pi.current.useLayoutEffect(n, e)
}
;
Et.useMemo = function(n, e) {
    return pi.current.useMemo(n, e)
}
;
Et.useReducer = function(n, e, t) {
    return pi.current.useReducer(n, e, t)
}
;
Et.useRef = function(n) {
    return pi.current.useRef(n)
}
;
Et.useState = function(n) {
    return pi.current.useState(n)
}
;
Et.useSyncExternalStore = function(n, e, t) {
    return pi.current.useSyncExternalStore(n, e, t)
}
;
Et.useTransition = function() {
    return pi.current.useTransition()
}
;
Et.version = "18.3.1";
YE.exports = Et;
var ve = YE.exports;
const jb = zy(ve);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qb = ve
  , Zb = Symbol.for("react.element")
  , Jb = Symbol.for("react.fragment")
  , Kb = Object.prototype.hasOwnProperty
  , Qb = qb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , $b = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function tT(n, e, t) {
    var i, r = {}, s = null, o = null;
    t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
    for (i in e)
        Kb.call(e, i) && !$b.hasOwnProperty(i) && (r[i] = e[i]);
    if (n && n.defaultProps)
        for (i in e = n.defaultProps,
        e)
            r[i] === void 0 && (r[i] = e[i]);
    return {
        $$typeof: Zb,
        type: n,
        key: s,
        ref: o,
        props: r,
        _owner: Qb.current
    }
}
Ip.Fragment = Jb;
Ip.jsx = tT;
Ip.jsxs = tT;
XE.exports = Ip;
var ct = XE.exports
  , K0 = {}
  , nT = {
    exports: {}
}
  , Gi = {}
  , iT = {
    exports: {}
}
  , rT = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
    function e(F, H) {
        var V = F.length;
        F.push(H);
        e: for (; 0 < V; ) {
            var q = V - 1 >>> 1
              , ce = F[q];
            if (0 < r(ce, H))
                F[q] = H,
                F[V] = ce,
                V = q;
            else
                break e
        }
    }
    function t(F) {
        return F.length === 0 ? null : F[0]
    }
    function i(F) {
        if (F.length === 0)
            return null;
        var H = F[0]
          , V = F.pop();
        if (V !== H) {
            F[0] = V;
            e: for (var q = 0, ce = F.length, Ce = ce >>> 1; q < Ce; ) {
                var Z = 2 * (q + 1) - 1
                  , de = F[Z]
                  , Se = Z + 1
                  , ke = F[Se];
                if (0 > r(de, V))
                    Se < ce && 0 > r(ke, de) ? (F[q] = ke,
                    F[Se] = V,
                    q = Se) : (F[q] = de,
                    F[Z] = V,
                    q = Z);
                else if (Se < ce && 0 > r(ke, V))
                    F[q] = ke,
                    F[Se] = V,
                    q = Se;
                else
                    break e
            }
        }
        return H
    }
    function r(F, H) {
        var V = F.sortIndex - H.sortIndex;
        return V !== 0 ? V : F.id - H.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        n.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , a = o.now();
        n.unstable_now = function() {
            return o.now() - a
        }
    }
    var c = []
      , f = []
      , h = 1
      , d = null
      , m = 3
      , v = !1
      , _ = !1
      , w = !1
      , x = typeof setTimeout == "function" ? setTimeout : null
      , g = typeof clearTimeout == "function" ? clearTimeout : null
      , S = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function M(F) {
        for (var H = t(f); H !== null; ) {
            if (H.callback === null)
                i(f);
            else if (H.startTime <= F)
                i(f),
                H.sortIndex = H.expirationTime,
                e(c, H);
            else
                break;
            H = t(f)
        }
    }
    function T(F) {
        if (w = !1,
        M(F),
        !_)
            if (t(c) !== null)
                _ = !0,
                J(P);
            else {
                var H = t(f);
                H !== null && ue(T, H.startTime - F)
            }
    }
    function P(F, H) {
        _ = !1,
        w && (w = !1,
        g(N),
        N = -1),
        v = !0;
        var V = m;
        try {
            for (M(H),
            d = t(c); d !== null && (!(d.expirationTime > H) || F && !I()); ) {
                var q = d.callback;
                if (typeof q == "function") {
                    d.callback = null,
                    m = d.priorityLevel;
                    var ce = q(d.expirationTime <= H);
                    H = n.unstable_now(),
                    typeof ce == "function" ? d.callback = ce : d === t(c) && i(c),
                    M(H)
                } else
                    i(c);
                d = t(c)
            }
            if (d !== null)
                var Ce = !0;
            else {
                var Z = t(f);
                Z !== null && ue(T, Z.startTime - H),
                Ce = !1
            }
            return Ce
        } finally {
            d = null,
            m = V,
            v = !1
        }
    }
    var R = !1
      , b = null
      , N = -1
      , G = 5
      , C = -1;
    function I() {
        return !(n.unstable_now() - C < G)
    }
    function K() {
        if (b !== null) {
            var F = n.unstable_now();
            C = F;
            var H = !0;
            try {
                H = b(!0, F)
            } finally {
                H ? se() : (R = !1,
                b = null)
            }
        } else
            R = !1
    }
    var se;
    if (typeof S == "function")
        se = function() {
            S(K)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var B = new MessageChannel
          , ie = B.port2;
        B.port1.onmessage = K,
        se = function() {
            ie.postMessage(null)
        }
    } else
        se = function() {
            x(K, 0)
        }
        ;
    function J(F) {
        b = F,
        R || (R = !0,
        se())
    }
    function ue(F, H) {
        N = x(function() {
            F(n.unstable_now())
        }, H)
    }
    n.unstable_IdlePriority = 5,
    n.unstable_ImmediatePriority = 1,
    n.unstable_LowPriority = 4,
    n.unstable_NormalPriority = 3,
    n.unstable_Profiling = null,
    n.unstable_UserBlockingPriority = 2,
    n.unstable_cancelCallback = function(F) {
        F.callback = null
    }
    ,
    n.unstable_continueExecution = function() {
        _ || v || (_ = !0,
        J(P))
    }
    ,
    n.unstable_forceFrameRate = function(F) {
        0 > F || 125 < F ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : G = 0 < F ? Math.floor(1e3 / F) : 5
    }
    ,
    n.unstable_getCurrentPriorityLevel = function() {
        return m
    }
    ,
    n.unstable_getFirstCallbackNode = function() {
        return t(c)
    }
    ,
    n.unstable_next = function(F) {
        switch (m) {
        case 1:
        case 2:
        case 3:
            var H = 3;
            break;
        default:
            H = m
        }
        var V = m;
        m = H;
        try {
            return F()
        } finally {
            m = V
        }
    }
    ,
    n.unstable_pauseExecution = function() {}
    ,
    n.unstable_requestPaint = function() {}
    ,
    n.unstable_runWithPriority = function(F, H) {
        switch (F) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            F = 3
        }
        var V = m;
        m = F;
        try {
            return H()
        } finally {
            m = V
        }
    }
    ,
    n.unstable_scheduleCallback = function(F, H, V) {
        var q = n.unstable_now();
        switch (typeof V == "object" && V !== null ? (V = V.delay,
        V = typeof V == "number" && 0 < V ? q + V : q) : V = q,
        F) {
        case 1:
            var ce = -1;
            break;
        case 2:
            ce = 250;
            break;
        case 5:
            ce = 1073741823;
            break;
        case 4:
            ce = 1e4;
            break;
        default:
            ce = 5e3
        }
        return ce = V + ce,
        F = {
            id: h++,
            callback: H,
            priorityLevel: F,
            startTime: V,
            expirationTime: ce,
            sortIndex: -1
        },
        V > q ? (F.sortIndex = V,
        e(f, F),
        t(c) === null && F === t(f) && (w ? (g(N),
        N = -1) : w = !0,
        ue(T, V - q))) : (F.sortIndex = ce,
        e(c, F),
        _ || v || (_ = !0,
        J(P))),
        F
    }
    ,
    n.unstable_shouldYield = I,
    n.unstable_wrapCallback = function(F) {
        var H = m;
        return function() {
            var V = m;
            m = H;
            try {
                return F.apply(this, arguments)
            } finally {
                m = V
            }
        }
    }
}
)(rT);
iT.exports = rT;
var e3 = iT.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var t3 = ve
  , Vi = e3;
function _e(n) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1; t < arguments.length; t++)
        e += "&args[]=" + encodeURIComponent(arguments[t]);
    return "Minified React error #" + n + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var sT = new Set
  , Ec = {};
function Sa(n, e) {
    Gl(n, e),
    Gl(n + "Capture", e)
}
function Gl(n, e) {
    for (Ec[n] = e,
    n = 0; n < e.length; n++)
        sT.add(e[n])
}
var Ss = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , Q0 = Object.prototype.hasOwnProperty
  , n3 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , lS = {}
  , uS = {};
function i3(n) {
    return Q0.call(uS, n) ? !0 : Q0.call(lS, n) ? !1 : n3.test(n) ? uS[n] = !0 : (lS[n] = !0,
    !1)
}
function r3(n, e, t, i) {
    if (t !== null && t.type === 0)
        return !1;
    switch (typeof e) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return i ? !1 : t !== null ? !t.acceptsBooleans : (n = n.toLowerCase().slice(0, 5),
        n !== "data-" && n !== "aria-");
    default:
        return !1
    }
}
function s3(n, e, t, i) {
    if (e === null || typeof e > "u" || r3(n, e, t, i))
        return !0;
    if (i)
        return !1;
    if (t !== null)
        switch (t.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
        }
    return !1
}
function mi(n, e, t, i, r, s, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4,
    this.attributeName = i,
    this.attributeNamespace = r,
    this.mustUseProperty = t,
    this.propertyName = n,
    this.type = e,
    this.sanitizeURL = s,
    this.removeEmptyString = o
}
var Vn = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(n) {
    Vn[n] = new mi(n,0,!1,n,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(n) {
    var e = n[0];
    Vn[e] = new mi(e,1,!1,n[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n) {
    Vn[n] = new mi(n,2,!1,n.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n) {
    Vn[n] = new mi(n,2,!1,n,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(n) {
    Vn[n] = new mi(n,3,!1,n.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(n) {
    Vn[n] = new mi(n,3,!0,n,null,!1,!1)
});
["capture", "download"].forEach(function(n) {
    Vn[n] = new mi(n,4,!1,n,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(n) {
    Vn[n] = new mi(n,6,!1,n,null,!1,!1)
});
["rowSpan", "start"].forEach(function(n) {
    Vn[n] = new mi(n,5,!1,n.toLowerCase(),null,!1,!1)
});
var Wy = /[\-:]([a-z])/g;
function Xy(n) {
    return n[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(n) {
    var e = n.replace(Wy, Xy);
    Vn[e] = new mi(e,1,!1,n,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(n) {
    var e = n.replace(Wy, Xy);
    Vn[e] = new mi(e,1,!1,n,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(n) {
    var e = n.replace(Wy, Xy);
    Vn[e] = new mi(e,1,!1,n,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(n) {
    Vn[n] = new mi(n,1,!1,n.toLowerCase(),null,!1,!1)
});
Vn.xlinkHref = new mi("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(n) {
    Vn[n] = new mi(n,1,!1,n.toLowerCase(),null,!0,!0)
});
function Yy(n, e, t, i) {
    var r = Vn.hasOwnProperty(e) ? Vn[e] : null;
    (r !== null ? r.type !== 0 : i || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (s3(e, t, r, i) && (t = null),
    i || r === null ? i3(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t)) : r.mustUseProperty ? n[r.propertyName] = t === null ? r.type === 3 ? !1 : "" : t : (e = r.attributeName,
    i = r.attributeNamespace,
    t === null ? n.removeAttribute(e) : (r = r.type,
    t = r === 3 || r === 4 && t === !0 ? "" : "" + t,
    i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t))))
}
var As = t3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , wh = Symbol.for("react.element")
  , vl = Symbol.for("react.portal")
  , yl = Symbol.for("react.fragment")
  , jy = Symbol.for("react.strict_mode")
  , $0 = Symbol.for("react.profiler")
  , oT = Symbol.for("react.provider")
  , aT = Symbol.for("react.context")
  , qy = Symbol.for("react.forward_ref")
  , ev = Symbol.for("react.suspense")
  , tv = Symbol.for("react.suspense_list")
  , Zy = Symbol.for("react.memo")
  , js = Symbol.for("react.lazy")
  , lT = Symbol.for("react.offscreen")
  , cS = Symbol.iterator;
function Lu(n) {
    return n === null || typeof n != "object" ? null : (n = cS && n[cS] || n["@@iterator"],
    typeof n == "function" ? n : null)
}
var tn = Object.assign, Lg;
function rc(n) {
    if (Lg === void 0)
        try {
            throw Error()
        } catch (t) {
            var e = t.stack.trim().match(/\n( *(at )?)/);
            Lg = e && e[1] || ""
        }
    return `
` + Lg + n
}
var Ig = !1;
function Ng(n, e) {
    if (!n || Ig)
        return "";
    Ig = !0;
    var t = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                throw Error()
            }
            ,
            Object.defineProperty(e.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (f) {
                    var i = f
                }
                Reflect.construct(n, [], e)
            } else {
                try {
                    e.call()
                } catch (f) {
                    i = f
                }
                n.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (f) {
                i = f
            }
            n()
        }
    } catch (f) {
        if (f && i && typeof f.stack == "string") {
            for (var r = f.stack.split(`
`), s = i.stack.split(`
`), o = r.length - 1, a = s.length - 1; 1 <= o && 0 <= a && r[o] !== s[a]; )
                a--;
            for (; 1 <= o && 0 <= a; o--,
            a--)
                if (r[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--,
                            a--,
                            0 > a || r[o] !== s[a]) {
                                var c = `
` + r[o].replace(" at new ", " at ");
                                return n.displayName && c.includes("<anonymous>") && (c = c.replace("<anonymous>", n.displayName)),
                                c
                            }
                        while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        Ig = !1,
        Error.prepareStackTrace = t
    }
    return (n = n ? n.displayName || n.name : "") ? rc(n) : ""
}
function o3(n) {
    switch (n.tag) {
    case 5:
        return rc(n.type);
    case 16:
        return rc("Lazy");
    case 13:
        return rc("Suspense");
    case 19:
        return rc("SuspenseList");
    case 0:
    case 2:
    case 15:
        return n = Ng(n.type, !1),
        n;
    case 11:
        return n = Ng(n.type.render, !1),
        n;
    case 1:
        return n = Ng(n.type, !0),
        n;
    default:
        return ""
    }
}
function nv(n) {
    if (n == null)
        return null;
    if (typeof n == "function")
        return n.displayName || n.name || null;
    if (typeof n == "string")
        return n;
    switch (n) {
    case yl:
        return "Fragment";
    case vl:
        return "Portal";
    case $0:
        return "Profiler";
    case jy:
        return "StrictMode";
    case ev:
        return "Suspense";
    case tv:
        return "SuspenseList"
    }
    if (typeof n == "object")
        switch (n.$$typeof) {
        case aT:
            return (n.displayName || "Context") + ".Consumer";
        case oT:
            return (n._context.displayName || "Context") + ".Provider";
        case qy:
            var e = n.render;
            return n = n.displayName,
            n || (n = e.displayName || e.name || "",
            n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"),
            n;
        case Zy:
            return e = n.displayName || null,
            e !== null ? e : nv(n.type) || "Memo";
        case js:
            e = n._payload,
            n = n._init;
            try {
                return nv(n(e))
            } catch {}
        }
    return null
}
function a3(n) {
    var e = n.type;
    switch (n.tag) {
    case 24:
        return "Cache";
    case 9:
        return (e.displayName || "Context") + ".Consumer";
    case 10:
        return (e._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return n = e.render,
        n = n.displayName || n.name || "",
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return e;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return nv(e);
    case 8:
        return e === jy ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof e == "function")
            return e.displayName || e.name || null;
        if (typeof e == "string")
            return e
    }
    return null
}
function ho(n) {
    switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return n;
    case "object":
        return n;
    default:
        return ""
    }
}
function uT(n) {
    var e = n.type;
    return (n = n.nodeName) && n.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}
function l3(n) {
    var e = uT(n) ? "checked" : "value"
      , t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e)
      , i = "" + n[e];
    if (!n.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") {
        var r = t.get
          , s = t.set;
        return Object.defineProperty(n, e, {
            configurable: !0,
            get: function() {
                return r.call(this)
            },
            set: function(o) {
                i = "" + o,
                s.call(this, o)
            }
        }),
        Object.defineProperty(n, e, {
            enumerable: t.enumerable
        }),
        {
            getValue: function() {
                return i
            },
            setValue: function(o) {
                i = "" + o
            },
            stopTracking: function() {
                n._valueTracker = null,
                delete n[e]
            }
        }
    }
}
function Eh(n) {
    n._valueTracker || (n._valueTracker = l3(n))
}
function cT(n) {
    if (!n)
        return !1;
    var e = n._valueTracker;
    if (!e)
        return !0;
    var t = e.getValue()
      , i = "";
    return n && (i = uT(n) ? n.checked ? "true" : "false" : n.value),
    n = i,
    n !== t ? (e.setValue(n),
    !0) : !1
}
function $d(n) {
    if (n = n || (typeof document < "u" ? document : void 0),
    typeof n > "u")
        return null;
    try {
        return n.activeElement || n.body
    } catch {
        return n.body
    }
}
function iv(n, e) {
    var t = e.checked;
    return tn({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: t ?? n._wrapperState.initialChecked
    })
}
function fS(n, e) {
    var t = e.defaultValue == null ? "" : e.defaultValue
      , i = e.checked != null ? e.checked : e.defaultChecked;
    t = ho(e.value != null ? e.value : t),
    n._wrapperState = {
        initialChecked: i,
        initialValue: t,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}
function fT(n, e) {
    e = e.checked,
    e != null && Yy(n, "checked", e, !1)
}
function rv(n, e) {
    fT(n, e);
    var t = ho(e.value)
      , i = e.type;
    if (t != null)
        i === "number" ? (t === 0 && n.value === "" || n.value != t) && (n.value = "" + t) : n.value !== "" + t && (n.value = "" + t);
    else if (i === "submit" || i === "reset") {
        n.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? sv(n, e.type, t) : e.hasOwnProperty("defaultValue") && sv(n, e.type, ho(e.defaultValue)),
    e.checked == null && e.defaultChecked != null && (n.defaultChecked = !!e.defaultChecked)
}
function hS(n, e, t) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var i = e.type;
        if (!(i !== "submit" && i !== "reset" || e.value !== void 0 && e.value !== null))
            return;
        e = "" + n._wrapperState.initialValue,
        t || e === n.value || (n.value = e),
        n.defaultValue = e
    }
    t = n.name,
    t !== "" && (n.name = ""),
    n.defaultChecked = !!n._wrapperState.initialChecked,
    t !== "" && (n.name = t)
}
function sv(n, e, t) {
    (e !== "number" || $d(n.ownerDocument) !== n) && (t == null ? n.defaultValue = "" + n._wrapperState.initialValue : n.defaultValue !== "" + t && (n.defaultValue = "" + t))
}
var sc = Array.isArray;
function Ul(n, e, t, i) {
    if (n = n.options,
    e) {
        e = {};
        for (var r = 0; r < t.length; r++)
            e["$" + t[r]] = !0;
        for (t = 0; t < n.length; t++)
            r = e.hasOwnProperty("$" + n[t].value),
            n[t].selected !== r && (n[t].selected = r),
            r && i && (n[t].defaultSelected = !0)
    } else {
        for (t = "" + ho(t),
        e = null,
        r = 0; r < n.length; r++) {
            if (n[r].value === t) {
                n[r].selected = !0,
                i && (n[r].defaultSelected = !0);
                return
            }
            e !== null || n[r].disabled || (e = n[r])
        }
        e !== null && (e.selected = !0)
    }
}
function ov(n, e) {
    if (e.dangerouslySetInnerHTML != null)
        throw Error(_e(91));
    return tn({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + n._wrapperState.initialValue
    })
}
function dS(n, e) {
    var t = e.value;
    if (t == null) {
        if (t = e.children,
        e = e.defaultValue,
        t != null) {
            if (e != null)
                throw Error(_e(92));
            if (sc(t)) {
                if (1 < t.length)
                    throw Error(_e(93));
                t = t[0]
            }
            e = t
        }
        e == null && (e = ""),
        t = e
    }
    n._wrapperState = {
        initialValue: ho(t)
    }
}
function hT(n, e) {
    var t = ho(e.value)
      , i = ho(e.defaultValue);
    t != null && (t = "" + t,
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    i != null && (n.defaultValue = "" + i)
}
function pS(n) {
    var e = n.textContent;
    e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e)
}
function dT(n) {
    switch (n) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function av(n, e) {
    return n == null || n === "http://www.w3.org/1999/xhtml" ? dT(e) : n === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n
}
var Th, pT = function(n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, t, i, r) {
        MSApp.execUnsafeLocalFunction(function() {
            return n(e, t, i, r)
        })
    }
    : n
}(function(n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in n)
        n.innerHTML = e;
    else {
        for (Th = Th || document.createElement("div"),
        Th.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
        e = Th.firstChild; n.firstChild; )
            n.removeChild(n.firstChild);
        for (; e.firstChild; )
            n.appendChild(e.firstChild)
    }
});
function Tc(n, e) {
    if (e) {
        var t = n.firstChild;
        if (t && t === n.lastChild && t.nodeType === 3) {
            t.nodeValue = e;
            return
        }
    }
    n.textContent = e
}
var uc = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , u3 = ["Webkit", "ms", "Moz", "O"];
Object.keys(uc).forEach(function(n) {
    u3.forEach(function(e) {
        e = e + n.charAt(0).toUpperCase() + n.substring(1),
        uc[e] = uc[n]
    })
});
function mT(n, e, t) {
    return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || uc.hasOwnProperty(n) && uc[n] ? ("" + e).trim() : e + "px"
}
function gT(n, e) {
    n = n.style;
    for (var t in e)
        if (e.hasOwnProperty(t)) {
            var i = t.indexOf("--") === 0
              , r = mT(t, e[t], i);
            t === "float" && (t = "cssFloat"),
            i ? n.setProperty(t, r) : n[t] = r
        }
}
var c3 = tn({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function lv(n, e) {
    if (e) {
        if (c3[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
            throw Error(_e(137, n));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null)
                throw Error(_e(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html"in e.dangerouslySetInnerHTML))
                throw Error(_e(61))
        }
        if (e.style != null && typeof e.style != "object")
            throw Error(_e(62))
    }
}
function uv(n, e) {
    if (n.indexOf("-") === -1)
        return typeof e.is == "string";
    switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var cv = null;
function Jy(n) {
    return n = n.target || n.srcElement || window,
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
}
var fv = null
  , Ol = null
  , Fl = null;
function mS(n) {
    if (n = df(n)) {
        if (typeof fv != "function")
            throw Error(_e(280));
        var e = n.stateNode;
        e && (e = Fp(e),
        fv(n.stateNode, n.type, e))
    }
}
function vT(n) {
    Ol ? Fl ? Fl.push(n) : Fl = [n] : Ol = n
}
function yT() {
    if (Ol) {
        var n = Ol
          , e = Fl;
        if (Fl = Ol = null,
        mS(n),
        e)
            for (n = 0; n < e.length; n++)
                mS(e[n])
    }
}
function _T(n, e) {
    return n(e)
}
function xT() {}
var Dg = !1;
function ST(n, e, t) {
    if (Dg)
        return n(e, t);
    Dg = !0;
    try {
        return _T(n, e, t)
    } finally {
        Dg = !1,
        (Ol !== null || Fl !== null) && (xT(),
        yT())
    }
}
function Ac(n, e) {
    var t = n.stateNode;
    if (t === null)
        return null;
    var i = Fp(t);
    if (i === null)
        return null;
    t = i[e];
    e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (i = !i.disabled) || (n = n.type,
        i = !(n === "button" || n === "input" || n === "select" || n === "textarea")),
        n = !i;
        break e;
    default:
        n = !1
    }
    if (n)
        return null;
    if (t && typeof t != "function")
        throw Error(_e(231, e, typeof t));
    return t
}
var hv = !1;
if (Ss)
    try {
        var Iu = {};
        Object.defineProperty(Iu, "passive", {
            get: function() {
                hv = !0
            }
        }),
        window.addEventListener("test", Iu, Iu),
        window.removeEventListener("test", Iu, Iu)
    } catch {
        hv = !1
    }
function f3(n, e, t, i, r, s, o, a, c) {
    var f = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(t, f)
    } catch (h) {
        this.onError(h)
    }
}
var cc = !1
  , ep = null
  , tp = !1
  , dv = null
  , h3 = {
    onError: function(n) {
        cc = !0,
        ep = n
    }
};
function d3(n, e, t, i, r, s, o, a, c) {
    cc = !1,
    ep = null,
    f3.apply(h3, arguments)
}
function p3(n, e, t, i, r, s, o, a, c) {
    if (d3.apply(this, arguments),
    cc) {
        if (cc) {
            var f = ep;
            cc = !1,
            ep = null
        } else
            throw Error(_e(198));
        tp || (tp = !0,
        dv = f)
    }
}
function Ma(n) {
    var e = n
      , t = n;
    if (n.alternate)
        for (; e.return; )
            e = e.return;
    else {
        n = e;
        do
            e = n,
            e.flags & 4098 && (t = e.return),
            n = e.return;
        while (n)
    }
    return e.tag === 3 ? t : null
}
function MT(n) {
    if (n.tag === 13) {
        var e = n.memoizedState;
        if (e === null && (n = n.alternate,
        n !== null && (e = n.memoizedState)),
        e !== null)
            return e.dehydrated
    }
    return null
}
function gS(n) {
    if (Ma(n) !== n)
        throw Error(_e(188))
}
function m3(n) {
    var e = n.alternate;
    if (!e) {
        if (e = Ma(n),
        e === null)
            throw Error(_e(188));
        return e !== n ? null : n
    }
    for (var t = n, i = e; ; ) {
        var r = t.return;
        if (r === null)
            break;
        var s = r.alternate;
        if (s === null) {
            if (i = r.return,
            i !== null) {
                t = i;
                continue
            }
            break
        }
        if (r.child === s.child) {
            for (s = r.child; s; ) {
                if (s === t)
                    return gS(r),
                    n;
                if (s === i)
                    return gS(r),
                    e;
                s = s.sibling
            }
            throw Error(_e(188))
        }
        if (t.return !== i.return)
            t = r,
            i = s;
        else {
            for (var o = !1, a = r.child; a; ) {
                if (a === t) {
                    o = !0,
                    t = r,
                    i = s;
                    break
                }
                if (a === i) {
                    o = !0,
                    i = r,
                    t = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a; ) {
                    if (a === t) {
                        o = !0,
                        t = s,
                        i = r;
                        break
                    }
                    if (a === i) {
                        o = !0,
                        i = s,
                        t = r;
                        break
                    }
                    a = a.sibling
                }
                if (!o)
                    throw Error(_e(189))
            }
        }
        if (t.alternate !== i)
            throw Error(_e(190))
    }
    if (t.tag !== 3)
        throw Error(_e(188));
    return t.stateNode.current === t ? n : e
}
function wT(n) {
    return n = m3(n),
    n !== null ? ET(n) : null
}
function ET(n) {
    if (n.tag === 5 || n.tag === 6)
        return n;
    for (n = n.child; n !== null; ) {
        var e = ET(n);
        if (e !== null)
            return e;
        n = n.sibling
    }
    return null
}
var TT = Vi.unstable_scheduleCallback
  , vS = Vi.unstable_cancelCallback
  , g3 = Vi.unstable_shouldYield
  , v3 = Vi.unstable_requestPaint
  , dn = Vi.unstable_now
  , y3 = Vi.unstable_getCurrentPriorityLevel
  , Ky = Vi.unstable_ImmediatePriority
  , AT = Vi.unstable_UserBlockingPriority
  , np = Vi.unstable_NormalPriority
  , _3 = Vi.unstable_LowPriority
  , CT = Vi.unstable_IdlePriority
  , Np = null
  , Xr = null;
function x3(n) {
    if (Xr && typeof Xr.onCommitFiberRoot == "function")
        try {
            Xr.onCommitFiberRoot(Np, n, void 0, (n.current.flags & 128) === 128)
        } catch {}
}
var Er = Math.clz32 ? Math.clz32 : w3
  , S3 = Math.log
  , M3 = Math.LN2;
function w3(n) {
    return n >>>= 0,
    n === 0 ? 32 : 31 - (S3(n) / M3 | 0) | 0
}
var Ah = 64
  , Ch = 4194304;
function oc(n) {
    switch (n & -n) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return n & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return n
    }
}
function ip(n, e) {
    var t = n.pendingLanes;
    if (t === 0)
        return 0;
    var i = 0
      , r = n.suspendedLanes
      , s = n.pingedLanes
      , o = t & 268435455;
    if (o !== 0) {
        var a = o & ~r;
        a !== 0 ? i = oc(a) : (s &= o,
        s !== 0 && (i = oc(s)))
    } else
        o = t & ~r,
        o !== 0 ? i = oc(o) : s !== 0 && (i = oc(s));
    if (i === 0)
        return 0;
    if (e !== 0 && e !== i && !(e & r) && (r = i & -i,
    s = e & -e,
    r >= s || r === 16 && (s & 4194240) !== 0))
        return e;
    if (i & 4 && (i |= t & 16),
    e = n.entangledLanes,
    e !== 0)
        for (n = n.entanglements,
        e &= i; 0 < e; )
            t = 31 - Er(e),
            r = 1 << t,
            i |= n[t],
            e &= ~r;
    return i
}
function E3(n, e) {
    switch (n) {
    case 1:
    case 2:
    case 4:
        return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function T3(n, e) {
    for (var t = n.suspendedLanes, i = n.pingedLanes, r = n.expirationTimes, s = n.pendingLanes; 0 < s; ) {
        var o = 31 - Er(s)
          , a = 1 << o
          , c = r[o];
        c === -1 ? (!(a & t) || a & i) && (r[o] = E3(a, e)) : c <= e && (n.expiredLanes |= a),
        s &= ~a
    }
}
function pv(n) {
    return n = n.pendingLanes & -1073741825,
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
}
function RT() {
    var n = Ah;
    return Ah <<= 1,
    !(Ah & 4194240) && (Ah = 64),
    n
}
function Ug(n) {
    for (var e = [], t = 0; 31 > t; t++)
        e.push(n);
    return e
}
function ff(n, e, t) {
    n.pendingLanes |= e,
    e !== 536870912 && (n.suspendedLanes = 0,
    n.pingedLanes = 0),
    n = n.eventTimes,
    e = 31 - Er(e),
    n[e] = t
}
function A3(n, e) {
    var t = n.pendingLanes & ~e;
    n.pendingLanes = e,
    n.suspendedLanes = 0,
    n.pingedLanes = 0,
    n.expiredLanes &= e,
    n.mutableReadLanes &= e,
    n.entangledLanes &= e,
    e = n.entanglements;
    var i = n.eventTimes;
    for (n = n.expirationTimes; 0 < t; ) {
        var r = 31 - Er(t)
          , s = 1 << r;
        e[r] = 0,
        i[r] = -1,
        n[r] = -1,
        t &= ~s
    }
}
function Qy(n, e) {
    var t = n.entangledLanes |= e;
    for (n = n.entanglements; t; ) {
        var i = 31 - Er(t)
          , r = 1 << i;
        r & e | n[i] & e && (n[i] |= e),
        t &= ~r
    }
}
var Ot = 0;
function bT(n) {
    return n &= -n,
    1 < n ? 4 < n ? n & 268435455 ? 16 : 536870912 : 4 : 1
}
var PT, $y, LT, IT, NT, mv = !1, Rh = [], to = null, no = null, io = null, Cc = new Map, Rc = new Map, Js = [], C3 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function yS(n, e) {
    switch (n) {
    case "focusin":
    case "focusout":
        to = null;
        break;
    case "dragenter":
    case "dragleave":
        no = null;
        break;
    case "mouseover":
    case "mouseout":
        io = null;
        break;
    case "pointerover":
    case "pointerout":
        Cc.delete(e.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        Rc.delete(e.pointerId)
    }
}
function Nu(n, e, t, i, r, s) {
    return n === null || n.nativeEvent !== s ? (n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r]
    },
    e !== null && (e = df(e),
    e !== null && $y(e)),
    n) : (n.eventSystemFlags |= i,
    e = n.targetContainers,
    r !== null && e.indexOf(r) === -1 && e.push(r),
    n)
}
function R3(n, e, t, i, r) {
    switch (e) {
    case "focusin":
        return to = Nu(to, n, e, t, i, r),
        !0;
    case "dragenter":
        return no = Nu(no, n, e, t, i, r),
        !0;
    case "mouseover":
        return io = Nu(io, n, e, t, i, r),
        !0;
    case "pointerover":
        var s = r.pointerId;
        return Cc.set(s, Nu(Cc.get(s) || null, n, e, t, i, r)),
        !0;
    case "gotpointercapture":
        return s = r.pointerId,
        Rc.set(s, Nu(Rc.get(s) || null, n, e, t, i, r)),
        !0
    }
    return !1
}
function DT(n) {
    var e = Qo(n.target);
    if (e !== null) {
        var t = Ma(e);
        if (t !== null) {
            if (e = t.tag,
            e === 13) {
                if (e = MT(t),
                e !== null) {
                    n.blockedOn = e,
                    NT(n.priority, function() {
                        LT(t)
                    });
                    return
                }
            } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
                n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
                return
            }
        }
    }
    n.blockedOn = null
}
function Ud(n) {
    if (n.blockedOn !== null)
        return !1;
    for (var e = n.targetContainers; 0 < e.length; ) {
        var t = gv(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
        if (t === null) {
            t = n.nativeEvent;
            var i = new t.constructor(t.type,t);
            cv = i,
            t.target.dispatchEvent(i),
            cv = null
        } else
            return e = df(t),
            e !== null && $y(e),
            n.blockedOn = t,
            !1;
        e.shift()
    }
    return !0
}
function _S(n, e, t) {
    Ud(n) && t.delete(e)
}
function b3() {
    mv = !1,
    to !== null && Ud(to) && (to = null),
    no !== null && Ud(no) && (no = null),
    io !== null && Ud(io) && (io = null),
    Cc.forEach(_S),
    Rc.forEach(_S)
}
function Du(n, e) {
    n.blockedOn === e && (n.blockedOn = null,
    mv || (mv = !0,
    Vi.unstable_scheduleCallback(Vi.unstable_NormalPriority, b3)))
}
function bc(n) {
    function e(r) {
        return Du(r, n)
    }
    if (0 < Rh.length) {
        Du(Rh[0], n);
        for (var t = 1; t < Rh.length; t++) {
            var i = Rh[t];
            i.blockedOn === n && (i.blockedOn = null)
        }
    }
    for (to !== null && Du(to, n),
    no !== null && Du(no, n),
    io !== null && Du(io, n),
    Cc.forEach(e),
    Rc.forEach(e),
    t = 0; t < Js.length; t++)
        i = Js[t],
        i.blockedOn === n && (i.blockedOn = null);
    for (; 0 < Js.length && (t = Js[0],
    t.blockedOn === null); )
        DT(t),
        t.blockedOn === null && Js.shift()
}
var kl = As.ReactCurrentBatchConfig
  , rp = !0;
function P3(n, e, t, i) {
    var r = Ot
      , s = kl.transition;
    kl.transition = null;
    try {
        Ot = 1,
        e_(n, e, t, i)
    } finally {
        Ot = r,
        kl.transition = s
    }
}
function L3(n, e, t, i) {
    var r = Ot
      , s = kl.transition;
    kl.transition = null;
    try {
        Ot = 4,
        e_(n, e, t, i)
    } finally {
        Ot = r,
        kl.transition = s
    }
}
function e_(n, e, t, i) {
    if (rp) {
        var r = gv(n, e, t, i);
        if (r === null)
            Xg(n, e, i, sp, t),
            yS(n, i);
        else if (R3(r, n, e, t, i))
            i.stopPropagation();
        else if (yS(n, i),
        e & 4 && -1 < C3.indexOf(n)) {
            for (; r !== null; ) {
                var s = df(r);
                if (s !== null && PT(s),
                s = gv(n, e, t, i),
                s === null && Xg(n, e, i, sp, t),
                s === r)
                    break;
                r = s
            }
            r !== null && i.stopPropagation()
        } else
            Xg(n, e, i, null, t)
    }
}
var sp = null;
function gv(n, e, t, i) {
    if (sp = null,
    n = Jy(i),
    n = Qo(n),
    n !== null)
        if (e = Ma(n),
        e === null)
            n = null;
        else if (t = e.tag,
        t === 13) {
            if (n = MT(e),
            n !== null)
                return n;
            n = null
        } else if (t === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
                return e.tag === 3 ? e.stateNode.containerInfo : null;
            n = null
        } else
            e !== n && (n = null);
    return sp = n,
    null
}
function UT(n) {
    switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (y3()) {
        case Ky:
            return 1;
        case AT:
            return 4;
        case np:
        case _3:
            return 16;
        case CT:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var $s = null
  , t_ = null
  , Od = null;
function OT() {
    if (Od)
        return Od;
    var n, e = t_, t = e.length, i, r = "value"in $s ? $s.value : $s.textContent, s = r.length;
    for (n = 0; n < t && e[n] === r[n]; n++)
        ;
    var o = t - n;
    for (i = 1; i <= o && e[t - i] === r[s - i]; i++)
        ;
    return Od = r.slice(n, 1 < i ? 1 - i : void 0)
}
function Fd(n) {
    var e = n.keyCode;
    return "charCode"in n ? (n = n.charCode,
    n === 0 && e === 13 && (n = 13)) : n = e,
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
}
function bh() {
    return !0
}
function xS() {
    return !1
}
function Wi(n) {
    function e(t, i, r, s, o) {
        this._reactName = t,
        this._targetInst = r,
        this.type = i,
        this.nativeEvent = s,
        this.target = o,
        this.currentTarget = null;
        for (var a in n)
            n.hasOwnProperty(a) && (t = n[a],
            this[a] = t ? t(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? bh : xS,
        this.isPropagationStopped = xS,
        this
    }
    return tn(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var t = this.nativeEvent;
            t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = !1),
            this.isDefaultPrevented = bh)
        },
        stopPropagation: function() {
            var t = this.nativeEvent;
            t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
            this.isPropagationStopped = bh)
        },
        persist: function() {},
        isPersistent: bh
    }),
    e
}
var nu = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(n) {
        return n.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, n_ = Wi(nu), hf = tn({}, nu, {
    view: 0,
    detail: 0
}), I3 = Wi(hf), Og, Fg, Uu, Dp = tn({}, hf, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: i_,
    button: 0,
    buttons: 0,
    relatedTarget: function(n) {
        return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget
    },
    movementX: function(n) {
        return "movementX"in n ? n.movementX : (n !== Uu && (Uu && n.type === "mousemove" ? (Og = n.screenX - Uu.screenX,
        Fg = n.screenY - Uu.screenY) : Fg = Og = 0,
        Uu = n),
        Og)
    },
    movementY: function(n) {
        return "movementY"in n ? n.movementY : Fg
    }
}), SS = Wi(Dp), N3 = tn({}, Dp, {
    dataTransfer: 0
}), D3 = Wi(N3), U3 = tn({}, hf, {
    relatedTarget: 0
}), kg = Wi(U3), O3 = tn({}, nu, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), F3 = Wi(O3), k3 = tn({}, nu, {
    clipboardData: function(n) {
        return "clipboardData"in n ? n.clipboardData : window.clipboardData
    }
}), z3 = Wi(k3), B3 = tn({}, nu, {
    data: 0
}), MS = Wi(B3), H3 = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, V3 = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, G3 = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function W3(n) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(n) : (n = G3[n]) ? !!e[n] : !1
}
function i_() {
    return W3
}
var X3 = tn({}, hf, {
    key: function(n) {
        if (n.key) {
            var e = H3[n.key] || n.key;
            if (e !== "Unidentified")
                return e
        }
        return n.type === "keypress" ? (n = Fd(n),
        n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? V3[n.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: i_,
    charCode: function(n) {
        return n.type === "keypress" ? Fd(n) : 0
    },
    keyCode: function(n) {
        return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
    },
    which: function(n) {
        return n.type === "keypress" ? Fd(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
    }
})
  , Y3 = Wi(X3)
  , j3 = tn({}, Dp, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , wS = Wi(j3)
  , q3 = tn({}, hf, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: i_
})
  , Z3 = Wi(q3)
  , J3 = tn({}, nu, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , K3 = Wi(J3)
  , Q3 = tn({}, Dp, {
    deltaX: function(n) {
        return "deltaX"in n ? n.deltaX : "wheelDeltaX"in n ? -n.wheelDeltaX : 0
    },
    deltaY: function(n) {
        return "deltaY"in n ? n.deltaY : "wheelDeltaY"in n ? -n.wheelDeltaY : "wheelDelta"in n ? -n.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , $3 = Wi(Q3)
  , eP = [9, 13, 27, 32]
  , r_ = Ss && "CompositionEvent"in window
  , fc = null;
Ss && "documentMode"in document && (fc = document.documentMode);
var tP = Ss && "TextEvent"in window && !fc
  , FT = Ss && (!r_ || fc && 8 < fc && 11 >= fc)
  , ES = " "
  , TS = !1;
function kT(n, e) {
    switch (n) {
    case "keyup":
        return eP.indexOf(e.keyCode) !== -1;
    case "keydown":
        return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function zT(n) {
    return n = n.detail,
    typeof n == "object" && "data"in n ? n.data : null
}
var _l = !1;
function nP(n, e) {
    switch (n) {
    case "compositionend":
        return zT(e);
    case "keypress":
        return e.which !== 32 ? null : (TS = !0,
        ES);
    case "textInput":
        return n = e.data,
        n === ES && TS ? null : n;
    default:
        return null
    }
}
function iP(n, e) {
    if (_l)
        return n === "compositionend" || !r_ && kT(n, e) ? (n = OT(),
        Od = t_ = $s = null,
        _l = !1,
        n) : null;
    switch (n) {
    case "paste":
        return null;
    case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
            if (e.char && 1 < e.char.length)
                return e.char;
            if (e.which)
                return String.fromCharCode(e.which)
        }
        return null;
    case "compositionend":
        return FT && e.locale !== "ko" ? null : e.data;
    default:
        return null
    }
}
var rP = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function AS(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e === "input" ? !!rP[n.type] : e === "textarea"
}
function BT(n, e, t, i) {
    vT(i),
    e = op(e, "onChange"),
    0 < e.length && (t = new n_("onChange","change",null,t,i),
    n.push({
        event: t,
        listeners: e
    }))
}
var hc = null
  , Pc = null;
function sP(n) {
    KT(n, 0)
}
function Up(n) {
    var e = Ml(n);
    if (cT(e))
        return n
}
function oP(n, e) {
    if (n === "change")
        return e
}
var HT = !1;
if (Ss) {
    var zg;
    if (Ss) {
        var Bg = "oninput"in document;
        if (!Bg) {
            var CS = document.createElement("div");
            CS.setAttribute("oninput", "return;"),
            Bg = typeof CS.oninput == "function"
        }
        zg = Bg
    } else
        zg = !1;
    HT = zg && (!document.documentMode || 9 < document.documentMode)
}
function RS() {
    hc && (hc.detachEvent("onpropertychange", VT),
    Pc = hc = null)
}
function VT(n) {
    if (n.propertyName === "value" && Up(Pc)) {
        var e = [];
        BT(e, Pc, n, Jy(n)),
        ST(sP, e)
    }
}
function aP(n, e, t) {
    n === "focusin" ? (RS(),
    hc = e,
    Pc = t,
    hc.attachEvent("onpropertychange", VT)) : n === "focusout" && RS()
}
function lP(n) {
    if (n === "selectionchange" || n === "keyup" || n === "keydown")
        return Up(Pc)
}
function uP(n, e) {
    if (n === "click")
        return Up(e)
}
function cP(n, e) {
    if (n === "input" || n === "change")
        return Up(e)
}
function fP(n, e) {
    return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e
}
var Cr = typeof Object.is == "function" ? Object.is : fP;
function Lc(n, e) {
    if (Cr(n, e))
        return !0;
    if (typeof n != "object" || n === null || typeof e != "object" || e === null)
        return !1;
    var t = Object.keys(n)
      , i = Object.keys(e);
    if (t.length !== i.length)
        return !1;
    for (i = 0; i < t.length; i++) {
        var r = t[i];
        if (!Q0.call(e, r) || !Cr(n[r], e[r]))
            return !1
    }
    return !0
}
function bS(n) {
    for (; n && n.firstChild; )
        n = n.firstChild;
    return n
}
function PS(n, e) {
    var t = bS(n);
    n = 0;
    for (var i; t; ) {
        if (t.nodeType === 3) {
            if (i = n + t.textContent.length,
            n <= e && i >= e)
                return {
                    node: t,
                    offset: e - n
                };
            n = i
        }
        e: {
            for (; t; ) {
                if (t.nextSibling) {
                    t = t.nextSibling;
                    break e
                }
                t = t.parentNode
            }
            t = void 0
        }
        t = bS(t)
    }
}
function GT(n, e) {
    return n && e ? n === e ? !0 : n && n.nodeType === 3 ? !1 : e && e.nodeType === 3 ? GT(n, e.parentNode) : "contains"in n ? n.contains(e) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(e) & 16) : !1 : !1
}
function WT() {
    for (var n = window, e = $d(); e instanceof n.HTMLIFrameElement; ) {
        try {
            var t = typeof e.contentWindow.location.href == "string"
        } catch {
            t = !1
        }
        if (t)
            n = e.contentWindow;
        else
            break;
        e = $d(n.document)
    }
    return e
}
function s_(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e && (e === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || e === "textarea" || n.contentEditable === "true")
}
function hP(n) {
    var e = WT()
      , t = n.focusedElem
      , i = n.selectionRange;
    if (e !== t && t && t.ownerDocument && GT(t.ownerDocument.documentElement, t)) {
        if (i !== null && s_(t)) {
            if (e = i.start,
            n = i.end,
            n === void 0 && (n = e),
            "selectionStart"in t)
                t.selectionStart = e,
                t.selectionEnd = Math.min(n, t.value.length);
            else if (n = (e = t.ownerDocument || document) && e.defaultView || window,
            n.getSelection) {
                n = n.getSelection();
                var r = t.textContent.length
                  , s = Math.min(i.start, r);
                i = i.end === void 0 ? s : Math.min(i.end, r),
                !n.extend && s > i && (r = i,
                i = s,
                s = r),
                r = PS(t, s);
                var o = PS(t, i);
                r && o && (n.rangeCount !== 1 || n.anchorNode !== r.node || n.anchorOffset !== r.offset || n.focusNode !== o.node || n.focusOffset !== o.offset) && (e = e.createRange(),
                e.setStart(r.node, r.offset),
                n.removeAllRanges(),
                s > i ? (n.addRange(e),
                n.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset),
                n.addRange(e)))
            }
        }
        for (e = [],
        n = t; n = n.parentNode; )
            n.nodeType === 1 && e.push({
                element: n,
                left: n.scrollLeft,
                top: n.scrollTop
            });
        for (typeof t.focus == "function" && t.focus(),
        t = 0; t < e.length; t++)
            n = e[t],
            n.element.scrollLeft = n.left,
            n.element.scrollTop = n.top
    }
}
var dP = Ss && "documentMode"in document && 11 >= document.documentMode
  , xl = null
  , vv = null
  , dc = null
  , yv = !1;
function LS(n, e, t) {
    var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
    yv || xl == null || xl !== $d(i) || (i = xl,
    "selectionStart"in i && s_(i) ? i = {
        start: i.selectionStart,
        end: i.selectionEnd
    } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(),
    i = {
        anchorNode: i.anchorNode,
        anchorOffset: i.anchorOffset,
        focusNode: i.focusNode,
        focusOffset: i.focusOffset
    }),
    dc && Lc(dc, i) || (dc = i,
    i = op(vv, "onSelect"),
    0 < i.length && (e = new n_("onSelect","select",null,e,t),
    n.push({
        event: e,
        listeners: i
    }),
    e.target = xl)))
}
function Ph(n, e) {
    var t = {};
    return t[n.toLowerCase()] = e.toLowerCase(),
    t["Webkit" + n] = "webkit" + e,
    t["Moz" + n] = "moz" + e,
    t
}
var Sl = {
    animationend: Ph("Animation", "AnimationEnd"),
    animationiteration: Ph("Animation", "AnimationIteration"),
    animationstart: Ph("Animation", "AnimationStart"),
    transitionend: Ph("Transition", "TransitionEnd")
}
  , Hg = {}
  , XT = {};
Ss && (XT = document.createElement("div").style,
"AnimationEvent"in window || (delete Sl.animationend.animation,
delete Sl.animationiteration.animation,
delete Sl.animationstart.animation),
"TransitionEvent"in window || delete Sl.transitionend.transition);
function Op(n) {
    if (Hg[n])
        return Hg[n];
    if (!Sl[n])
        return n;
    var e = Sl[n], t;
    for (t in e)
        if (e.hasOwnProperty(t) && t in XT)
            return Hg[n] = e[t];
    return n
}
var YT = Op("animationend")
  , jT = Op("animationiteration")
  , qT = Op("animationstart")
  , ZT = Op("transitionend")
  , JT = new Map
  , IS = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function vo(n, e) {
    JT.set(n, e),
    Sa(e, [n])
}
for (var Vg = 0; Vg < IS.length; Vg++) {
    var Gg = IS[Vg]
      , pP = Gg.toLowerCase()
      , mP = Gg[0].toUpperCase() + Gg.slice(1);
    vo(pP, "on" + mP)
}
vo(YT, "onAnimationEnd");
vo(jT, "onAnimationIteration");
vo(qT, "onAnimationStart");
vo("dblclick", "onDoubleClick");
vo("focusin", "onFocus");
vo("focusout", "onBlur");
vo(ZT, "onTransitionEnd");
Gl("onMouseEnter", ["mouseout", "mouseover"]);
Gl("onMouseLeave", ["mouseout", "mouseover"]);
Gl("onPointerEnter", ["pointerout", "pointerover"]);
Gl("onPointerLeave", ["pointerout", "pointerover"]);
Sa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Sa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Sa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Sa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Sa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Sa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var ac = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , gP = new Set("cancel close invalid load scroll toggle".split(" ").concat(ac));
function NS(n, e, t) {
    var i = n.type || "unknown-event";
    n.currentTarget = t,
    p3(i, e, void 0, n),
    n.currentTarget = null
}
function KT(n, e) {
    e = (e & 4) !== 0;
    for (var t = 0; t < n.length; t++) {
        var i = n[t]
          , r = i.event;
        i = i.listeners;
        e: {
            var s = void 0;
            if (e)
                for (var o = i.length - 1; 0 <= o; o--) {
                    var a = i[o]
                      , c = a.instance
                      , f = a.currentTarget;
                    if (a = a.listener,
                    c !== s && r.isPropagationStopped())
                        break e;
                    NS(r, a, f),
                    s = c
                }
            else
                for (o = 0; o < i.length; o++) {
                    if (a = i[o],
                    c = a.instance,
                    f = a.currentTarget,
                    a = a.listener,
                    c !== s && r.isPropagationStopped())
                        break e;
                    NS(r, a, f),
                    s = c
                }
        }
    }
    if (tp)
        throw n = dv,
        tp = !1,
        dv = null,
        n
}
function Gt(n, e) {
    var t = e[wv];
    t === void 0 && (t = e[wv] = new Set);
    var i = n + "__bubble";
    t.has(i) || (QT(e, n, 2, !1),
    t.add(i))
}
function Wg(n, e, t) {
    var i = 0;
    e && (i |= 4),
    QT(t, n, i, e)
}
var Lh = "_reactListening" + Math.random().toString(36).slice(2);
function Ic(n) {
    if (!n[Lh]) {
        n[Lh] = !0,
        sT.forEach(function(t) {
            t !== "selectionchange" && (gP.has(t) || Wg(t, !1, n),
            Wg(t, !0, n))
        });
        var e = n.nodeType === 9 ? n : n.ownerDocument;
        e === null || e[Lh] || (e[Lh] = !0,
        Wg("selectionchange", !1, e))
    }
}
function QT(n, e, t, i) {
    switch (UT(e)) {
    case 1:
        var r = P3;
        break;
    case 4:
        r = L3;
        break;
    default:
        r = e_
    }
    t = r.bind(null, e, t, n),
    r = void 0,
    !hv || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0),
    i ? r !== void 0 ? n.addEventListener(e, t, {
        capture: !0,
        passive: r
    }) : n.addEventListener(e, t, !0) : r !== void 0 ? n.addEventListener(e, t, {
        passive: r
    }) : n.addEventListener(e, t, !1)
}
function Xg(n, e, t, i, r) {
    var s = i;
    if (!(e & 1) && !(e & 2) && i !== null)
        e: for (; ; ) {
            if (i === null)
                return;
            var o = i.tag;
            if (o === 3 || o === 4) {
                var a = i.stateNode.containerInfo;
                if (a === r || a.nodeType === 8 && a.parentNode === r)
                    break;
                if (o === 4)
                    for (o = i.return; o !== null; ) {
                        var c = o.tag;
                        if ((c === 3 || c === 4) && (c = o.stateNode.containerInfo,
                        c === r || c.nodeType === 8 && c.parentNode === r))
                            return;
                        o = o.return
                    }
                for (; a !== null; ) {
                    if (o = Qo(a),
                    o === null)
                        return;
                    if (c = o.tag,
                    c === 5 || c === 6) {
                        i = s = o;
                        continue e
                    }
                    a = a.parentNode
                }
            }
            i = i.return
        }
    ST(function() {
        var f = s
          , h = Jy(t)
          , d = [];
        e: {
            var m = JT.get(n);
            if (m !== void 0) {
                var v = n_
                  , _ = n;
                switch (n) {
                case "keypress":
                    if (Fd(t) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    v = Y3;
                    break;
                case "focusin":
                    _ = "focus",
                    v = kg;
                    break;
                case "focusout":
                    _ = "blur",
                    v = kg;
                    break;
                case "beforeblur":
                case "afterblur":
                    v = kg;
                    break;
                case "click":
                    if (t.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    v = SS;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    v = D3;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    v = Z3;
                    break;
                case YT:
                case jT:
                case qT:
                    v = F3;
                    break;
                case ZT:
                    v = K3;
                    break;
                case "scroll":
                    v = I3;
                    break;
                case "wheel":
                    v = $3;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    v = z3;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    v = wS
                }
                var w = (e & 4) !== 0
                  , x = !w && n === "scroll"
                  , g = w ? m !== null ? m + "Capture" : null : m;
                w = [];
                for (var S = f, M; S !== null; ) {
                    M = S;
                    var T = M.stateNode;
                    if (M.tag === 5 && T !== null && (M = T,
                    g !== null && (T = Ac(S, g),
                    T != null && w.push(Nc(S, T, M)))),
                    x)
                        break;
                    S = S.return
                }
                0 < w.length && (m = new v(m,_,null,t,h),
                d.push({
                    event: m,
                    listeners: w
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (m = n === "mouseover" || n === "pointerover",
                v = n === "mouseout" || n === "pointerout",
                m && t !== cv && (_ = t.relatedTarget || t.fromElement) && (Qo(_) || _[Ms]))
                    break e;
                if ((v || m) && (m = h.window === h ? h : (m = h.ownerDocument) ? m.defaultView || m.parentWindow : window,
                v ? (_ = t.relatedTarget || t.toElement,
                v = f,
                _ = _ ? Qo(_) : null,
                _ !== null && (x = Ma(_),
                _ !== x || _.tag !== 5 && _.tag !== 6) && (_ = null)) : (v = null,
                _ = f),
                v !== _)) {
                    if (w = SS,
                    T = "onMouseLeave",
                    g = "onMouseEnter",
                    S = "mouse",
                    (n === "pointerout" || n === "pointerover") && (w = wS,
                    T = "onPointerLeave",
                    g = "onPointerEnter",
                    S = "pointer"),
                    x = v == null ? m : Ml(v),
                    M = _ == null ? m : Ml(_),
                    m = new w(T,S + "leave",v,t,h),
                    m.target = x,
                    m.relatedTarget = M,
                    T = null,
                    Qo(h) === f && (w = new w(g,S + "enter",_,t,h),
                    w.target = M,
                    w.relatedTarget = x,
                    T = w),
                    x = T,
                    v && _)
                        t: {
                            for (w = v,
                            g = _,
                            S = 0,
                            M = w; M; M = Ga(M))
                                S++;
                            for (M = 0,
                            T = g; T; T = Ga(T))
                                M++;
                            for (; 0 < S - M; )
                                w = Ga(w),
                                S--;
                            for (; 0 < M - S; )
                                g = Ga(g),
                                M--;
                            for (; S--; ) {
                                if (w === g || g !== null && w === g.alternate)
                                    break t;
                                w = Ga(w),
                                g = Ga(g)
                            }
                            w = null
                        }
                    else
                        w = null;
                    v !== null && DS(d, m, v, w, !1),
                    _ !== null && x !== null && DS(d, x, _, w, !0)
                }
            }
            e: {
                if (m = f ? Ml(f) : window,
                v = m.nodeName && m.nodeName.toLowerCase(),
                v === "select" || v === "input" && m.type === "file")
                    var P = oP;
                else if (AS(m))
                    if (HT)
                        P = cP;
                    else {
                        P = lP;
                        var R = aP
                    }
                else
                    (v = m.nodeName) && v.toLowerCase() === "input" && (m.type === "checkbox" || m.type === "radio") && (P = uP);
                if (P && (P = P(n, f))) {
                    BT(d, P, t, h);
                    break e
                }
                R && R(n, m, f),
                n === "focusout" && (R = m._wrapperState) && R.controlled && m.type === "number" && sv(m, "number", m.value)
            }
            switch (R = f ? Ml(f) : window,
            n) {
            case "focusin":
                (AS(R) || R.contentEditable === "true") && (xl = R,
                vv = f,
                dc = null);
                break;
            case "focusout":
                dc = vv = xl = null;
                break;
            case "mousedown":
                yv = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                yv = !1,
                LS(d, t, h);
                break;
            case "selectionchange":
                if (dP)
                    break;
            case "keydown":
            case "keyup":
                LS(d, t, h)
            }
            var b;
            if (r_)
                e: {
                    switch (n) {
                    case "compositionstart":
                        var N = "onCompositionStart";
                        break e;
                    case "compositionend":
                        N = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        N = "onCompositionUpdate";
                        break e
                    }
                    N = void 0
                }
            else
                _l ? kT(n, t) && (N = "onCompositionEnd") : n === "keydown" && t.keyCode === 229 && (N = "onCompositionStart");
            N && (FT && t.locale !== "ko" && (_l || N !== "onCompositionStart" ? N === "onCompositionEnd" && _l && (b = OT()) : ($s = h,
            t_ = "value"in $s ? $s.value : $s.textContent,
            _l = !0)),
            R = op(f, N),
            0 < R.length && (N = new MS(N,n,null,t,h),
            d.push({
                event: N,
                listeners: R
            }),
            b ? N.data = b : (b = zT(t),
            b !== null && (N.data = b)))),
            (b = tP ? nP(n, t) : iP(n, t)) && (f = op(f, "onBeforeInput"),
            0 < f.length && (h = new MS("onBeforeInput","beforeinput",null,t,h),
            d.push({
                event: h,
                listeners: f
            }),
            h.data = b))
        }
        KT(d, e)
    })
}
function Nc(n, e, t) {
    return {
        instance: n,
        listener: e,
        currentTarget: t
    }
}
function op(n, e) {
    for (var t = e + "Capture", i = []; n !== null; ) {
        var r = n
          , s = r.stateNode;
        r.tag === 5 && s !== null && (r = s,
        s = Ac(n, t),
        s != null && i.unshift(Nc(n, s, r)),
        s = Ac(n, e),
        s != null && i.push(Nc(n, s, r))),
        n = n.return
    }
    return i
}
function Ga(n) {
    if (n === null)
        return null;
    do
        n = n.return;
    while (n && n.tag !== 5);
    return n || null
}
function DS(n, e, t, i, r) {
    for (var s = e._reactName, o = []; t !== null && t !== i; ) {
        var a = t
          , c = a.alternate
          , f = a.stateNode;
        if (c !== null && c === i)
            break;
        a.tag === 5 && f !== null && (a = f,
        r ? (c = Ac(t, s),
        c != null && o.unshift(Nc(t, c, a))) : r || (c = Ac(t, s),
        c != null && o.push(Nc(t, c, a)))),
        t = t.return
    }
    o.length !== 0 && n.push({
        event: e,
        listeners: o
    })
}
var vP = /\r\n?/g
  , yP = /\u0000|\uFFFD/g;
function US(n) {
    return (typeof n == "string" ? n : "" + n).replace(vP, `
`).replace(yP, "")
}
function Ih(n, e, t) {
    if (e = US(e),
    US(n) !== e && t)
        throw Error(_e(425))
}
function ap() {}
var _v = null
  , xv = null;
function Sv(n, e) {
    return n === "textarea" || n === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var Mv = typeof setTimeout == "function" ? setTimeout : void 0
  , _P = typeof clearTimeout == "function" ? clearTimeout : void 0
  , OS = typeof Promise == "function" ? Promise : void 0
  , xP = typeof queueMicrotask == "function" ? queueMicrotask : typeof OS < "u" ? function(n) {
    return OS.resolve(null).then(n).catch(SP)
}
: Mv;
function SP(n) {
    setTimeout(function() {
        throw n
    })
}
function Yg(n, e) {
    var t = e
      , i = 0;
    do {
        var r = t.nextSibling;
        if (n.removeChild(t),
        r && r.nodeType === 8)
            if (t = r.data,
            t === "/$") {
                if (i === 0) {
                    n.removeChild(r),
                    bc(e);
                    return
                }
                i--
            } else
                t !== "$" && t !== "$?" && t !== "$!" || i++;
        t = r
    } while (t);
    bc(e)
}
function ro(n) {
    for (; n != null; n = n.nextSibling) {
        var e = n.nodeType;
        if (e === 1 || e === 3)
            break;
        if (e === 8) {
            if (e = n.data,
            e === "$" || e === "$!" || e === "$?")
                break;
            if (e === "/$")
                return null
        }
    }
    return n
}
function FS(n) {
    n = n.previousSibling;
    for (var e = 0; n; ) {
        if (n.nodeType === 8) {
            var t = n.data;
            if (t === "$" || t === "$!" || t === "$?") {
                if (e === 0)
                    return n;
                e--
            } else
                t === "/$" && e++
        }
        n = n.previousSibling
    }
    return null
}
var iu = Math.random().toString(36).slice(2)
  , Hr = "__reactFiber$" + iu
  , Dc = "__reactProps$" + iu
  , Ms = "__reactContainer$" + iu
  , wv = "__reactEvents$" + iu
  , MP = "__reactListeners$" + iu
  , wP = "__reactHandles$" + iu;
function Qo(n) {
    var e = n[Hr];
    if (e)
        return e;
    for (var t = n.parentNode; t; ) {
        if (e = t[Ms] || t[Hr]) {
            if (t = e.alternate,
            e.child !== null || t !== null && t.child !== null)
                for (n = FS(n); n !== null; ) {
                    if (t = n[Hr])
                        return t;
                    n = FS(n)
                }
            return e
        }
        n = t,
        t = n.parentNode
    }
    return null
}
function df(n) {
    return n = n[Hr] || n[Ms],
    !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3 ? null : n
}
function Ml(n) {
    if (n.tag === 5 || n.tag === 6)
        return n.stateNode;
    throw Error(_e(33))
}
function Fp(n) {
    return n[Dc] || null
}
var Ev = []
  , wl = -1;
function yo(n) {
    return {
        current: n
    }
}
function Xt(n) {
    0 > wl || (n.current = Ev[wl],
    Ev[wl] = null,
    wl--)
}
function Ht(n, e) {
    wl++,
    Ev[wl] = n.current,
    n.current = e
}
var po = {}
  , ii = yo(po)
  , Ti = yo(!1)
  , ha = po;
function Wl(n, e) {
    var t = n.type.contextTypes;
    if (!t)
        return po;
    var i = n.stateNode;
    if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
        return i.__reactInternalMemoizedMaskedChildContext;
    var r = {}, s;
    for (s in t)
        r[s] = e[s];
    return i && (n = n.stateNode,
    n.__reactInternalMemoizedUnmaskedChildContext = e,
    n.__reactInternalMemoizedMaskedChildContext = r),
    r
}
function Ai(n) {
    return n = n.childContextTypes,
    n != null
}
function lp() {
    Xt(Ti),
    Xt(ii)
}
function kS(n, e, t) {
    if (ii.current !== po)
        throw Error(_e(168));
    Ht(ii, e),
    Ht(Ti, t)
}
function $T(n, e, t) {
    var i = n.stateNode;
    if (e = e.childContextTypes,
    typeof i.getChildContext != "function")
        return t;
    i = i.getChildContext();
    for (var r in i)
        if (!(r in e))
            throw Error(_e(108, a3(n) || "Unknown", r));
    return tn({}, t, i)
}
function up(n) {
    return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || po,
    ha = ii.current,
    Ht(ii, n),
    Ht(Ti, Ti.current),
    !0
}
function zS(n, e, t) {
    var i = n.stateNode;
    if (!i)
        throw Error(_e(169));
    t ? (n = $T(n, e, ha),
    i.__reactInternalMemoizedMergedChildContext = n,
    Xt(Ti),
    Xt(ii),
    Ht(ii, n)) : Xt(Ti),
    Ht(Ti, t)
}
var hs = null
  , kp = !1
  , jg = !1;
function eA(n) {
    hs === null ? hs = [n] : hs.push(n)
}
function EP(n) {
    kp = !0,
    eA(n)
}
function _o() {
    if (!jg && hs !== null) {
        jg = !0;
        var n = 0
          , e = Ot;
        try {
            var t = hs;
            for (Ot = 1; n < t.length; n++) {
                var i = t[n];
                do
                    i = i(!0);
                while (i !== null)
            }
            hs = null,
            kp = !1
        } catch (r) {
            throw hs !== null && (hs = hs.slice(n + 1)),
            TT(Ky, _o),
            r
        } finally {
            Ot = e,
            jg = !1
        }
    }
    return null
}
var El = []
  , Tl = 0
  , cp = null
  , fp = 0
  , rr = []
  , sr = 0
  , da = null
  , ms = 1
  , gs = "";
function Yo(n, e) {
    El[Tl++] = fp,
    El[Tl++] = cp,
    cp = n,
    fp = e
}
function tA(n, e, t) {
    rr[sr++] = ms,
    rr[sr++] = gs,
    rr[sr++] = da,
    da = n;
    var i = ms;
    n = gs;
    var r = 32 - Er(i) - 1;
    i &= ~(1 << r),
    t += 1;
    var s = 32 - Er(e) + r;
    if (30 < s) {
        var o = r - r % 5;
        s = (i & (1 << o) - 1).toString(32),
        i >>= o,
        r -= o,
        ms = 1 << 32 - Er(e) + r | t << r | i,
        gs = s + n
    } else
        ms = 1 << s | t << r | i,
        gs = n
}
function o_(n) {
    n.return !== null && (Yo(n, 1),
    tA(n, 1, 0))
}
function a_(n) {
    for (; n === cp; )
        cp = El[--Tl],
        El[Tl] = null,
        fp = El[--Tl],
        El[Tl] = null;
    for (; n === da; )
        da = rr[--sr],
        rr[sr] = null,
        gs = rr[--sr],
        rr[sr] = null,
        ms = rr[--sr],
        rr[sr] = null
}
var Bi = null
  , zi = null
  , qt = !1
  , Mr = null;
function nA(n, e) {
    var t = or(5, null, null, 0);
    t.elementType = "DELETED",
    t.stateNode = e,
    t.return = n,
    e = n.deletions,
    e === null ? (n.deletions = [t],
    n.flags |= 16) : e.push(t)
}
function BS(n, e) {
    switch (n.tag) {
    case 5:
        var t = n.type;
        return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e,
        e !== null ? (n.stateNode = e,
        Bi = n,
        zi = ro(e.firstChild),
        !0) : !1;
    case 6:
        return e = n.pendingProps === "" || e.nodeType !== 3 ? null : e,
        e !== null ? (n.stateNode = e,
        Bi = n,
        zi = null,
        !0) : !1;
    case 13:
        return e = e.nodeType !== 8 ? null : e,
        e !== null ? (t = da !== null ? {
            id: ms,
            overflow: gs
        } : null,
        n.memoizedState = {
            dehydrated: e,
            treeContext: t,
            retryLane: 1073741824
        },
        t = or(18, null, null, 0),
        t.stateNode = e,
        t.return = n,
        n.child = t,
        Bi = n,
        zi = null,
        !0) : !1;
    default:
        return !1
    }
}
function Tv(n) {
    return (n.mode & 1) !== 0 && (n.flags & 128) === 0
}
function Av(n) {
    if (qt) {
        var e = zi;
        if (e) {
            var t = e;
            if (!BS(n, e)) {
                if (Tv(n))
                    throw Error(_e(418));
                e = ro(t.nextSibling);
                var i = Bi;
                e && BS(n, e) ? nA(i, t) : (n.flags = n.flags & -4097 | 2,
                qt = !1,
                Bi = n)
            }
        } else {
            if (Tv(n))
                throw Error(_e(418));
            n.flags = n.flags & -4097 | 2,
            qt = !1,
            Bi = n
        }
    }
}
function HS(n) {
    for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
        n = n.return;
    Bi = n
}
function Nh(n) {
    if (n !== Bi)
        return !1;
    if (!qt)
        return HS(n),
        qt = !0,
        !1;
    var e;
    if ((e = n.tag !== 3) && !(e = n.tag !== 5) && (e = n.type,
    e = e !== "head" && e !== "body" && !Sv(n.type, n.memoizedProps)),
    e && (e = zi)) {
        if (Tv(n))
            throw iA(),
            Error(_e(418));
        for (; e; )
            nA(n, e),
            e = ro(e.nextSibling)
    }
    if (HS(n),
    n.tag === 13) {
        if (n = n.memoizedState,
        n = n !== null ? n.dehydrated : null,
        !n)
            throw Error(_e(317));
        e: {
            for (n = n.nextSibling,
            e = 0; n; ) {
                if (n.nodeType === 8) {
                    var t = n.data;
                    if (t === "/$") {
                        if (e === 0) {
                            zi = ro(n.nextSibling);
                            break e
                        }
                        e--
                    } else
                        t !== "$" && t !== "$!" && t !== "$?" || e++
                }
                n = n.nextSibling
            }
            zi = null
        }
    } else
        zi = Bi ? ro(n.stateNode.nextSibling) : null;
    return !0
}
function iA() {
    for (var n = zi; n; )
        n = ro(n.nextSibling)
}
function Xl() {
    zi = Bi = null,
    qt = !1
}
function l_(n) {
    Mr === null ? Mr = [n] : Mr.push(n)
}
var TP = As.ReactCurrentBatchConfig;
function Ou(n, e, t) {
    if (n = t.ref,
    n !== null && typeof n != "function" && typeof n != "object") {
        if (t._owner) {
            if (t = t._owner,
            t) {
                if (t.tag !== 1)
                    throw Error(_e(309));
                var i = t.stateNode
            }
            if (!i)
                throw Error(_e(147, n));
            var r = i
              , s = "" + n;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
                var a = r.refs;
                o === null ? delete a[s] : a[s] = o
            }
            ,
            e._stringRef = s,
            e)
        }
        if (typeof n != "string")
            throw Error(_e(284));
        if (!t._owner)
            throw Error(_e(290, n))
    }
    return n
}
function Dh(n, e) {
    throw n = Object.prototype.toString.call(e),
    Error(_e(31, n === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : n))
}
function VS(n) {
    var e = n._init;
    return e(n._payload)
}
function rA(n) {
    function e(g, S) {
        if (n) {
            var M = g.deletions;
            M === null ? (g.deletions = [S],
            g.flags |= 16) : M.push(S)
        }
    }
    function t(g, S) {
        if (!n)
            return null;
        for (; S !== null; )
            e(g, S),
            S = S.sibling;
        return null
    }
    function i(g, S) {
        for (g = new Map; S !== null; )
            S.key !== null ? g.set(S.key, S) : g.set(S.index, S),
            S = S.sibling;
        return g
    }
    function r(g, S) {
        return g = lo(g, S),
        g.index = 0,
        g.sibling = null,
        g
    }
    function s(g, S, M) {
        return g.index = M,
        n ? (M = g.alternate,
        M !== null ? (M = M.index,
        M < S ? (g.flags |= 2,
        S) : M) : (g.flags |= 2,
        S)) : (g.flags |= 1048576,
        S)
    }
    function o(g) {
        return n && g.alternate === null && (g.flags |= 2),
        g
    }
    function a(g, S, M, T) {
        return S === null || S.tag !== 6 ? (S = e0(M, g.mode, T),
        S.return = g,
        S) : (S = r(S, M),
        S.return = g,
        S)
    }
    function c(g, S, M, T) {
        var P = M.type;
        return P === yl ? h(g, S, M.props.children, T, M.key) : S !== null && (S.elementType === P || typeof P == "object" && P !== null && P.$$typeof === js && VS(P) === S.type) ? (T = r(S, M.props),
        T.ref = Ou(g, S, M),
        T.return = g,
        T) : (T = Wd(M.type, M.key, M.props, null, g.mode, T),
        T.ref = Ou(g, S, M),
        T.return = g,
        T)
    }
    function f(g, S, M, T) {
        return S === null || S.tag !== 4 || S.stateNode.containerInfo !== M.containerInfo || S.stateNode.implementation !== M.implementation ? (S = t0(M, g.mode, T),
        S.return = g,
        S) : (S = r(S, M.children || []),
        S.return = g,
        S)
    }
    function h(g, S, M, T, P) {
        return S === null || S.tag !== 7 ? (S = aa(M, g.mode, T, P),
        S.return = g,
        S) : (S = r(S, M),
        S.return = g,
        S)
    }
    function d(g, S, M) {
        if (typeof S == "string" && S !== "" || typeof S == "number")
            return S = e0("" + S, g.mode, M),
            S.return = g,
            S;
        if (typeof S == "object" && S !== null) {
            switch (S.$$typeof) {
            case wh:
                return M = Wd(S.type, S.key, S.props, null, g.mode, M),
                M.ref = Ou(g, null, S),
                M.return = g,
                M;
            case vl:
                return S = t0(S, g.mode, M),
                S.return = g,
                S;
            case js:
                var T = S._init;
                return d(g, T(S._payload), M)
            }
            if (sc(S) || Lu(S))
                return S = aa(S, g.mode, M, null),
                S.return = g,
                S;
            Dh(g, S)
        }
        return null
    }
    function m(g, S, M, T) {
        var P = S !== null ? S.key : null;
        if (typeof M == "string" && M !== "" || typeof M == "number")
            return P !== null ? null : a(g, S, "" + M, T);
        if (typeof M == "object" && M !== null) {
            switch (M.$$typeof) {
            case wh:
                return M.key === P ? c(g, S, M, T) : null;
            case vl:
                return M.key === P ? f(g, S, M, T) : null;
            case js:
                return P = M._init,
                m(g, S, P(M._payload), T)
            }
            if (sc(M) || Lu(M))
                return P !== null ? null : h(g, S, M, T, null);
            Dh(g, M)
        }
        return null
    }
    function v(g, S, M, T, P) {
        if (typeof T == "string" && T !== "" || typeof T == "number")
            return g = g.get(M) || null,
            a(S, g, "" + T, P);
        if (typeof T == "object" && T !== null) {
            switch (T.$$typeof) {
            case wh:
                return g = g.get(T.key === null ? M : T.key) || null,
                c(S, g, T, P);
            case vl:
                return g = g.get(T.key === null ? M : T.key) || null,
                f(S, g, T, P);
            case js:
                var R = T._init;
                return v(g, S, M, R(T._payload), P)
            }
            if (sc(T) || Lu(T))
                return g = g.get(M) || null,
                h(S, g, T, P, null);
            Dh(S, T)
        }
        return null
    }
    function _(g, S, M, T) {
        for (var P = null, R = null, b = S, N = S = 0, G = null; b !== null && N < M.length; N++) {
            b.index > N ? (G = b,
            b = null) : G = b.sibling;
            var C = m(g, b, M[N], T);
            if (C === null) {
                b === null && (b = G);
                break
            }
            n && b && C.alternate === null && e(g, b),
            S = s(C, S, N),
            R === null ? P = C : R.sibling = C,
            R = C,
            b = G
        }
        if (N === M.length)
            return t(g, b),
            qt && Yo(g, N),
            P;
        if (b === null) {
            for (; N < M.length; N++)
                b = d(g, M[N], T),
                b !== null && (S = s(b, S, N),
                R === null ? P = b : R.sibling = b,
                R = b);
            return qt && Yo(g, N),
            P
        }
        for (b = i(g, b); N < M.length; N++)
            G = v(b, g, N, M[N], T),
            G !== null && (n && G.alternate !== null && b.delete(G.key === null ? N : G.key),
            S = s(G, S, N),
            R === null ? P = G : R.sibling = G,
            R = G);
        return n && b.forEach(function(I) {
            return e(g, I)
        }),
        qt && Yo(g, N),
        P
    }
    function w(g, S, M, T) {
        var P = Lu(M);
        if (typeof P != "function")
            throw Error(_e(150));
        if (M = P.call(M),
        M == null)
            throw Error(_e(151));
        for (var R = P = null, b = S, N = S = 0, G = null, C = M.next(); b !== null && !C.done; N++,
        C = M.next()) {
            b.index > N ? (G = b,
            b = null) : G = b.sibling;
            var I = m(g, b, C.value, T);
            if (I === null) {
                b === null && (b = G);
                break
            }
            n && b && I.alternate === null && e(g, b),
            S = s(I, S, N),
            R === null ? P = I : R.sibling = I,
            R = I,
            b = G
        }
        if (C.done)
            return t(g, b),
            qt && Yo(g, N),
            P;
        if (b === null) {
            for (; !C.done; N++,
            C = M.next())
                C = d(g, C.value, T),
                C !== null && (S = s(C, S, N),
                R === null ? P = C : R.sibling = C,
                R = C);
            return qt && Yo(g, N),
            P
        }
        for (b = i(g, b); !C.done; N++,
        C = M.next())
            C = v(b, g, N, C.value, T),
            C !== null && (n && C.alternate !== null && b.delete(C.key === null ? N : C.key),
            S = s(C, S, N),
            R === null ? P = C : R.sibling = C,
            R = C);
        return n && b.forEach(function(K) {
            return e(g, K)
        }),
        qt && Yo(g, N),
        P
    }
    function x(g, S, M, T) {
        if (typeof M == "object" && M !== null && M.type === yl && M.key === null && (M = M.props.children),
        typeof M == "object" && M !== null) {
            switch (M.$$typeof) {
            case wh:
                e: {
                    for (var P = M.key, R = S; R !== null; ) {
                        if (R.key === P) {
                            if (P = M.type,
                            P === yl) {
                                if (R.tag === 7) {
                                    t(g, R.sibling),
                                    S = r(R, M.props.children),
                                    S.return = g,
                                    g = S;
                                    break e
                                }
                            } else if (R.elementType === P || typeof P == "object" && P !== null && P.$$typeof === js && VS(P) === R.type) {
                                t(g, R.sibling),
                                S = r(R, M.props),
                                S.ref = Ou(g, R, M),
                                S.return = g,
                                g = S;
                                break e
                            }
                            t(g, R);
                            break
                        } else
                            e(g, R);
                        R = R.sibling
                    }
                    M.type === yl ? (S = aa(M.props.children, g.mode, T, M.key),
                    S.return = g,
                    g = S) : (T = Wd(M.type, M.key, M.props, null, g.mode, T),
                    T.ref = Ou(g, S, M),
                    T.return = g,
                    g = T)
                }
                return o(g);
            case vl:
                e: {
                    for (R = M.key; S !== null; ) {
                        if (S.key === R)
                            if (S.tag === 4 && S.stateNode.containerInfo === M.containerInfo && S.stateNode.implementation === M.implementation) {
                                t(g, S.sibling),
                                S = r(S, M.children || []),
                                S.return = g,
                                g = S;
                                break e
                            } else {
                                t(g, S);
                                break
                            }
                        else
                            e(g, S);
                        S = S.sibling
                    }
                    S = t0(M, g.mode, T),
                    S.return = g,
                    g = S
                }
                return o(g);
            case js:
                return R = M._init,
                x(g, S, R(M._payload), T)
            }
            if (sc(M))
                return _(g, S, M, T);
            if (Lu(M))
                return w(g, S, M, T);
            Dh(g, M)
        }
        return typeof M == "string" && M !== "" || typeof M == "number" ? (M = "" + M,
        S !== null && S.tag === 6 ? (t(g, S.sibling),
        S = r(S, M),
        S.return = g,
        g = S) : (t(g, S),
        S = e0(M, g.mode, T),
        S.return = g,
        g = S),
        o(g)) : t(g, S)
    }
    return x
}
var Yl = rA(!0)
  , sA = rA(!1)
  , hp = yo(null)
  , dp = null
  , Al = null
  , u_ = null;
function c_() {
    u_ = Al = dp = null
}
function f_(n) {
    var e = hp.current;
    Xt(hp),
    n._currentValue = e
}
function Cv(n, e, t) {
    for (; n !== null; ) {
        var i = n.alternate;
        if ((n.childLanes & e) !== e ? (n.childLanes |= e,
        i !== null && (i.childLanes |= e)) : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
        n === t)
            break;
        n = n.return
    }
}
function zl(n, e) {
    dp = n,
    u_ = Al = null,
    n = n.dependencies,
    n !== null && n.firstContext !== null && (n.lanes & e && (Ei = !0),
    n.firstContext = null)
}
function lr(n) {
    var e = n._currentValue;
    if (u_ !== n)
        if (n = {
            context: n,
            memoizedValue: e,
            next: null
        },
        Al === null) {
            if (dp === null)
                throw Error(_e(308));
            Al = n,
            dp.dependencies = {
                lanes: 0,
                firstContext: n
            }
        } else
            Al = Al.next = n;
    return e
}
var $o = null;
function h_(n) {
    $o === null ? $o = [n] : $o.push(n)
}
function oA(n, e, t, i) {
    var r = e.interleaved;
    return r === null ? (t.next = t,
    h_(e)) : (t.next = r.next,
    r.next = t),
    e.interleaved = t,
    ws(n, i)
}
function ws(n, e) {
    n.lanes |= e;
    var t = n.alternate;
    for (t !== null && (t.lanes |= e),
    t = n,
    n = n.return; n !== null; )
        n.childLanes |= e,
        t = n.alternate,
        t !== null && (t.childLanes |= e),
        t = n,
        n = n.return;
    return t.tag === 3 ? t.stateNode : null
}
var qs = !1;
function d_(n) {
    n.updateQueue = {
        baseState: n.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function aA(n, e) {
    n = n.updateQueue,
    e.updateQueue === n && (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects
    })
}
function _s(n, e) {
    return {
        eventTime: n,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function so(n, e, t) {
    var i = n.updateQueue;
    if (i === null)
        return null;
    if (i = i.shared,
    Rt & 2) {
        var r = i.pending;
        return r === null ? e.next = e : (e.next = r.next,
        r.next = e),
        i.pending = e,
        ws(n, t)
    }
    return r = i.interleaved,
    r === null ? (e.next = e,
    h_(i)) : (e.next = r.next,
    r.next = e),
    i.interleaved = e,
    ws(n, t)
}
function kd(n, e, t) {
    if (e = e.updateQueue,
    e !== null && (e = e.shared,
    (t & 4194240) !== 0)) {
        var i = e.lanes;
        i &= n.pendingLanes,
        t |= i,
        e.lanes = t,
        Qy(n, t)
    }
}
function GS(n, e) {
    var t = n.updateQueue
      , i = n.alternate;
    if (i !== null && (i = i.updateQueue,
    t === i)) {
        var r = null
          , s = null;
        if (t = t.firstBaseUpdate,
        t !== null) {
            do {
                var o = {
                    eventTime: t.eventTime,
                    lane: t.lane,
                    tag: t.tag,
                    payload: t.payload,
                    callback: t.callback,
                    next: null
                };
                s === null ? r = s = o : s = s.next = o,
                t = t.next
            } while (t !== null);
            s === null ? r = s = e : s = s.next = e
        } else
            r = s = e;
        t = {
            baseState: i.baseState,
            firstBaseUpdate: r,
            lastBaseUpdate: s,
            shared: i.shared,
            effects: i.effects
        },
        n.updateQueue = t;
        return
    }
    n = t.lastBaseUpdate,
    n === null ? t.firstBaseUpdate = e : n.next = e,
    t.lastBaseUpdate = e
}
function pp(n, e, t, i) {
    var r = n.updateQueue;
    qs = !1;
    var s = r.firstBaseUpdate
      , o = r.lastBaseUpdate
      , a = r.shared.pending;
    if (a !== null) {
        r.shared.pending = null;
        var c = a
          , f = c.next;
        c.next = null,
        o === null ? s = f : o.next = f,
        o = c;
        var h = n.alternate;
        h !== null && (h = h.updateQueue,
        a = h.lastBaseUpdate,
        a !== o && (a === null ? h.firstBaseUpdate = f : a.next = f,
        h.lastBaseUpdate = c))
    }
    if (s !== null) {
        var d = r.baseState;
        o = 0,
        h = f = c = null,
        a = s;
        do {
            var m = a.lane
              , v = a.eventTime;
            if ((i & m) === m) {
                h !== null && (h = h.next = {
                    eventTime: v,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var _ = n
                      , w = a;
                    switch (m = e,
                    v = t,
                    w.tag) {
                    case 1:
                        if (_ = w.payload,
                        typeof _ == "function") {
                            d = _.call(v, d, m);
                            break e
                        }
                        d = _;
                        break e;
                    case 3:
                        _.flags = _.flags & -65537 | 128;
                    case 0:
                        if (_ = w.payload,
                        m = typeof _ == "function" ? _.call(v, d, m) : _,
                        m == null)
                            break e;
                        d = tn({}, d, m);
                        break e;
                    case 2:
                        qs = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (n.flags |= 64,
                m = r.effects,
                m === null ? r.effects = [a] : m.push(a))
            } else
                v = {
                    eventTime: v,
                    lane: m,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                },
                h === null ? (f = h = v,
                c = d) : h = h.next = v,
                o |= m;
            if (a = a.next,
            a === null) {
                if (a = r.shared.pending,
                a === null)
                    break;
                m = a,
                a = m.next,
                m.next = null,
                r.lastBaseUpdate = m,
                r.shared.pending = null
            }
        } while (!0);
        if (h === null && (c = d),
        r.baseState = c,
        r.firstBaseUpdate = f,
        r.lastBaseUpdate = h,
        e = r.shared.interleaved,
        e !== null) {
            r = e;
            do
                o |= r.lane,
                r = r.next;
            while (r !== e)
        } else
            s === null && (r.shared.lanes = 0);
        ma |= o,
        n.lanes = o,
        n.memoizedState = d
    }
}
function WS(n, e, t) {
    if (n = e.effects,
    e.effects = null,
    n !== null)
        for (e = 0; e < n.length; e++) {
            var i = n[e]
              , r = i.callback;
            if (r !== null) {
                if (i.callback = null,
                i = t,
                typeof r != "function")
                    throw Error(_e(191, r));
                r.call(i)
            }
        }
}
var pf = {}
  , Yr = yo(pf)
  , Uc = yo(pf)
  , Oc = yo(pf);
function ea(n) {
    if (n === pf)
        throw Error(_e(174));
    return n
}
function p_(n, e) {
    switch (Ht(Oc, e),
    Ht(Uc, n),
    Ht(Yr, pf),
    n = e.nodeType,
    n) {
    case 9:
    case 11:
        e = (e = e.documentElement) ? e.namespaceURI : av(null, "");
        break;
    default:
        n = n === 8 ? e.parentNode : e,
        e = n.namespaceURI || null,
        n = n.tagName,
        e = av(e, n)
    }
    Xt(Yr),
    Ht(Yr, e)
}
function jl() {
    Xt(Yr),
    Xt(Uc),
    Xt(Oc)
}
function lA(n) {
    ea(Oc.current);
    var e = ea(Yr.current)
      , t = av(e, n.type);
    e !== t && (Ht(Uc, n),
    Ht(Yr, t))
}
function m_(n) {
    Uc.current === n && (Xt(Yr),
    Xt(Uc))
}
var Kt = yo(0);
function mp(n) {
    for (var e = n; e !== null; ) {
        if (e.tag === 13) {
            var t = e.memoizedState;
            if (t !== null && (t = t.dehydrated,
            t === null || t.data === "$?" || t.data === "$!"))
                return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128)
                return e
        } else if (e.child !== null) {
            e.child.return = e,
            e = e.child;
            continue
        }
        if (e === n)
            break;
        for (; e.sibling === null; ) {
            if (e.return === null || e.return === n)
                return null;
            e = e.return
        }
        e.sibling.return = e.return,
        e = e.sibling
    }
    return null
}
var qg = [];
function g_() {
    for (var n = 0; n < qg.length; n++)
        qg[n]._workInProgressVersionPrimary = null;
    qg.length = 0
}
var zd = As.ReactCurrentDispatcher
  , Zg = As.ReactCurrentBatchConfig
  , pa = 0
  , $t = null
  , Sn = null
  , Nn = null
  , gp = !1
  , pc = !1
  , Fc = 0
  , AP = 0;
function qn() {
    throw Error(_e(321))
}
function v_(n, e) {
    if (e === null)
        return !1;
    for (var t = 0; t < e.length && t < n.length; t++)
        if (!Cr(n[t], e[t]))
            return !1;
    return !0
}
function y_(n, e, t, i, r, s) {
    if (pa = s,
    $t = e,
    e.memoizedState = null,
    e.updateQueue = null,
    e.lanes = 0,
    zd.current = n === null || n.memoizedState === null ? PP : LP,
    n = t(i, r),
    pc) {
        s = 0;
        do {
            if (pc = !1,
            Fc = 0,
            25 <= s)
                throw Error(_e(301));
            s += 1,
            Nn = Sn = null,
            e.updateQueue = null,
            zd.current = IP,
            n = t(i, r)
        } while (pc)
    }
    if (zd.current = vp,
    e = Sn !== null && Sn.next !== null,
    pa = 0,
    Nn = Sn = $t = null,
    gp = !1,
    e)
        throw Error(_e(300));
    return n
}
function __() {
    var n = Fc !== 0;
    return Fc = 0,
    n
}
function Br() {
    var n = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return Nn === null ? $t.memoizedState = Nn = n : Nn = Nn.next = n,
    Nn
}
function ur() {
    if (Sn === null) {
        var n = $t.alternate;
        n = n !== null ? n.memoizedState : null
    } else
        n = Sn.next;
    var e = Nn === null ? $t.memoizedState : Nn.next;
    if (e !== null)
        Nn = e,
        Sn = n;
    else {
        if (n === null)
            throw Error(_e(310));
        Sn = n,
        n = {
            memoizedState: Sn.memoizedState,
            baseState: Sn.baseState,
            baseQueue: Sn.baseQueue,
            queue: Sn.queue,
            next: null
        },
        Nn === null ? $t.memoizedState = Nn = n : Nn = Nn.next = n
    }
    return Nn
}
function kc(n, e) {
    return typeof e == "function" ? e(n) : e
}
function Jg(n) {
    var e = ur()
      , t = e.queue;
    if (t === null)
        throw Error(_e(311));
    t.lastRenderedReducer = n;
    var i = Sn
      , r = i.baseQueue
      , s = t.pending;
    if (s !== null) {
        if (r !== null) {
            var o = r.next;
            r.next = s.next,
            s.next = o
        }
        i.baseQueue = r = s,
        t.pending = null
    }
    if (r !== null) {
        s = r.next,
        i = i.baseState;
        var a = o = null
          , c = null
          , f = s;
        do {
            var h = f.lane;
            if ((pa & h) === h)
                c !== null && (c = c.next = {
                    lane: 0,
                    action: f.action,
                    hasEagerState: f.hasEagerState,
                    eagerState: f.eagerState,
                    next: null
                }),
                i = f.hasEagerState ? f.eagerState : n(i, f.action);
            else {
                var d = {
                    lane: h,
                    action: f.action,
                    hasEagerState: f.hasEagerState,
                    eagerState: f.eagerState,
                    next: null
                };
                c === null ? (a = c = d,
                o = i) : c = c.next = d,
                $t.lanes |= h,
                ma |= h
            }
            f = f.next
        } while (f !== null && f !== s);
        c === null ? o = i : c.next = a,
        Cr(i, e.memoizedState) || (Ei = !0),
        e.memoizedState = i,
        e.baseState = o,
        e.baseQueue = c,
        t.lastRenderedState = i
    }
    if (n = t.interleaved,
    n !== null) {
        r = n;
        do
            s = r.lane,
            $t.lanes |= s,
            ma |= s,
            r = r.next;
        while (r !== n)
    } else
        r === null && (t.lanes = 0);
    return [e.memoizedState, t.dispatch]
}
function Kg(n) {
    var e = ur()
      , t = e.queue;
    if (t === null)
        throw Error(_e(311));
    t.lastRenderedReducer = n;
    var i = t.dispatch
      , r = t.pending
      , s = e.memoizedState;
    if (r !== null) {
        t.pending = null;
        var o = r = r.next;
        do
            s = n(s, o.action),
            o = o.next;
        while (o !== r);
        Cr(s, e.memoizedState) || (Ei = !0),
        e.memoizedState = s,
        e.baseQueue === null && (e.baseState = s),
        t.lastRenderedState = s
    }
    return [s, i]
}
function uA() {}
function cA(n, e) {
    var t = $t
      , i = ur()
      , r = e()
      , s = !Cr(i.memoizedState, r);
    if (s && (i.memoizedState = r,
    Ei = !0),
    i = i.queue,
    x_(dA.bind(null, t, i, n), [n]),
    i.getSnapshot !== e || s || Nn !== null && Nn.memoizedState.tag & 1) {
        if (t.flags |= 2048,
        zc(9, hA.bind(null, t, i, r, e), void 0, null),
        Un === null)
            throw Error(_e(349));
        pa & 30 || fA(t, e, r)
    }
    return r
}
function fA(n, e, t) {
    n.flags |= 16384,
    n = {
        getSnapshot: e,
        value: t
    },
    e = $t.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    $t.updateQueue = e,
    e.stores = [n]) : (t = e.stores,
    t === null ? e.stores = [n] : t.push(n))
}
function hA(n, e, t, i) {
    e.value = t,
    e.getSnapshot = i,
    pA(e) && mA(n)
}
function dA(n, e, t) {
    return t(function() {
        pA(e) && mA(n)
    })
}
function pA(n) {
    var e = n.getSnapshot;
    n = n.value;
    try {
        var t = e();
        return !Cr(n, t)
    } catch {
        return !0
    }
}
function mA(n) {
    var e = ws(n, 1);
    e !== null && Tr(e, n, 1, -1)
}
function XS(n) {
    var e = Br();
    return typeof n == "function" && (n = n()),
    e.memoizedState = e.baseState = n,
    n = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: kc,
        lastRenderedState: n
    },
    e.queue = n,
    n = n.dispatch = bP.bind(null, $t, n),
    [e.memoizedState, n]
}
function zc(n, e, t, i) {
    return n = {
        tag: n,
        create: e,
        destroy: t,
        deps: i,
        next: null
    },
    e = $t.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    $t.updateQueue = e,
    e.lastEffect = n.next = n) : (t = e.lastEffect,
    t === null ? e.lastEffect = n.next = n : (i = t.next,
    t.next = n,
    n.next = i,
    e.lastEffect = n)),
    n
}
function gA() {
    return ur().memoizedState
}
function Bd(n, e, t, i) {
    var r = Br();
    $t.flags |= n,
    r.memoizedState = zc(1 | e, t, void 0, i === void 0 ? null : i)
}
function zp(n, e, t, i) {
    var r = ur();
    i = i === void 0 ? null : i;
    var s = void 0;
    if (Sn !== null) {
        var o = Sn.memoizedState;
        if (s = o.destroy,
        i !== null && v_(i, o.deps)) {
            r.memoizedState = zc(e, t, s, i);
            return
        }
    }
    $t.flags |= n,
    r.memoizedState = zc(1 | e, t, s, i)
}
function YS(n, e) {
    return Bd(8390656, 8, n, e)
}
function x_(n, e) {
    return zp(2048, 8, n, e)
}
function vA(n, e) {
    return zp(4, 2, n, e)
}
function yA(n, e) {
    return zp(4, 4, n, e)
}
function _A(n, e) {
    if (typeof e == "function")
        return n = n(),
        e(n),
        function() {
            e(null)
        }
        ;
    if (e != null)
        return n = n(),
        e.current = n,
        function() {
            e.current = null
        }
}
function xA(n, e, t) {
    return t = t != null ? t.concat([n]) : null,
    zp(4, 4, _A.bind(null, e, n), t)
}
function S_() {}
function SA(n, e) {
    var t = ur();
    e = e === void 0 ? null : e;
    var i = t.memoizedState;
    return i !== null && e !== null && v_(e, i[1]) ? i[0] : (t.memoizedState = [n, e],
    n)
}
function MA(n, e) {
    var t = ur();
    e = e === void 0 ? null : e;
    var i = t.memoizedState;
    return i !== null && e !== null && v_(e, i[1]) ? i[0] : (n = n(),
    t.memoizedState = [n, e],
    n)
}
function wA(n, e, t) {
    return pa & 21 ? (Cr(t, e) || (t = RT(),
    $t.lanes |= t,
    ma |= t,
    n.baseState = !0),
    e) : (n.baseState && (n.baseState = !1,
    Ei = !0),
    n.memoizedState = t)
}
function CP(n, e) {
    var t = Ot;
    Ot = t !== 0 && 4 > t ? t : 4,
    n(!0);
    var i = Zg.transition;
    Zg.transition = {};
    try {
        n(!1),
        e()
    } finally {
        Ot = t,
        Zg.transition = i
    }
}
function EA() {
    return ur().memoizedState
}
function RP(n, e, t) {
    var i = ao(n);
    if (t = {
        lane: i,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    TA(n))
        AA(e, t);
    else if (t = oA(n, e, t, i),
    t !== null) {
        var r = hi();
        Tr(t, n, i, r),
        CA(t, e, i)
    }
}
function bP(n, e, t) {
    var i = ao(n)
      , r = {
        lane: i,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (TA(n))
        AA(e, r);
    else {
        var s = n.alternate;
        if (n.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer,
        s !== null))
            try {
                var o = e.lastRenderedState
                  , a = s(o, t);
                if (r.hasEagerState = !0,
                r.eagerState = a,
                Cr(a, o)) {
                    var c = e.interleaved;
                    c === null ? (r.next = r,
                    h_(e)) : (r.next = c.next,
                    c.next = r),
                    e.interleaved = r;
                    return
                }
            } catch {} finally {}
        t = oA(n, e, r, i),
        t !== null && (r = hi(),
        Tr(t, n, i, r),
        CA(t, e, i))
    }
}
function TA(n) {
    var e = n.alternate;
    return n === $t || e !== null && e === $t
}
function AA(n, e) {
    pc = gp = !0;
    var t = n.pending;
    t === null ? e.next = e : (e.next = t.next,
    t.next = e),
    n.pending = e
}
function CA(n, e, t) {
    if (t & 4194240) {
        var i = e.lanes;
        i &= n.pendingLanes,
        t |= i,
        e.lanes = t,
        Qy(n, t)
    }
}
var vp = {
    readContext: lr,
    useCallback: qn,
    useContext: qn,
    useEffect: qn,
    useImperativeHandle: qn,
    useInsertionEffect: qn,
    useLayoutEffect: qn,
    useMemo: qn,
    useReducer: qn,
    useRef: qn,
    useState: qn,
    useDebugValue: qn,
    useDeferredValue: qn,
    useTransition: qn,
    useMutableSource: qn,
    useSyncExternalStore: qn,
    useId: qn,
    unstable_isNewReconciler: !1
}
  , PP = {
    readContext: lr,
    useCallback: function(n, e) {
        return Br().memoizedState = [n, e === void 0 ? null : e],
        n
    },
    useContext: lr,
    useEffect: YS,
    useImperativeHandle: function(n, e, t) {
        return t = t != null ? t.concat([n]) : null,
        Bd(4194308, 4, _A.bind(null, e, n), t)
    },
    useLayoutEffect: function(n, e) {
        return Bd(4194308, 4, n, e)
    },
    useInsertionEffect: function(n, e) {
        return Bd(4, 2, n, e)
    },
    useMemo: function(n, e) {
        var t = Br();
        return e = e === void 0 ? null : e,
        n = n(),
        t.memoizedState = [n, e],
        n
    },
    useReducer: function(n, e, t) {
        var i = Br();
        return e = t !== void 0 ? t(e) : e,
        i.memoizedState = i.baseState = e,
        n = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: n,
            lastRenderedState: e
        },
        i.queue = n,
        n = n.dispatch = RP.bind(null, $t, n),
        [i.memoizedState, n]
    },
    useRef: function(n) {
        var e = Br();
        return n = {
            current: n
        },
        e.memoizedState = n
    },
    useState: XS,
    useDebugValue: S_,
    useDeferredValue: function(n) {
        return Br().memoizedState = n
    },
    useTransition: function() {
        var n = XS(!1)
          , e = n[0];
        return n = CP.bind(null, n[1]),
        Br().memoizedState = n,
        [e, n]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(n, e, t) {
        var i = $t
          , r = Br();
        if (qt) {
            if (t === void 0)
                throw Error(_e(407));
            t = t()
        } else {
            if (t = e(),
            Un === null)
                throw Error(_e(349));
            pa & 30 || fA(i, e, t)
        }
        r.memoizedState = t;
        var s = {
            value: t,
            getSnapshot: e
        };
        return r.queue = s,
        YS(dA.bind(null, i, s, n), [n]),
        i.flags |= 2048,
        zc(9, hA.bind(null, i, s, t, e), void 0, null),
        t
    },
    useId: function() {
        var n = Br()
          , e = Un.identifierPrefix;
        if (qt) {
            var t = gs
              , i = ms;
            t = (i & ~(1 << 32 - Er(i) - 1)).toString(32) + t,
            e = ":" + e + "R" + t,
            t = Fc++,
            0 < t && (e += "H" + t.toString(32)),
            e += ":"
        } else
            t = AP++,
            e = ":" + e + "r" + t.toString(32) + ":";
        return n.memoizedState = e
    },
    unstable_isNewReconciler: !1
}
  , LP = {
    readContext: lr,
    useCallback: SA,
    useContext: lr,
    useEffect: x_,
    useImperativeHandle: xA,
    useInsertionEffect: vA,
    useLayoutEffect: yA,
    useMemo: MA,
    useReducer: Jg,
    useRef: gA,
    useState: function() {
        return Jg(kc)
    },
    useDebugValue: S_,
    useDeferredValue: function(n) {
        var e = ur();
        return wA(e, Sn.memoizedState, n)
    },
    useTransition: function() {
        var n = Jg(kc)[0]
          , e = ur().memoizedState;
        return [n, e]
    },
    useMutableSource: uA,
    useSyncExternalStore: cA,
    useId: EA,
    unstable_isNewReconciler: !1
}
  , IP = {
    readContext: lr,
    useCallback: SA,
    useContext: lr,
    useEffect: x_,
    useImperativeHandle: xA,
    useInsertionEffect: vA,
    useLayoutEffect: yA,
    useMemo: MA,
    useReducer: Kg,
    useRef: gA,
    useState: function() {
        return Kg(kc)
    },
    useDebugValue: S_,
    useDeferredValue: function(n) {
        var e = ur();
        return Sn === null ? e.memoizedState = n : wA(e, Sn.memoizedState, n)
    },
    useTransition: function() {
        var n = Kg(kc)[0]
          , e = ur().memoizedState;
        return [n, e]
    },
    useMutableSource: uA,
    useSyncExternalStore: cA,
    useId: EA,
    unstable_isNewReconciler: !1
};
function _r(n, e) {
    if (n && n.defaultProps) {
        e = tn({}, e),
        n = n.defaultProps;
        for (var t in n)
            e[t] === void 0 && (e[t] = n[t]);
        return e
    }
    return e
}
function Rv(n, e, t, i) {
    e = n.memoizedState,
    t = t(i, e),
    t = t == null ? e : tn({}, e, t),
    n.memoizedState = t,
    n.lanes === 0 && (n.updateQueue.baseState = t)
}
var Bp = {
    isMounted: function(n) {
        return (n = n._reactInternals) ? Ma(n) === n : !1
    },
    enqueueSetState: function(n, e, t) {
        n = n._reactInternals;
        var i = hi()
          , r = ao(n)
          , s = _s(i, r);
        s.payload = e,
        t != null && (s.callback = t),
        e = so(n, s, r),
        e !== null && (Tr(e, n, r, i),
        kd(e, n, r))
    },
    enqueueReplaceState: function(n, e, t) {
        n = n._reactInternals;
        var i = hi()
          , r = ao(n)
          , s = _s(i, r);
        s.tag = 1,
        s.payload = e,
        t != null && (s.callback = t),
        e = so(n, s, r),
        e !== null && (Tr(e, n, r, i),
        kd(e, n, r))
    },
    enqueueForceUpdate: function(n, e) {
        n = n._reactInternals;
        var t = hi()
          , i = ao(n)
          , r = _s(t, i);
        r.tag = 2,
        e != null && (r.callback = e),
        e = so(n, r, i),
        e !== null && (Tr(e, n, i, t),
        kd(e, n, i))
    }
};
function jS(n, e, t, i, r, s, o) {
    return n = n.stateNode,
    typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(i, s, o) : e.prototype && e.prototype.isPureReactComponent ? !Lc(t, i) || !Lc(r, s) : !0
}
function RA(n, e, t) {
    var i = !1
      , r = po
      , s = e.contextType;
    return typeof s == "object" && s !== null ? s = lr(s) : (r = Ai(e) ? ha : ii.current,
    i = e.contextTypes,
    s = (i = i != null) ? Wl(n, r) : po),
    e = new e(t,s),
    n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null,
    e.updater = Bp,
    n.stateNode = e,
    e._reactInternals = n,
    i && (n = n.stateNode,
    n.__reactInternalMemoizedUnmaskedChildContext = r,
    n.__reactInternalMemoizedMaskedChildContext = s),
    e
}
function qS(n, e, t, i) {
    n = e.state,
    typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, i),
    e.state !== n && Bp.enqueueReplaceState(e, e.state, null)
}
function bv(n, e, t, i) {
    var r = n.stateNode;
    r.props = t,
    r.state = n.memoizedState,
    r.refs = {},
    d_(n);
    var s = e.contextType;
    typeof s == "object" && s !== null ? r.context = lr(s) : (s = Ai(e) ? ha : ii.current,
    r.context = Wl(n, s)),
    r.state = n.memoizedState,
    s = e.getDerivedStateFromProps,
    typeof s == "function" && (Rv(n, e, s, t),
    r.state = n.memoizedState),
    typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state,
    typeof r.componentWillMount == "function" && r.componentWillMount(),
    typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(),
    e !== r.state && Bp.enqueueReplaceState(r, r.state, null),
    pp(n, t, r, i),
    r.state = n.memoizedState),
    typeof r.componentDidMount == "function" && (n.flags |= 4194308)
}
function ql(n, e) {
    try {
        var t = ""
          , i = e;
        do
            t += o3(i),
            i = i.return;
        while (i);
        var r = t
    } catch (s) {
        r = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: n,
        source: e,
        stack: r,
        digest: null
    }
}
function Qg(n, e, t) {
    return {
        value: n,
        source: null,
        stack: t ?? null,
        digest: e ?? null
    }
}
function Pv(n, e) {
    try {
        console.error(e.value)
    } catch (t) {
        setTimeout(function() {
            throw t
        })
    }
}
var NP = typeof WeakMap == "function" ? WeakMap : Map;
function bA(n, e, t) {
    t = _s(-1, t),
    t.tag = 3,
    t.payload = {
        element: null
    };
    var i = e.value;
    return t.callback = function() {
        _p || (_p = !0,
        Bv = i),
        Pv(n, e)
    }
    ,
    t
}
function PA(n, e, t) {
    t = _s(-1, t),
    t.tag = 3;
    var i = n.type.getDerivedStateFromError;
    if (typeof i == "function") {
        var r = e.value;
        t.payload = function() {
            return i(r)
        }
        ,
        t.callback = function() {
            Pv(n, e)
        }
    }
    var s = n.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (t.callback = function() {
        Pv(n, e),
        typeof i != "function" && (oo === null ? oo = new Set([this]) : oo.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }
    ),
    t
}
function ZS(n, e, t) {
    var i = n.pingCache;
    if (i === null) {
        i = n.pingCache = new NP;
        var r = new Set;
        i.set(e, r)
    } else
        r = i.get(e),
        r === void 0 && (r = new Set,
        i.set(e, r));
    r.has(t) || (r.add(t),
    n = jP.bind(null, n, e, t),
    e.then(n, n))
}
function JS(n) {
    do {
        var e;
        if ((e = n.tag === 13) && (e = n.memoizedState,
        e = e !== null ? e.dehydrated !== null : !0),
        e)
            return n;
        n = n.return
    } while (n !== null);
    return null
}
function KS(n, e, t, i, r) {
    return n.mode & 1 ? (n.flags |= 65536,
    n.lanes = r,
    n) : (n === e ? n.flags |= 65536 : (n.flags |= 128,
    t.flags |= 131072,
    t.flags &= -52805,
    t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = _s(-1, 1),
    e.tag = 2,
    so(t, e, 1))),
    t.lanes |= 1),
    n)
}
var DP = As.ReactCurrentOwner
  , Ei = !1;
function ui(n, e, t, i) {
    e.child = n === null ? sA(e, null, t, i) : Yl(e, n.child, t, i)
}
function QS(n, e, t, i, r) {
    t = t.render;
    var s = e.ref;
    return zl(e, r),
    i = y_(n, e, t, i, s, r),
    t = __(),
    n !== null && !Ei ? (e.updateQueue = n.updateQueue,
    e.flags &= -2053,
    n.lanes &= ~r,
    Es(n, e, r)) : (qt && t && o_(e),
    e.flags |= 1,
    ui(n, e, i, r),
    e.child)
}
function $S(n, e, t, i, r) {
    if (n === null) {
        var s = t.type;
        return typeof s == "function" && !b_(s) && s.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15,
        e.type = s,
        LA(n, e, s, i, r)) : (n = Wd(t.type, null, i, e, e.mode, r),
        n.ref = e.ref,
        n.return = e,
        e.child = n)
    }
    if (s = n.child,
    !(n.lanes & r)) {
        var o = s.memoizedProps;
        if (t = t.compare,
        t = t !== null ? t : Lc,
        t(o, i) && n.ref === e.ref)
            return Es(n, e, r)
    }
    return e.flags |= 1,
    n = lo(s, i),
    n.ref = e.ref,
    n.return = e,
    e.child = n
}
function LA(n, e, t, i, r) {
    if (n !== null) {
        var s = n.memoizedProps;
        if (Lc(s, i) && n.ref === e.ref)
            if (Ei = !1,
            e.pendingProps = i = s,
            (n.lanes & r) !== 0)
                n.flags & 131072 && (Ei = !0);
            else
                return e.lanes = n.lanes,
                Es(n, e, r)
    }
    return Lv(n, e, t, i, r)
}
function IA(n, e, t) {
    var i = e.pendingProps
      , r = i.children
      , s = n !== null ? n.memoizedState : null;
    if (i.mode === "hidden")
        if (!(e.mode & 1))
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            Ht(Rl, Oi),
            Oi |= t;
        else {
            if (!(t & 1073741824))
                return n = s !== null ? s.baseLanes | t : t,
                e.lanes = e.childLanes = 1073741824,
                e.memoizedState = {
                    baseLanes: n,
                    cachePool: null,
                    transitions: null
                },
                e.updateQueue = null,
                Ht(Rl, Oi),
                Oi |= n,
                null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            i = s !== null ? s.baseLanes : t,
            Ht(Rl, Oi),
            Oi |= i
        }
    else
        s !== null ? (i = s.baseLanes | t,
        e.memoizedState = null) : i = t,
        Ht(Rl, Oi),
        Oi |= i;
    return ui(n, e, r, t),
    e.child
}
function NA(n, e) {
    var t = e.ref;
    (n === null && t !== null || n !== null && n.ref !== t) && (e.flags |= 512,
    e.flags |= 2097152)
}
function Lv(n, e, t, i, r) {
    var s = Ai(t) ? ha : ii.current;
    return s = Wl(e, s),
    zl(e, r),
    t = y_(n, e, t, i, s, r),
    i = __(),
    n !== null && !Ei ? (e.updateQueue = n.updateQueue,
    e.flags &= -2053,
    n.lanes &= ~r,
    Es(n, e, r)) : (qt && i && o_(e),
    e.flags |= 1,
    ui(n, e, t, r),
    e.child)
}
function eM(n, e, t, i, r) {
    if (Ai(t)) {
        var s = !0;
        up(e)
    } else
        s = !1;
    if (zl(e, r),
    e.stateNode === null)
        Hd(n, e),
        RA(e, t, i),
        bv(e, t, i, r),
        i = !0;
    else if (n === null) {
        var o = e.stateNode
          , a = e.memoizedProps;
        o.props = a;
        var c = o.context
          , f = t.contextType;
        typeof f == "object" && f !== null ? f = lr(f) : (f = Ai(t) ? ha : ii.current,
        f = Wl(e, f));
        var h = t.getDerivedStateFromProps
          , d = typeof h == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== i || c !== f) && qS(e, o, i, f),
        qs = !1;
        var m = e.memoizedState;
        o.state = m,
        pp(e, i, o, r),
        c = e.memoizedState,
        a !== i || m !== c || Ti.current || qs ? (typeof h == "function" && (Rv(e, t, h, i),
        c = e.memoizedState),
        (a = qs || jS(e, t, a, i, m, c, f)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(),
        typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()),
        typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        e.memoizedProps = i,
        e.memoizedState = c),
        o.props = i,
        o.state = c,
        o.context = f,
        i = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        i = !1)
    } else {
        o = e.stateNode,
        aA(n, e),
        a = e.memoizedProps,
        f = e.type === e.elementType ? a : _r(e.type, a),
        o.props = f,
        d = e.pendingProps,
        m = o.context,
        c = t.contextType,
        typeof c == "object" && c !== null ? c = lr(c) : (c = Ai(t) ? ha : ii.current,
        c = Wl(e, c));
        var v = t.getDerivedStateFromProps;
        (h = typeof v == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || m !== c) && qS(e, o, i, c),
        qs = !1,
        m = e.memoizedState,
        o.state = m,
        pp(e, i, o, r);
        var _ = e.memoizedState;
        a !== d || m !== _ || Ti.current || qs ? (typeof v == "function" && (Rv(e, t, v, i),
        _ = e.memoizedState),
        (f = qs || jS(e, t, f, i, m, _, c) || !1) ? (h || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, _, c),
        typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, _, c)),
        typeof o.componentDidUpdate == "function" && (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && m === n.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && m === n.memoizedState || (e.flags |= 1024),
        e.memoizedProps = i,
        e.memoizedState = _),
        o.props = i,
        o.state = _,
        o.context = c,
        i = f) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && m === n.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && m === n.memoizedState || (e.flags |= 1024),
        i = !1)
    }
    return Iv(n, e, t, i, s, r)
}
function Iv(n, e, t, i, r, s) {
    NA(n, e);
    var o = (e.flags & 128) !== 0;
    if (!i && !o)
        return r && zS(e, t, !1),
        Es(n, e, s);
    i = e.stateNode,
    DP.current = e;
    var a = o && typeof t.getDerivedStateFromError != "function" ? null : i.render();
    return e.flags |= 1,
    n !== null && o ? (e.child = Yl(e, n.child, null, s),
    e.child = Yl(e, null, a, s)) : ui(n, e, a, s),
    e.memoizedState = i.state,
    r && zS(e, t, !0),
    e.child
}
function DA(n) {
    var e = n.stateNode;
    e.pendingContext ? kS(n, e.pendingContext, e.pendingContext !== e.context) : e.context && kS(n, e.context, !1),
    p_(n, e.containerInfo)
}
function tM(n, e, t, i, r) {
    return Xl(),
    l_(r),
    e.flags |= 256,
    ui(n, e, t, i),
    e.child
}
var Nv = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function Dv(n) {
    return {
        baseLanes: n,
        cachePool: null,
        transitions: null
    }
}
function UA(n, e, t) {
    var i = e.pendingProps, r = Kt.current, s = !1, o = (e.flags & 128) !== 0, a;
    if ((a = o) || (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0),
    a ? (s = !0,
    e.flags &= -129) : (n === null || n.memoizedState !== null) && (r |= 1),
    Ht(Kt, r & 1),
    n === null)
        return Av(e),
        n = e.memoizedState,
        n !== null && (n = n.dehydrated,
        n !== null) ? (e.mode & 1 ? n.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1,
        null) : (o = i.children,
        n = i.fallback,
        s ? (i = e.mode,
        s = e.child,
        o = {
            mode: "hidden",
            children: o
        },
        !(i & 1) && s !== null ? (s.childLanes = 0,
        s.pendingProps = o) : s = Gp(o, i, 0, null),
        n = aa(n, i, t, null),
        s.return = e,
        n.return = e,
        s.sibling = n,
        e.child = s,
        e.child.memoizedState = Dv(t),
        e.memoizedState = Nv,
        n) : M_(e, o));
    if (r = n.memoizedState,
    r !== null && (a = r.dehydrated,
    a !== null))
        return UP(n, e, o, i, a, r, t);
    if (s) {
        s = i.fallback,
        o = e.mode,
        r = n.child,
        a = r.sibling;
        var c = {
            mode: "hidden",
            children: i.children
        };
        return !(o & 1) && e.child !== r ? (i = e.child,
        i.childLanes = 0,
        i.pendingProps = c,
        e.deletions = null) : (i = lo(r, c),
        i.subtreeFlags = r.subtreeFlags & 14680064),
        a !== null ? s = lo(a, s) : (s = aa(s, o, t, null),
        s.flags |= 2),
        s.return = e,
        i.return = e,
        i.sibling = s,
        e.child = i,
        i = s,
        s = e.child,
        o = n.child.memoizedState,
        o = o === null ? Dv(t) : {
            baseLanes: o.baseLanes | t,
            cachePool: null,
            transitions: o.transitions
        },
        s.memoizedState = o,
        s.childLanes = n.childLanes & ~t,
        e.memoizedState = Nv,
        i
    }
    return s = n.child,
    n = s.sibling,
    i = lo(s, {
        mode: "visible",
        children: i.children
    }),
    !(e.mode & 1) && (i.lanes = t),
    i.return = e,
    i.sibling = null,
    n !== null && (t = e.deletions,
    t === null ? (e.deletions = [n],
    e.flags |= 16) : t.push(n)),
    e.child = i,
    e.memoizedState = null,
    i
}
function M_(n, e) {
    return e = Gp({
        mode: "visible",
        children: e
    }, n.mode, 0, null),
    e.return = n,
    n.child = e
}
function Uh(n, e, t, i) {
    return i !== null && l_(i),
    Yl(e, n.child, null, t),
    n = M_(e, e.pendingProps.children),
    n.flags |= 2,
    e.memoizedState = null,
    n
}
function UP(n, e, t, i, r, s, o) {
    if (t)
        return e.flags & 256 ? (e.flags &= -257,
        i = Qg(Error(_e(422))),
        Uh(n, e, o, i)) : e.memoizedState !== null ? (e.child = n.child,
        e.flags |= 128,
        null) : (s = i.fallback,
        r = e.mode,
        i = Gp({
            mode: "visible",
            children: i.children
        }, r, 0, null),
        s = aa(s, r, o, null),
        s.flags |= 2,
        i.return = e,
        s.return = e,
        i.sibling = s,
        e.child = i,
        e.mode & 1 && Yl(e, n.child, null, o),
        e.child.memoizedState = Dv(o),
        e.memoizedState = Nv,
        s);
    if (!(e.mode & 1))
        return Uh(n, e, o, null);
    if (r.data === "$!") {
        if (i = r.nextSibling && r.nextSibling.dataset,
        i)
            var a = i.dgst;
        return i = a,
        s = Error(_e(419)),
        i = Qg(s, i, void 0),
        Uh(n, e, o, i)
    }
    if (a = (o & n.childLanes) !== 0,
    Ei || a) {
        if (i = Un,
        i !== null) {
            switch (o & -o) {
            case 4:
                r = 2;
                break;
            case 16:
                r = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                r = 32;
                break;
            case 536870912:
                r = 268435456;
                break;
            default:
                r = 0
            }
            r = r & (i.suspendedLanes | o) ? 0 : r,
            r !== 0 && r !== s.retryLane && (s.retryLane = r,
            ws(n, r),
            Tr(i, n, r, -1))
        }
        return R_(),
        i = Qg(Error(_e(421))),
        Uh(n, e, o, i)
    }
    return r.data === "$?" ? (e.flags |= 128,
    e.child = n.child,
    e = qP.bind(null, n),
    r._reactRetry = e,
    null) : (n = s.treeContext,
    zi = ro(r.nextSibling),
    Bi = e,
    qt = !0,
    Mr = null,
    n !== null && (rr[sr++] = ms,
    rr[sr++] = gs,
    rr[sr++] = da,
    ms = n.id,
    gs = n.overflow,
    da = e),
    e = M_(e, i.children),
    e.flags |= 4096,
    e)
}
function nM(n, e, t) {
    n.lanes |= e;
    var i = n.alternate;
    i !== null && (i.lanes |= e),
    Cv(n.return, e, t)
}
function $g(n, e, t, i, r) {
    var s = n.memoizedState;
    s === null ? n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: t,
        tailMode: r
    } : (s.isBackwards = e,
    s.rendering = null,
    s.renderingStartTime = 0,
    s.last = i,
    s.tail = t,
    s.tailMode = r)
}
function OA(n, e, t) {
    var i = e.pendingProps
      , r = i.revealOrder
      , s = i.tail;
    if (ui(n, e, i.children, t),
    i = Kt.current,
    i & 2)
        i = i & 1 | 2,
        e.flags |= 128;
    else {
        if (n !== null && n.flags & 128)
            e: for (n = e.child; n !== null; ) {
                if (n.tag === 13)
                    n.memoizedState !== null && nM(n, t, e);
                else if (n.tag === 19)
                    nM(n, t, e);
                else if (n.child !== null) {
                    n.child.return = n,
                    n = n.child;
                    continue
                }
                if (n === e)
                    break e;
                for (; n.sibling === null; ) {
                    if (n.return === null || n.return === e)
                        break e;
                    n = n.return
                }
                n.sibling.return = n.return,
                n = n.sibling
            }
        i &= 1
    }
    if (Ht(Kt, i),
    !(e.mode & 1))
        e.memoizedState = null;
    else
        switch (r) {
        case "forwards":
            for (t = e.child,
            r = null; t !== null; )
                n = t.alternate,
                n !== null && mp(n) === null && (r = t),
                t = t.sibling;
            t = r,
            t === null ? (r = e.child,
            e.child = null) : (r = t.sibling,
            t.sibling = null),
            $g(e, !1, r, t, s);
            break;
        case "backwards":
            for (t = null,
            r = e.child,
            e.child = null; r !== null; ) {
                if (n = r.alternate,
                n !== null && mp(n) === null) {
                    e.child = r;
                    break
                }
                n = r.sibling,
                r.sibling = t,
                t = r,
                r = n
            }
            $g(e, !0, t, null, s);
            break;
        case "together":
            $g(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
        }
    return e.child
}
function Hd(n, e) {
    !(e.mode & 1) && n !== null && (n.alternate = null,
    e.alternate = null,
    e.flags |= 2)
}
function Es(n, e, t) {
    if (n !== null && (e.dependencies = n.dependencies),
    ma |= e.lanes,
    !(t & e.childLanes))
        return null;
    if (n !== null && e.child !== n.child)
        throw Error(_e(153));
    if (e.child !== null) {
        for (n = e.child,
        t = lo(n, n.pendingProps),
        e.child = t,
        t.return = e; n.sibling !== null; )
            n = n.sibling,
            t = t.sibling = lo(n, n.pendingProps),
            t.return = e;
        t.sibling = null
    }
    return e.child
}
function OP(n, e, t) {
    switch (e.tag) {
    case 3:
        DA(e),
        Xl();
        break;
    case 5:
        lA(e);
        break;
    case 1:
        Ai(e.type) && up(e);
        break;
    case 4:
        p_(e, e.stateNode.containerInfo);
        break;
    case 10:
        var i = e.type._context
          , r = e.memoizedProps.value;
        Ht(hp, i._currentValue),
        i._currentValue = r;
        break;
    case 13:
        if (i = e.memoizedState,
        i !== null)
            return i.dehydrated !== null ? (Ht(Kt, Kt.current & 1),
            e.flags |= 128,
            null) : t & e.child.childLanes ? UA(n, e, t) : (Ht(Kt, Kt.current & 1),
            n = Es(n, e, t),
            n !== null ? n.sibling : null);
        Ht(Kt, Kt.current & 1);
        break;
    case 19:
        if (i = (t & e.childLanes) !== 0,
        n.flags & 128) {
            if (i)
                return OA(n, e, t);
            e.flags |= 128
        }
        if (r = e.memoizedState,
        r !== null && (r.rendering = null,
        r.tail = null,
        r.lastEffect = null),
        Ht(Kt, Kt.current),
        i)
            break;
        return null;
    case 22:
    case 23:
        return e.lanes = 0,
        IA(n, e, t)
    }
    return Es(n, e, t)
}
var FA, Uv, kA, zA;
FA = function(n, e) {
    for (var t = e.child; t !== null; ) {
        if (t.tag === 5 || t.tag === 6)
            n.appendChild(t.stateNode);
        else if (t.tag !== 4 && t.child !== null) {
            t.child.return = t,
            t = t.child;
            continue
        }
        if (t === e)
            break;
        for (; t.sibling === null; ) {
            if (t.return === null || t.return === e)
                return;
            t = t.return
        }
        t.sibling.return = t.return,
        t = t.sibling
    }
}
;
Uv = function() {}
;
kA = function(n, e, t, i) {
    var r = n.memoizedProps;
    if (r !== i) {
        n = e.stateNode,
        ea(Yr.current);
        var s = null;
        switch (t) {
        case "input":
            r = iv(n, r),
            i = iv(n, i),
            s = [];
            break;
        case "select":
            r = tn({}, r, {
                value: void 0
            }),
            i = tn({}, i, {
                value: void 0
            }),
            s = [];
            break;
        case "textarea":
            r = ov(n, r),
            i = ov(n, i),
            s = [];
            break;
        default:
            typeof r.onClick != "function" && typeof i.onClick == "function" && (n.onclick = ap)
        }
        lv(t, i);
        var o;
        t = null;
        for (f in r)
            if (!i.hasOwnProperty(f) && r.hasOwnProperty(f) && r[f] != null)
                if (f === "style") {
                    var a = r[f];
                    for (o in a)
                        a.hasOwnProperty(o) && (t || (t = {}),
                        t[o] = "")
                } else
                    f !== "dangerouslySetInnerHTML" && f !== "children" && f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && f !== "autoFocus" && (Ec.hasOwnProperty(f) ? s || (s = []) : (s = s || []).push(f, null));
        for (f in i) {
            var c = i[f];
            if (a = r != null ? r[f] : void 0,
            i.hasOwnProperty(f) && c !== a && (c != null || a != null))
                if (f === "style")
                    if (a) {
                        for (o in a)
                            !a.hasOwnProperty(o) || c && c.hasOwnProperty(o) || (t || (t = {}),
                            t[o] = "");
                        for (o in c)
                            c.hasOwnProperty(o) && a[o] !== c[o] && (t || (t = {}),
                            t[o] = c[o])
                    } else
                        t || (s || (s = []),
                        s.push(f, t)),
                        t = c;
                else
                    f === "dangerouslySetInnerHTML" ? (c = c ? c.__html : void 0,
                    a = a ? a.__html : void 0,
                    c != null && a !== c && (s = s || []).push(f, c)) : f === "children" ? typeof c != "string" && typeof c != "number" || (s = s || []).push(f, "" + c) : f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && (Ec.hasOwnProperty(f) ? (c != null && f === "onScroll" && Gt("scroll", n),
                    s || a === c || (s = [])) : (s = s || []).push(f, c))
        }
        t && (s = s || []).push("style", t);
        var f = s;
        (e.updateQueue = f) && (e.flags |= 4)
    }
}
;
zA = function(n, e, t, i) {
    t !== i && (e.flags |= 4)
}
;
function Fu(n, e) {
    if (!qt)
        switch (n.tailMode) {
        case "hidden":
            e = n.tail;
            for (var t = null; e !== null; )
                e.alternate !== null && (t = e),
                e = e.sibling;
            t === null ? n.tail = null : t.sibling = null;
            break;
        case "collapsed":
            t = n.tail;
            for (var i = null; t !== null; )
                t.alternate !== null && (i = t),
                t = t.sibling;
            i === null ? e || n.tail === null ? n.tail = null : n.tail.sibling = null : i.sibling = null
        }
}
function Zn(n) {
    var e = n.alternate !== null && n.alternate.child === n.child
      , t = 0
      , i = 0;
    if (e)
        for (var r = n.child; r !== null; )
            t |= r.lanes | r.childLanes,
            i |= r.subtreeFlags & 14680064,
            i |= r.flags & 14680064,
            r.return = n,
            r = r.sibling;
    else
        for (r = n.child; r !== null; )
            t |= r.lanes | r.childLanes,
            i |= r.subtreeFlags,
            i |= r.flags,
            r.return = n,
            r = r.sibling;
    return n.subtreeFlags |= i,
    n.childLanes = t,
    e
}
function FP(n, e, t) {
    var i = e.pendingProps;
    switch (a_(e),
    e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return Zn(e),
        null;
    case 1:
        return Ai(e.type) && lp(),
        Zn(e),
        null;
    case 3:
        return i = e.stateNode,
        jl(),
        Xt(Ti),
        Xt(ii),
        g_(),
        i.pendingContext && (i.context = i.pendingContext,
        i.pendingContext = null),
        (n === null || n.child === null) && (Nh(e) ? e.flags |= 4 : n === null || n.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024,
        Mr !== null && (Gv(Mr),
        Mr = null))),
        Uv(n, e),
        Zn(e),
        null;
    case 5:
        m_(e);
        var r = ea(Oc.current);
        if (t = e.type,
        n !== null && e.stateNode != null)
            kA(n, e, t, i, r),
            n.ref !== e.ref && (e.flags |= 512,
            e.flags |= 2097152);
        else {
            if (!i) {
                if (e.stateNode === null)
                    throw Error(_e(166));
                return Zn(e),
                null
            }
            if (n = ea(Yr.current),
            Nh(e)) {
                i = e.stateNode,
                t = e.type;
                var s = e.memoizedProps;
                switch (i[Hr] = e,
                i[Dc] = s,
                n = (e.mode & 1) !== 0,
                t) {
                case "dialog":
                    Gt("cancel", i),
                    Gt("close", i);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    Gt("load", i);
                    break;
                case "video":
                case "audio":
                    for (r = 0; r < ac.length; r++)
                        Gt(ac[r], i);
                    break;
                case "source":
                    Gt("error", i);
                    break;
                case "img":
                case "image":
                case "link":
                    Gt("error", i),
                    Gt("load", i);
                    break;
                case "details":
                    Gt("toggle", i);
                    break;
                case "input":
                    fS(i, s),
                    Gt("invalid", i);
                    break;
                case "select":
                    i._wrapperState = {
                        wasMultiple: !!s.multiple
                    },
                    Gt("invalid", i);
                    break;
                case "textarea":
                    dS(i, s),
                    Gt("invalid", i)
                }
                lv(t, s),
                r = null;
                for (var o in s)
                    if (s.hasOwnProperty(o)) {
                        var a = s[o];
                        o === "children" ? typeof a == "string" ? i.textContent !== a && (s.suppressHydrationWarning !== !0 && Ih(i.textContent, a, n),
                        r = ["children", a]) : typeof a == "number" && i.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && Ih(i.textContent, a, n),
                        r = ["children", "" + a]) : Ec.hasOwnProperty(o) && a != null && o === "onScroll" && Gt("scroll", i)
                    }
                switch (t) {
                case "input":
                    Eh(i),
                    hS(i, s, !0);
                    break;
                case "textarea":
                    Eh(i),
                    pS(i);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof s.onClick == "function" && (i.onclick = ap)
                }
                i = r,
                e.updateQueue = i,
                i !== null && (e.flags |= 4)
            } else {
                o = r.nodeType === 9 ? r : r.ownerDocument,
                n === "http://www.w3.org/1999/xhtml" && (n = dT(t)),
                n === "http://www.w3.org/1999/xhtml" ? t === "script" ? (n = o.createElement("div"),
                n.innerHTML = "<script><\/script>",
                n = n.removeChild(n.firstChild)) : typeof i.is == "string" ? n = o.createElement(t, {
                    is: i.is
                }) : (n = o.createElement(t),
                t === "select" && (o = n,
                i.multiple ? o.multiple = !0 : i.size && (o.size = i.size))) : n = o.createElementNS(n, t),
                n[Hr] = e,
                n[Dc] = i,
                FA(n, e, !1, !1),
                e.stateNode = n;
                e: {
                    switch (o = uv(t, i),
                    t) {
                    case "dialog":
                        Gt("cancel", n),
                        Gt("close", n),
                        r = i;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        Gt("load", n),
                        r = i;
                        break;
                    case "video":
                    case "audio":
                        for (r = 0; r < ac.length; r++)
                            Gt(ac[r], n);
                        r = i;
                        break;
                    case "source":
                        Gt("error", n),
                        r = i;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        Gt("error", n),
                        Gt("load", n),
                        r = i;
                        break;
                    case "details":
                        Gt("toggle", n),
                        r = i;
                        break;
                    case "input":
                        fS(n, i),
                        r = iv(n, i),
                        Gt("invalid", n);
                        break;
                    case "option":
                        r = i;
                        break;
                    case "select":
                        n._wrapperState = {
                            wasMultiple: !!i.multiple
                        },
                        r = tn({}, i, {
                            value: void 0
                        }),
                        Gt("invalid", n);
                        break;
                    case "textarea":
                        dS(n, i),
                        r = ov(n, i),
                        Gt("invalid", n);
                        break;
                    default:
                        r = i
                    }
                    lv(t, r),
                    a = r;
                    for (s in a)
                        if (a.hasOwnProperty(s)) {
                            var c = a[s];
                            s === "style" ? gT(n, c) : s === "dangerouslySetInnerHTML" ? (c = c ? c.__html : void 0,
                            c != null && pT(n, c)) : s === "children" ? typeof c == "string" ? (t !== "textarea" || c !== "") && Tc(n, c) : typeof c == "number" && Tc(n, "" + c) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Ec.hasOwnProperty(s) ? c != null && s === "onScroll" && Gt("scroll", n) : c != null && Yy(n, s, c, o))
                        }
                    switch (t) {
                    case "input":
                        Eh(n),
                        hS(n, i, !1);
                        break;
                    case "textarea":
                        Eh(n),
                        pS(n);
                        break;
                    case "option":
                        i.value != null && n.setAttribute("value", "" + ho(i.value));
                        break;
                    case "select":
                        n.multiple = !!i.multiple,
                        s = i.value,
                        s != null ? Ul(n, !!i.multiple, s, !1) : i.defaultValue != null && Ul(n, !!i.multiple, i.defaultValue, !0);
                        break;
                    default:
                        typeof r.onClick == "function" && (n.onclick = ap)
                    }
                    switch (t) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        i = !!i.autoFocus;
                        break e;
                    case "img":
                        i = !0;
                        break e;
                    default:
                        i = !1
                    }
                }
                i && (e.flags |= 4)
            }
            e.ref !== null && (e.flags |= 512,
            e.flags |= 2097152)
        }
        return Zn(e),
        null;
    case 6:
        if (n && e.stateNode != null)
            zA(n, e, n.memoizedProps, i);
        else {
            if (typeof i != "string" && e.stateNode === null)
                throw Error(_e(166));
            if (t = ea(Oc.current),
            ea(Yr.current),
            Nh(e)) {
                if (i = e.stateNode,
                t = e.memoizedProps,
                i[Hr] = e,
                (s = i.nodeValue !== t) && (n = Bi,
                n !== null))
                    switch (n.tag) {
                    case 3:
                        Ih(i.nodeValue, t, (n.mode & 1) !== 0);
                        break;
                    case 5:
                        n.memoizedProps.suppressHydrationWarning !== !0 && Ih(i.nodeValue, t, (n.mode & 1) !== 0)
                    }
                s && (e.flags |= 4)
            } else
                i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i),
                i[Hr] = e,
                e.stateNode = i
        }
        return Zn(e),
        null;
    case 13:
        if (Xt(Kt),
        i = e.memoizedState,
        n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
            if (qt && zi !== null && e.mode & 1 && !(e.flags & 128))
                iA(),
                Xl(),
                e.flags |= 98560,
                s = !1;
            else if (s = Nh(e),
            i !== null && i.dehydrated !== null) {
                if (n === null) {
                    if (!s)
                        throw Error(_e(318));
                    if (s = e.memoizedState,
                    s = s !== null ? s.dehydrated : null,
                    !s)
                        throw Error(_e(317));
                    s[Hr] = e
                } else
                    Xl(),
                    !(e.flags & 128) && (e.memoizedState = null),
                    e.flags |= 4;
                Zn(e),
                s = !1
            } else
                Mr !== null && (Gv(Mr),
                Mr = null),
                s = !0;
            if (!s)
                return e.flags & 65536 ? e : null
        }
        return e.flags & 128 ? (e.lanes = t,
        e) : (i = i !== null,
        i !== (n !== null && n.memoizedState !== null) && i && (e.child.flags |= 8192,
        e.mode & 1 && (n === null || Kt.current & 1 ? Mn === 0 && (Mn = 3) : R_())),
        e.updateQueue !== null && (e.flags |= 4),
        Zn(e),
        null);
    case 4:
        return jl(),
        Uv(n, e),
        n === null && Ic(e.stateNode.containerInfo),
        Zn(e),
        null;
    case 10:
        return f_(e.type._context),
        Zn(e),
        null;
    case 17:
        return Ai(e.type) && lp(),
        Zn(e),
        null;
    case 19:
        if (Xt(Kt),
        s = e.memoizedState,
        s === null)
            return Zn(e),
            null;
        if (i = (e.flags & 128) !== 0,
        o = s.rendering,
        o === null)
            if (i)
                Fu(s, !1);
            else {
                if (Mn !== 0 || n !== null && n.flags & 128)
                    for (n = e.child; n !== null; ) {
                        if (o = mp(n),
                        o !== null) {
                            for (e.flags |= 128,
                            Fu(s, !1),
                            i = o.updateQueue,
                            i !== null && (e.updateQueue = i,
                            e.flags |= 4),
                            e.subtreeFlags = 0,
                            i = t,
                            t = e.child; t !== null; )
                                s = t,
                                n = i,
                                s.flags &= 14680066,
                                o = s.alternate,
                                o === null ? (s.childLanes = 0,
                                s.lanes = n,
                                s.child = null,
                                s.subtreeFlags = 0,
                                s.memoizedProps = null,
                                s.memoizedState = null,
                                s.updateQueue = null,
                                s.dependencies = null,
                                s.stateNode = null) : (s.childLanes = o.childLanes,
                                s.lanes = o.lanes,
                                s.child = o.child,
                                s.subtreeFlags = 0,
                                s.deletions = null,
                                s.memoizedProps = o.memoizedProps,
                                s.memoizedState = o.memoizedState,
                                s.updateQueue = o.updateQueue,
                                s.type = o.type,
                                n = o.dependencies,
                                s.dependencies = n === null ? null : {
                                    lanes: n.lanes,
                                    firstContext: n.firstContext
                                }),
                                t = t.sibling;
                            return Ht(Kt, Kt.current & 1 | 2),
                            e.child
                        }
                        n = n.sibling
                    }
                s.tail !== null && dn() > Zl && (e.flags |= 128,
                i = !0,
                Fu(s, !1),
                e.lanes = 4194304)
            }
        else {
            if (!i)
                if (n = mp(o),
                n !== null) {
                    if (e.flags |= 128,
                    i = !0,
                    t = n.updateQueue,
                    t !== null && (e.updateQueue = t,
                    e.flags |= 4),
                    Fu(s, !0),
                    s.tail === null && s.tailMode === "hidden" && !o.alternate && !qt)
                        return Zn(e),
                        null
                } else
                    2 * dn() - s.renderingStartTime > Zl && t !== 1073741824 && (e.flags |= 128,
                    i = !0,
                    Fu(s, !1),
                    e.lanes = 4194304);
            s.isBackwards ? (o.sibling = e.child,
            e.child = o) : (t = s.last,
            t !== null ? t.sibling = o : e.child = o,
            s.last = o)
        }
        return s.tail !== null ? (e = s.tail,
        s.rendering = e,
        s.tail = e.sibling,
        s.renderingStartTime = dn(),
        e.sibling = null,
        t = Kt.current,
        Ht(Kt, i ? t & 1 | 2 : t & 1),
        e) : (Zn(e),
        null);
    case 22:
    case 23:
        return C_(),
        i = e.memoizedState !== null,
        n !== null && n.memoizedState !== null !== i && (e.flags |= 8192),
        i && e.mode & 1 ? Oi & 1073741824 && (Zn(e),
        e.subtreeFlags & 6 && (e.flags |= 8192)) : Zn(e),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(_e(156, e.tag))
}
function kP(n, e) {
    switch (a_(e),
    e.tag) {
    case 1:
        return Ai(e.type) && lp(),
        n = e.flags,
        n & 65536 ? (e.flags = n & -65537 | 128,
        e) : null;
    case 3:
        return jl(),
        Xt(Ti),
        Xt(ii),
        g_(),
        n = e.flags,
        n & 65536 && !(n & 128) ? (e.flags = n & -65537 | 128,
        e) : null;
    case 5:
        return m_(e),
        null;
    case 13:
        if (Xt(Kt),
        n = e.memoizedState,
        n !== null && n.dehydrated !== null) {
            if (e.alternate === null)
                throw Error(_e(340));
            Xl()
        }
        return n = e.flags,
        n & 65536 ? (e.flags = n & -65537 | 128,
        e) : null;
    case 19:
        return Xt(Kt),
        null;
    case 4:
        return jl(),
        null;
    case 10:
        return f_(e.type._context),
        null;
    case 22:
    case 23:
        return C_(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Oh = !1
  , $n = !1
  , zP = typeof WeakSet == "function" ? WeakSet : Set
  , Be = null;
function Cl(n, e) {
    var t = n.ref;
    if (t !== null)
        if (typeof t == "function")
            try {
                t(null)
            } catch (i) {
                an(n, e, i)
            }
        else
            t.current = null
}
function Ov(n, e, t) {
    try {
        t()
    } catch (i) {
        an(n, e, i)
    }
}
var iM = !1;
function BP(n, e) {
    if (_v = rp,
    n = WT(),
    s_(n)) {
        if ("selectionStart"in n)
            var t = {
                start: n.selectionStart,
                end: n.selectionEnd
            };
        else
            e: {
                t = (t = n.ownerDocument) && t.defaultView || window;
                var i = t.getSelection && t.getSelection();
                if (i && i.rangeCount !== 0) {
                    t = i.anchorNode;
                    var r = i.anchorOffset
                      , s = i.focusNode;
                    i = i.focusOffset;
                    try {
                        t.nodeType,
                        s.nodeType
                    } catch {
                        t = null;
                        break e
                    }
                    var o = 0
                      , a = -1
                      , c = -1
                      , f = 0
                      , h = 0
                      , d = n
                      , m = null;
                    t: for (; ; ) {
                        for (var v; d !== t || r !== 0 && d.nodeType !== 3 || (a = o + r),
                        d !== s || i !== 0 && d.nodeType !== 3 || (c = o + i),
                        d.nodeType === 3 && (o += d.nodeValue.length),
                        (v = d.firstChild) !== null; )
                            m = d,
                            d = v;
                        for (; ; ) {
                            if (d === n)
                                break t;
                            if (m === t && ++f === r && (a = o),
                            m === s && ++h === i && (c = o),
                            (v = d.nextSibling) !== null)
                                break;
                            d = m,
                            m = d.parentNode
                        }
                        d = v
                    }
                    t = a === -1 || c === -1 ? null : {
                        start: a,
                        end: c
                    }
                } else
                    t = null
            }
        t = t || {
            start: 0,
            end: 0
        }
    } else
        t = null;
    for (xv = {
        focusedElem: n,
        selectionRange: t
    },
    rp = !1,
    Be = e; Be !== null; )
        if (e = Be,
        n = e.child,
        (e.subtreeFlags & 1028) !== 0 && n !== null)
            n.return = e,
            Be = n;
        else
            for (; Be !== null; ) {
                e = Be;
                try {
                    var _ = e.alternate;
                    if (e.flags & 1024)
                        switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (_ !== null) {
                                var w = _.memoizedProps
                                  , x = _.memoizedState
                                  , g = e.stateNode
                                  , S = g.getSnapshotBeforeUpdate(e.elementType === e.type ? w : _r(e.type, w), x);
                                g.__reactInternalSnapshotBeforeUpdate = S
                            }
                            break;
                        case 3:
                            var M = e.stateNode.containerInfo;
                            M.nodeType === 1 ? M.textContent = "" : M.nodeType === 9 && M.documentElement && M.removeChild(M.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(_e(163))
                        }
                } catch (T) {
                    an(e, e.return, T)
                }
                if (n = e.sibling,
                n !== null) {
                    n.return = e.return,
                    Be = n;
                    break
                }
                Be = e.return
            }
    return _ = iM,
    iM = !1,
    _
}
function mc(n, e, t) {
    var i = e.updateQueue;
    if (i = i !== null ? i.lastEffect : null,
    i !== null) {
        var r = i = i.next;
        do {
            if ((r.tag & n) === n) {
                var s = r.destroy;
                r.destroy = void 0,
                s !== void 0 && Ov(e, t, s)
            }
            r = r.next
        } while (r !== i)
    }
}
function Hp(n, e) {
    if (e = e.updateQueue,
    e = e !== null ? e.lastEffect : null,
    e !== null) {
        var t = e = e.next;
        do {
            if ((t.tag & n) === n) {
                var i = t.create;
                t.destroy = i()
            }
            t = t.next
        } while (t !== e)
    }
}
function Fv(n) {
    var e = n.ref;
    if (e !== null) {
        var t = n.stateNode;
        switch (n.tag) {
        case 5:
            n = t;
            break;
        default:
            n = t
        }
        typeof e == "function" ? e(n) : e.current = n
    }
}
function BA(n) {
    var e = n.alternate;
    e !== null && (n.alternate = null,
    BA(e)),
    n.child = null,
    n.deletions = null,
    n.sibling = null,
    n.tag === 5 && (e = n.stateNode,
    e !== null && (delete e[Hr],
    delete e[Dc],
    delete e[wv],
    delete e[MP],
    delete e[wP])),
    n.stateNode = null,
    n.return = null,
    n.dependencies = null,
    n.memoizedProps = null,
    n.memoizedState = null,
    n.pendingProps = null,
    n.stateNode = null,
    n.updateQueue = null
}
function HA(n) {
    return n.tag === 5 || n.tag === 3 || n.tag === 4
}
function rM(n) {
    e: for (; ; ) {
        for (; n.sibling === null; ) {
            if (n.return === null || HA(n.return))
                return null;
            n = n.return
        }
        for (n.sibling.return = n.return,
        n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18; ) {
            if (n.flags & 2 || n.child === null || n.tag === 4)
                continue e;
            n.child.return = n,
            n = n.child
        }
        if (!(n.flags & 2))
            return n.stateNode
    }
}
function kv(n, e, t) {
    var i = n.tag;
    if (i === 5 || i === 6)
        n = n.stateNode,
        e ? t.nodeType === 8 ? t.parentNode.insertBefore(n, e) : t.insertBefore(n, e) : (t.nodeType === 8 ? (e = t.parentNode,
        e.insertBefore(n, t)) : (e = t,
        e.appendChild(n)),
        t = t._reactRootContainer,
        t != null || e.onclick !== null || (e.onclick = ap));
    else if (i !== 4 && (n = n.child,
    n !== null))
        for (kv(n, e, t),
        n = n.sibling; n !== null; )
            kv(n, e, t),
            n = n.sibling
}
function zv(n, e, t) {
    var i = n.tag;
    if (i === 5 || i === 6)
        n = n.stateNode,
        e ? t.insertBefore(n, e) : t.appendChild(n);
    else if (i !== 4 && (n = n.child,
    n !== null))
        for (zv(n, e, t),
        n = n.sibling; n !== null; )
            zv(n, e, t),
            n = n.sibling
}
var Bn = null
  , Sr = !1;
function ks(n, e, t) {
    for (t = t.child; t !== null; )
        VA(n, e, t),
        t = t.sibling
}
function VA(n, e, t) {
    if (Xr && typeof Xr.onCommitFiberUnmount == "function")
        try {
            Xr.onCommitFiberUnmount(Np, t)
        } catch {}
    switch (t.tag) {
    case 5:
        $n || Cl(t, e);
    case 6:
        var i = Bn
          , r = Sr;
        Bn = null,
        ks(n, e, t),
        Bn = i,
        Sr = r,
        Bn !== null && (Sr ? (n = Bn,
        t = t.stateNode,
        n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t)) : Bn.removeChild(t.stateNode));
        break;
    case 18:
        Bn !== null && (Sr ? (n = Bn,
        t = t.stateNode,
        n.nodeType === 8 ? Yg(n.parentNode, t) : n.nodeType === 1 && Yg(n, t),
        bc(n)) : Yg(Bn, t.stateNode));
        break;
    case 4:
        i = Bn,
        r = Sr,
        Bn = t.stateNode.containerInfo,
        Sr = !0,
        ks(n, e, t),
        Bn = i,
        Sr = r;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!$n && (i = t.updateQueue,
        i !== null && (i = i.lastEffect,
        i !== null))) {
            r = i = i.next;
            do {
                var s = r
                  , o = s.destroy;
                s = s.tag,
                o !== void 0 && (s & 2 || s & 4) && Ov(t, e, o),
                r = r.next
            } while (r !== i)
        }
        ks(n, e, t);
        break;
    case 1:
        if (!$n && (Cl(t, e),
        i = t.stateNode,
        typeof i.componentWillUnmount == "function"))
            try {
                i.props = t.memoizedProps,
                i.state = t.memoizedState,
                i.componentWillUnmount()
            } catch (a) {
                an(t, e, a)
            }
        ks(n, e, t);
        break;
    case 21:
        ks(n, e, t);
        break;
    case 22:
        t.mode & 1 ? ($n = (i = $n) || t.memoizedState !== null,
        ks(n, e, t),
        $n = i) : ks(n, e, t);
        break;
    default:
        ks(n, e, t)
    }
}
function sM(n) {
    var e = n.updateQueue;
    if (e !== null) {
        n.updateQueue = null;
        var t = n.stateNode;
        t === null && (t = n.stateNode = new zP),
        e.forEach(function(i) {
            var r = ZP.bind(null, n, i);
            t.has(i) || (t.add(i),
            i.then(r, r))
        })
    }
}
function pr(n, e) {
    var t = e.deletions;
    if (t !== null)
        for (var i = 0; i < t.length; i++) {
            var r = t[i];
            try {
                var s = n
                  , o = e
                  , a = o;
                e: for (; a !== null; ) {
                    switch (a.tag) {
                    case 5:
                        Bn = a.stateNode,
                        Sr = !1;
                        break e;
                    case 3:
                        Bn = a.stateNode.containerInfo,
                        Sr = !0;
                        break e;
                    case 4:
                        Bn = a.stateNode.containerInfo,
                        Sr = !0;
                        break e
                    }
                    a = a.return
                }
                if (Bn === null)
                    throw Error(_e(160));
                VA(s, o, r),
                Bn = null,
                Sr = !1;
                var c = r.alternate;
                c !== null && (c.return = null),
                r.return = null
            } catch (f) {
                an(r, e, f)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null; )
            GA(e, n),
            e = e.sibling
}
function GA(n, e) {
    var t = n.alternate
      , i = n.flags;
    switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (pr(e, n),
        zr(n),
        i & 4) {
            try {
                mc(3, n, n.return),
                Hp(3, n)
            } catch (w) {
                an(n, n.return, w)
            }
            try {
                mc(5, n, n.return)
            } catch (w) {
                an(n, n.return, w)
            }
        }
        break;
    case 1:
        pr(e, n),
        zr(n),
        i & 512 && t !== null && Cl(t, t.return);
        break;
    case 5:
        if (pr(e, n),
        zr(n),
        i & 512 && t !== null && Cl(t, t.return),
        n.flags & 32) {
            var r = n.stateNode;
            try {
                Tc(r, "")
            } catch (w) {
                an(n, n.return, w)
            }
        }
        if (i & 4 && (r = n.stateNode,
        r != null)) {
            var s = n.memoizedProps
              , o = t !== null ? t.memoizedProps : s
              , a = n.type
              , c = n.updateQueue;
            if (n.updateQueue = null,
            c !== null)
                try {
                    a === "input" && s.type === "radio" && s.name != null && fT(r, s),
                    uv(a, o);
                    var f = uv(a, s);
                    for (o = 0; o < c.length; o += 2) {
                        var h = c[o]
                          , d = c[o + 1];
                        h === "style" ? gT(r, d) : h === "dangerouslySetInnerHTML" ? pT(r, d) : h === "children" ? Tc(r, d) : Yy(r, h, d, f)
                    }
                    switch (a) {
                    case "input":
                        rv(r, s);
                        break;
                    case "textarea":
                        hT(r, s);
                        break;
                    case "select":
                        var m = r._wrapperState.wasMultiple;
                        r._wrapperState.wasMultiple = !!s.multiple;
                        var v = s.value;
                        v != null ? Ul(r, !!s.multiple, v, !1) : m !== !!s.multiple && (s.defaultValue != null ? Ul(r, !!s.multiple, s.defaultValue, !0) : Ul(r, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    r[Dc] = s
                } catch (w) {
                    an(n, n.return, w)
                }
        }
        break;
    case 6:
        if (pr(e, n),
        zr(n),
        i & 4) {
            if (n.stateNode === null)
                throw Error(_e(162));
            r = n.stateNode,
            s = n.memoizedProps;
            try {
                r.nodeValue = s
            } catch (w) {
                an(n, n.return, w)
            }
        }
        break;
    case 3:
        if (pr(e, n),
        zr(n),
        i & 4 && t !== null && t.memoizedState.isDehydrated)
            try {
                bc(e.containerInfo)
            } catch (w) {
                an(n, n.return, w)
            }
        break;
    case 4:
        pr(e, n),
        zr(n);
        break;
    case 13:
        pr(e, n),
        zr(n),
        r = n.child,
        r.flags & 8192 && (s = r.memoizedState !== null,
        r.stateNode.isHidden = s,
        !s || r.alternate !== null && r.alternate.memoizedState !== null || (T_ = dn())),
        i & 4 && sM(n);
        break;
    case 22:
        if (h = t !== null && t.memoizedState !== null,
        n.mode & 1 ? ($n = (f = $n) || h,
        pr(e, n),
        $n = f) : pr(e, n),
        zr(n),
        i & 8192) {
            if (f = n.memoizedState !== null,
            (n.stateNode.isHidden = f) && !h && n.mode & 1)
                for (Be = n,
                h = n.child; h !== null; ) {
                    for (d = Be = h; Be !== null; ) {
                        switch (m = Be,
                        v = m.child,
                        m.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            mc(4, m, m.return);
                            break;
                        case 1:
                            Cl(m, m.return);
                            var _ = m.stateNode;
                            if (typeof _.componentWillUnmount == "function") {
                                i = m,
                                t = m.return;
                                try {
                                    e = i,
                                    _.props = e.memoizedProps,
                                    _.state = e.memoizedState,
                                    _.componentWillUnmount()
                                } catch (w) {
                                    an(i, t, w)
                                }
                            }
                            break;
                        case 5:
                            Cl(m, m.return);
                            break;
                        case 22:
                            if (m.memoizedState !== null) {
                                aM(d);
                                continue
                            }
                        }
                        v !== null ? (v.return = m,
                        Be = v) : aM(d)
                    }
                    h = h.sibling
                }
            e: for (h = null,
            d = n; ; ) {
                if (d.tag === 5) {
                    if (h === null) {
                        h = d;
                        try {
                            r = d.stateNode,
                            f ? (s = r.style,
                            typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = d.stateNode,
                            c = d.memoizedProps.style,
                            o = c != null && c.hasOwnProperty("display") ? c.display : null,
                            a.style.display = mT("display", o))
                        } catch (w) {
                            an(n, n.return, w)
                        }
                    }
                } else if (d.tag === 6) {
                    if (h === null)
                        try {
                            d.stateNode.nodeValue = f ? "" : d.memoizedProps
                        } catch (w) {
                            an(n, n.return, w)
                        }
                } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === n) && d.child !== null) {
                    d.child.return = d,
                    d = d.child;
                    continue
                }
                if (d === n)
                    break e;
                for (; d.sibling === null; ) {
                    if (d.return === null || d.return === n)
                        break e;
                    h === d && (h = null),
                    d = d.return
                }
                h === d && (h = null),
                d.sibling.return = d.return,
                d = d.sibling
            }
        }
        break;
    case 19:
        pr(e, n),
        zr(n),
        i & 4 && sM(n);
        break;
    case 21:
        break;
    default:
        pr(e, n),
        zr(n)
    }
}
function zr(n) {
    var e = n.flags;
    if (e & 2) {
        try {
            e: {
                for (var t = n.return; t !== null; ) {
                    if (HA(t)) {
                        var i = t;
                        break e
                    }
                    t = t.return
                }
                throw Error(_e(160))
            }
            switch (i.tag) {
            case 5:
                var r = i.stateNode;
                i.flags & 32 && (Tc(r, ""),
                i.flags &= -33);
                var s = rM(n);
                zv(n, s, r);
                break;
            case 3:
            case 4:
                var o = i.stateNode.containerInfo
                  , a = rM(n);
                kv(n, a, o);
                break;
            default:
                throw Error(_e(161))
            }
        } catch (c) {
            an(n, n.return, c)
        }
        n.flags &= -3
    }
    e & 4096 && (n.flags &= -4097)
}
function HP(n, e, t) {
    Be = n,
    WA(n)
}
function WA(n, e, t) {
    for (var i = (n.mode & 1) !== 0; Be !== null; ) {
        var r = Be
          , s = r.child;
        if (r.tag === 22 && i) {
            var o = r.memoizedState !== null || Oh;
            if (!o) {
                var a = r.alternate
                  , c = a !== null && a.memoizedState !== null || $n;
                a = Oh;
                var f = $n;
                if (Oh = o,
                ($n = c) && !f)
                    for (Be = r; Be !== null; )
                        o = Be,
                        c = o.child,
                        o.tag === 22 && o.memoizedState !== null ? lM(r) : c !== null ? (c.return = o,
                        Be = c) : lM(r);
                for (; s !== null; )
                    Be = s,
                    WA(s),
                    s = s.sibling;
                Be = r,
                Oh = a,
                $n = f
            }
            oM(n)
        } else
            r.subtreeFlags & 8772 && s !== null ? (s.return = r,
            Be = s) : oM(n)
    }
}
function oM(n) {
    for (; Be !== null; ) {
        var e = Be;
        if (e.flags & 8772) {
            var t = e.alternate;
            try {
                if (e.flags & 8772)
                    switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        $n || Hp(5, e);
                        break;
                    case 1:
                        var i = e.stateNode;
                        if (e.flags & 4 && !$n)
                            if (t === null)
                                i.componentDidMount();
                            else {
                                var r = e.elementType === e.type ? t.memoizedProps : _r(e.type, t.memoizedProps);
                                i.componentDidUpdate(r, t.memoizedState, i.__reactInternalSnapshotBeforeUpdate)
                            }
                        var s = e.updateQueue;
                        s !== null && WS(e, s, i);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (t = null,
                            e.child !== null)
                                switch (e.child.tag) {
                                case 5:
                                    t = e.child.stateNode;
                                    break;
                                case 1:
                                    t = e.child.stateNode
                                }
                            WS(e, o, t)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (t === null && e.flags & 4) {
                            t = a;
                            var c = e.memoizedProps;
                            switch (e.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                c.autoFocus && t.focus();
                                break;
                            case "img":
                                c.src && (t.src = c.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var f = e.alternate;
                            if (f !== null) {
                                var h = f.memoizedState;
                                if (h !== null) {
                                    var d = h.dehydrated;
                                    d !== null && bc(d)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(_e(163))
                    }
                $n || e.flags & 512 && Fv(e)
            } catch (m) {
                an(e, e.return, m)
            }
        }
        if (e === n) {
            Be = null;
            break
        }
        if (t = e.sibling,
        t !== null) {
            t.return = e.return,
            Be = t;
            break
        }
        Be = e.return
    }
}
function aM(n) {
    for (; Be !== null; ) {
        var e = Be;
        if (e === n) {
            Be = null;
            break
        }
        var t = e.sibling;
        if (t !== null) {
            t.return = e.return,
            Be = t;
            break
        }
        Be = e.return
    }
}
function lM(n) {
    for (; Be !== null; ) {
        var e = Be;
        try {
            switch (e.tag) {
            case 0:
            case 11:
            case 15:
                var t = e.return;
                try {
                    Hp(4, e)
                } catch (c) {
                    an(e, t, c)
                }
                break;
            case 1:
                var i = e.stateNode;
                if (typeof i.componentDidMount == "function") {
                    var r = e.return;
                    try {
                        i.componentDidMount()
                    } catch (c) {
                        an(e, r, c)
                    }
                }
                var s = e.return;
                try {
                    Fv(e)
                } catch (c) {
                    an(e, s, c)
                }
                break;
            case 5:
                var o = e.return;
                try {
                    Fv(e)
                } catch (c) {
                    an(e, o, c)
                }
            }
        } catch (c) {
            an(e, e.return, c)
        }
        if (e === n) {
            Be = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return,
            Be = a;
            break
        }
        Be = e.return
    }
}
var VP = Math.ceil
  , yp = As.ReactCurrentDispatcher
  , w_ = As.ReactCurrentOwner
  , ar = As.ReactCurrentBatchConfig
  , Rt = 0
  , Un = null
  , yn = null
  , Hn = 0
  , Oi = 0
  , Rl = yo(0)
  , Mn = 0
  , Bc = null
  , ma = 0
  , Vp = 0
  , E_ = 0
  , gc = null
  , Mi = null
  , T_ = 0
  , Zl = 1 / 0
  , fs = null
  , _p = !1
  , Bv = null
  , oo = null
  , Fh = !1
  , eo = null
  , xp = 0
  , vc = 0
  , Hv = null
  , Vd = -1
  , Gd = 0;
function hi() {
    return Rt & 6 ? dn() : Vd !== -1 ? Vd : Vd = dn()
}
function ao(n) {
    return n.mode & 1 ? Rt & 2 && Hn !== 0 ? Hn & -Hn : TP.transition !== null ? (Gd === 0 && (Gd = RT()),
    Gd) : (n = Ot,
    n !== 0 || (n = window.event,
    n = n === void 0 ? 16 : UT(n.type)),
    n) : 1
}
function Tr(n, e, t, i) {
    if (50 < vc)
        throw vc = 0,
        Hv = null,
        Error(_e(185));
    ff(n, t, i),
    (!(Rt & 2) || n !== Un) && (n === Un && (!(Rt & 2) && (Vp |= t),
    Mn === 4 && Ks(n, Hn)),
    Ci(n, i),
    t === 1 && Rt === 0 && !(e.mode & 1) && (Zl = dn() + 500,
    kp && _o()))
}
function Ci(n, e) {
    var t = n.callbackNode;
    T3(n, e);
    var i = ip(n, n === Un ? Hn : 0);
    if (i === 0)
        t !== null && vS(t),
        n.callbackNode = null,
        n.callbackPriority = 0;
    else if (e = i & -i,
    n.callbackPriority !== e) {
        if (t != null && vS(t),
        e === 1)
            n.tag === 0 ? EP(uM.bind(null, n)) : eA(uM.bind(null, n)),
            xP(function() {
                !(Rt & 6) && _o()
            }),
            t = null;
        else {
            switch (bT(i)) {
            case 1:
                t = Ky;
                break;
            case 4:
                t = AT;
                break;
            case 16:
                t = np;
                break;
            case 536870912:
                t = CT;
                break;
            default:
                t = np
            }
            t = QA(t, XA.bind(null, n))
        }
        n.callbackPriority = e,
        n.callbackNode = t
    }
}
function XA(n, e) {
    if (Vd = -1,
    Gd = 0,
    Rt & 6)
        throw Error(_e(327));
    var t = n.callbackNode;
    if (Bl() && n.callbackNode !== t)
        return null;
    var i = ip(n, n === Un ? Hn : 0);
    if (i === 0)
        return null;
    if (i & 30 || i & n.expiredLanes || e)
        e = Sp(n, i);
    else {
        e = i;
        var r = Rt;
        Rt |= 2;
        var s = jA();
        (Un !== n || Hn !== e) && (fs = null,
        Zl = dn() + 500,
        oa(n, e));
        do
            try {
                XP();
                break
            } catch (a) {
                YA(n, a)
            }
        while (!0);
        c_(),
        yp.current = s,
        Rt = r,
        yn !== null ? e = 0 : (Un = null,
        Hn = 0,
        e = Mn)
    }
    if (e !== 0) {
        if (e === 2 && (r = pv(n),
        r !== 0 && (i = r,
        e = Vv(n, r))),
        e === 1)
            throw t = Bc,
            oa(n, 0),
            Ks(n, i),
            Ci(n, dn()),
            t;
        if (e === 6)
            Ks(n, i);
        else {
            if (r = n.current.alternate,
            !(i & 30) && !GP(r) && (e = Sp(n, i),
            e === 2 && (s = pv(n),
            s !== 0 && (i = s,
            e = Vv(n, s))),
            e === 1))
                throw t = Bc,
                oa(n, 0),
                Ks(n, i),
                Ci(n, dn()),
                t;
            switch (n.finishedWork = r,
            n.finishedLanes = i,
            e) {
            case 0:
            case 1:
                throw Error(_e(345));
            case 2:
                jo(n, Mi, fs);
                break;
            case 3:
                if (Ks(n, i),
                (i & 130023424) === i && (e = T_ + 500 - dn(),
                10 < e)) {
                    if (ip(n, 0) !== 0)
                        break;
                    if (r = n.suspendedLanes,
                    (r & i) !== i) {
                        hi(),
                        n.pingedLanes |= n.suspendedLanes & r;
                        break
                    }
                    n.timeoutHandle = Mv(jo.bind(null, n, Mi, fs), e);
                    break
                }
                jo(n, Mi, fs);
                break;
            case 4:
                if (Ks(n, i),
                (i & 4194240) === i)
                    break;
                for (e = n.eventTimes,
                r = -1; 0 < i; ) {
                    var o = 31 - Er(i);
                    s = 1 << o,
                    o = e[o],
                    o > r && (r = o),
                    i &= ~s
                }
                if (i = r,
                i = dn() - i,
                i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * VP(i / 1960)) - i,
                10 < i) {
                    n.timeoutHandle = Mv(jo.bind(null, n, Mi, fs), i);
                    break
                }
                jo(n, Mi, fs);
                break;
            case 5:
                jo(n, Mi, fs);
                break;
            default:
                throw Error(_e(329))
            }
        }
    }
    return Ci(n, dn()),
    n.callbackNode === t ? XA.bind(null, n) : null
}
function Vv(n, e) {
    var t = gc;
    return n.current.memoizedState.isDehydrated && (oa(n, e).flags |= 256),
    n = Sp(n, e),
    n !== 2 && (e = Mi,
    Mi = t,
    e !== null && Gv(e)),
    n
}
function Gv(n) {
    Mi === null ? Mi = n : Mi.push.apply(Mi, n)
}
function GP(n) {
    for (var e = n; ; ) {
        if (e.flags & 16384) {
            var t = e.updateQueue;
            if (t !== null && (t = t.stores,
            t !== null))
                for (var i = 0; i < t.length; i++) {
                    var r = t[i]
                      , s = r.getSnapshot;
                    r = r.value;
                    try {
                        if (!Cr(s(), r))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (t = e.child,
        e.subtreeFlags & 16384 && t !== null)
            t.return = e,
            e = t;
        else {
            if (e === n)
                break;
            for (; e.sibling === null; ) {
                if (e.return === null || e.return === n)
                    return !0;
                e = e.return
            }
            e.sibling.return = e.return,
            e = e.sibling
        }
    }
    return !0
}
function Ks(n, e) {
    for (e &= ~E_,
    e &= ~Vp,
    n.suspendedLanes |= e,
    n.pingedLanes &= ~e,
    n = n.expirationTimes; 0 < e; ) {
        var t = 31 - Er(e)
          , i = 1 << t;
        n[t] = -1,
        e &= ~i
    }
}
function uM(n) {
    if (Rt & 6)
        throw Error(_e(327));
    Bl();
    var e = ip(n, 0);
    if (!(e & 1))
        return Ci(n, dn()),
        null;
    var t = Sp(n, e);
    if (n.tag !== 0 && t === 2) {
        var i = pv(n);
        i !== 0 && (e = i,
        t = Vv(n, i))
    }
    if (t === 1)
        throw t = Bc,
        oa(n, 0),
        Ks(n, e),
        Ci(n, dn()),
        t;
    if (t === 6)
        throw Error(_e(345));
    return n.finishedWork = n.current.alternate,
    n.finishedLanes = e,
    jo(n, Mi, fs),
    Ci(n, dn()),
    null
}
function A_(n, e) {
    var t = Rt;
    Rt |= 1;
    try {
        return n(e)
    } finally {
        Rt = t,
        Rt === 0 && (Zl = dn() + 500,
        kp && _o())
    }
}
function ga(n) {
    eo !== null && eo.tag === 0 && !(Rt & 6) && Bl();
    var e = Rt;
    Rt |= 1;
    var t = ar.transition
      , i = Ot;
    try {
        if (ar.transition = null,
        Ot = 1,
        n)
            return n()
    } finally {
        Ot = i,
        ar.transition = t,
        Rt = e,
        !(Rt & 6) && _o()
    }
}
function C_() {
    Oi = Rl.current,
    Xt(Rl)
}
function oa(n, e) {
    n.finishedWork = null,
    n.finishedLanes = 0;
    var t = n.timeoutHandle;
    if (t !== -1 && (n.timeoutHandle = -1,
    _P(t)),
    yn !== null)
        for (t = yn.return; t !== null; ) {
            var i = t;
            switch (a_(i),
            i.tag) {
            case 1:
                i = i.type.childContextTypes,
                i != null && lp();
                break;
            case 3:
                jl(),
                Xt(Ti),
                Xt(ii),
                g_();
                break;
            case 5:
                m_(i);
                break;
            case 4:
                jl();
                break;
            case 13:
                Xt(Kt);
                break;
            case 19:
                Xt(Kt);
                break;
            case 10:
                f_(i.type._context);
                break;
            case 22:
            case 23:
                C_()
            }
            t = t.return
        }
    if (Un = n,
    yn = n = lo(n.current, null),
    Hn = Oi = e,
    Mn = 0,
    Bc = null,
    E_ = Vp = ma = 0,
    Mi = gc = null,
    $o !== null) {
        for (e = 0; e < $o.length; e++)
            if (t = $o[e],
            i = t.interleaved,
            i !== null) {
                t.interleaved = null;
                var r = i.next
                  , s = t.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = r,
                    i.next = o
                }
                t.pending = i
            }
        $o = null
    }
    return n
}
function YA(n, e) {
    do {
        var t = yn;
        try {
            if (c_(),
            zd.current = vp,
            gp) {
                for (var i = $t.memoizedState; i !== null; ) {
                    var r = i.queue;
                    r !== null && (r.pending = null),
                    i = i.next
                }
                gp = !1
            }
            if (pa = 0,
            Nn = Sn = $t = null,
            pc = !1,
            Fc = 0,
            w_.current = null,
            t === null || t.return === null) {
                Mn = 1,
                Bc = e,
                yn = null;
                break
            }
            e: {
                var s = n
                  , o = t.return
                  , a = t
                  , c = e;
                if (e = Hn,
                a.flags |= 32768,
                c !== null && typeof c == "object" && typeof c.then == "function") {
                    var f = c
                      , h = a
                      , d = h.tag;
                    if (!(h.mode & 1) && (d === 0 || d === 11 || d === 15)) {
                        var m = h.alternate;
                        m ? (h.updateQueue = m.updateQueue,
                        h.memoizedState = m.memoizedState,
                        h.lanes = m.lanes) : (h.updateQueue = null,
                        h.memoizedState = null)
                    }
                    var v = JS(o);
                    if (v !== null) {
                        v.flags &= -257,
                        KS(v, o, a, s, e),
                        v.mode & 1 && ZS(s, f, e),
                        e = v,
                        c = f;
                        var _ = e.updateQueue;
                        if (_ === null) {
                            var w = new Set;
                            w.add(c),
                            e.updateQueue = w
                        } else
                            _.add(c);
                        break e
                    } else {
                        if (!(e & 1)) {
                            ZS(s, f, e),
                            R_();
                            break e
                        }
                        c = Error(_e(426))
                    }
                } else if (qt && a.mode & 1) {
                    var x = JS(o);
                    if (x !== null) {
                        !(x.flags & 65536) && (x.flags |= 256),
                        KS(x, o, a, s, e),
                        l_(ql(c, a));
                        break e
                    }
                }
                s = c = ql(c, a),
                Mn !== 4 && (Mn = 2),
                gc === null ? gc = [s] : gc.push(s),
                s = o;
                do {
                    switch (s.tag) {
                    case 3:
                        s.flags |= 65536,
                        e &= -e,
                        s.lanes |= e;
                        var g = bA(s, c, e);
                        GS(s, g);
                        break e;
                    case 1:
                        a = c;
                        var S = s.type
                          , M = s.stateNode;
                        if (!(s.flags & 128) && (typeof S.getDerivedStateFromError == "function" || M !== null && typeof M.componentDidCatch == "function" && (oo === null || !oo.has(M)))) {
                            s.flags |= 65536,
                            e &= -e,
                            s.lanes |= e;
                            var T = PA(s, a, e);
                            GS(s, T);
                            break e
                        }
                    }
                    s = s.return
                } while (s !== null)
            }
            ZA(t)
        } catch (P) {
            e = P,
            yn === t && t !== null && (yn = t = t.return);
            continue
        }
        break
    } while (!0)
}
function jA() {
    var n = yp.current;
    return yp.current = vp,
    n === null ? vp : n
}
function R_() {
    (Mn === 0 || Mn === 3 || Mn === 2) && (Mn = 4),
    Un === null || !(ma & 268435455) && !(Vp & 268435455) || Ks(Un, Hn)
}
function Sp(n, e) {
    var t = Rt;
    Rt |= 2;
    var i = jA();
    (Un !== n || Hn !== e) && (fs = null,
    oa(n, e));
    do
        try {
            WP();
            break
        } catch (r) {
            YA(n, r)
        }
    while (!0);
    if (c_(),
    Rt = t,
    yp.current = i,
    yn !== null)
        throw Error(_e(261));
    return Un = null,
    Hn = 0,
    Mn
}
function WP() {
    for (; yn !== null; )
        qA(yn)
}
function XP() {
    for (; yn !== null && !g3(); )
        qA(yn)
}
function qA(n) {
    var e = KA(n.alternate, n, Oi);
    n.memoizedProps = n.pendingProps,
    e === null ? ZA(n) : yn = e,
    w_.current = null
}
function ZA(n) {
    var e = n;
    do {
        var t = e.alternate;
        if (n = e.return,
        e.flags & 32768) {
            if (t = kP(t, e),
            t !== null) {
                t.flags &= 32767,
                yn = t;
                return
            }
            if (n !== null)
                n.flags |= 32768,
                n.subtreeFlags = 0,
                n.deletions = null;
            else {
                Mn = 6,
                yn = null;
                return
            }
        } else if (t = FP(t, e, Oi),
        t !== null) {
            yn = t;
            return
        }
        if (e = e.sibling,
        e !== null) {
            yn = e;
            return
        }
        yn = e = n
    } while (e !== null);
    Mn === 0 && (Mn = 5)
}
function jo(n, e, t) {
    var i = Ot
      , r = ar.transition;
    try {
        ar.transition = null,
        Ot = 1,
        YP(n, e, t, i)
    } finally {
        ar.transition = r,
        Ot = i
    }
    return null
}
function YP(n, e, t, i) {
    do
        Bl();
    while (eo !== null);
    if (Rt & 6)
        throw Error(_e(327));
    t = n.finishedWork;
    var r = n.finishedLanes;
    if (t === null)
        return null;
    if (n.finishedWork = null,
    n.finishedLanes = 0,
    t === n.current)
        throw Error(_e(177));
    n.callbackNode = null,
    n.callbackPriority = 0;
    var s = t.lanes | t.childLanes;
    if (A3(n, s),
    n === Un && (yn = Un = null,
    Hn = 0),
    !(t.subtreeFlags & 2064) && !(t.flags & 2064) || Fh || (Fh = !0,
    QA(np, function() {
        return Bl(),
        null
    })),
    s = (t.flags & 15990) !== 0,
    t.subtreeFlags & 15990 || s) {
        s = ar.transition,
        ar.transition = null;
        var o = Ot;
        Ot = 1;
        var a = Rt;
        Rt |= 4,
        w_.current = null,
        BP(n, t),
        GA(t, n),
        hP(xv),
        rp = !!_v,
        xv = _v = null,
        n.current = t,
        HP(t),
        v3(),
        Rt = a,
        Ot = o,
        ar.transition = s
    } else
        n.current = t;
    if (Fh && (Fh = !1,
    eo = n,
    xp = r),
    s = n.pendingLanes,
    s === 0 && (oo = null),
    x3(t.stateNode),
    Ci(n, dn()),
    e !== null)
        for (i = n.onRecoverableError,
        t = 0; t < e.length; t++)
            r = e[t],
            i(r.value, {
                componentStack: r.stack,
                digest: r.digest
            });
    if (_p)
        throw _p = !1,
        n = Bv,
        Bv = null,
        n;
    return xp & 1 && n.tag !== 0 && Bl(),
    s = n.pendingLanes,
    s & 1 ? n === Hv ? vc++ : (vc = 0,
    Hv = n) : vc = 0,
    _o(),
    null
}
function Bl() {
    if (eo !== null) {
        var n = bT(xp)
          , e = ar.transition
          , t = Ot;
        try {
            if (ar.transition = null,
            Ot = 16 > n ? 16 : n,
            eo === null)
                var i = !1;
            else {
                if (n = eo,
                eo = null,
                xp = 0,
                Rt & 6)
                    throw Error(_e(331));
                var r = Rt;
                for (Rt |= 4,
                Be = n.current; Be !== null; ) {
                    var s = Be
                      , o = s.child;
                    if (Be.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var c = 0; c < a.length; c++) {
                                var f = a[c];
                                for (Be = f; Be !== null; ) {
                                    var h = Be;
                                    switch (h.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        mc(8, h, s)
                                    }
                                    var d = h.child;
                                    if (d !== null)
                                        d.return = h,
                                        Be = d;
                                    else
                                        for (; Be !== null; ) {
                                            h = Be;
                                            var m = h.sibling
                                              , v = h.return;
                                            if (BA(h),
                                            h === f) {
                                                Be = null;
                                                break
                                            }
                                            if (m !== null) {
                                                m.return = v,
                                                Be = m;
                                                break
                                            }
                                            Be = v
                                        }
                                }
                            }
                            var _ = s.alternate;
                            if (_ !== null) {
                                var w = _.child;
                                if (w !== null) {
                                    _.child = null;
                                    do {
                                        var x = w.sibling;
                                        w.sibling = null,
                                        w = x
                                    } while (w !== null)
                                }
                            }
                            Be = s
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null)
                        o.return = s,
                        Be = o;
                    else
                        e: for (; Be !== null; ) {
                            if (s = Be,
                            s.flags & 2048)
                                switch (s.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    mc(9, s, s.return)
                                }
                            var g = s.sibling;
                            if (g !== null) {
                                g.return = s.return,
                                Be = g;
                                break e
                            }
                            Be = s.return
                        }
                }
                var S = n.current;
                for (Be = S; Be !== null; ) {
                    o = Be;
                    var M = o.child;
                    if (o.subtreeFlags & 2064 && M !== null)
                        M.return = o,
                        Be = M;
                    else
                        e: for (o = S; Be !== null; ) {
                            if (a = Be,
                            a.flags & 2048)
                                try {
                                    switch (a.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Hp(9, a)
                                    }
                                } catch (P) {
                                    an(a, a.return, P)
                                }
                            if (a === o) {
                                Be = null;
                                break e
                            }
                            var T = a.sibling;
                            if (T !== null) {
                                T.return = a.return,
                                Be = T;
                                break e
                            }
                            Be = a.return
                        }
                }
                if (Rt = r,
                _o(),
                Xr && typeof Xr.onPostCommitFiberRoot == "function")
                    try {
                        Xr.onPostCommitFiberRoot(Np, n)
                    } catch {}
                i = !0
            }
            return i
        } finally {
            Ot = t,
            ar.transition = e
        }
    }
    return !1
}
function cM(n, e, t) {
    e = ql(t, e),
    e = bA(n, e, 1),
    n = so(n, e, 1),
    e = hi(),
    n !== null && (ff(n, 1, e),
    Ci(n, e))
}
function an(n, e, t) {
    if (n.tag === 3)
        cM(n, n, t);
    else
        for (; e !== null; ) {
            if (e.tag === 3) {
                cM(e, n, t);
                break
            } else if (e.tag === 1) {
                var i = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (oo === null || !oo.has(i))) {
                    n = ql(t, n),
                    n = PA(e, n, 1),
                    e = so(e, n, 1),
                    n = hi(),
                    e !== null && (ff(e, 1, n),
                    Ci(e, n));
                    break
                }
            }
            e = e.return
        }
}
function jP(n, e, t) {
    var i = n.pingCache;
    i !== null && i.delete(e),
    e = hi(),
    n.pingedLanes |= n.suspendedLanes & t,
    Un === n && (Hn & t) === t && (Mn === 4 || Mn === 3 && (Hn & 130023424) === Hn && 500 > dn() - T_ ? oa(n, 0) : E_ |= t),
    Ci(n, e)
}
function JA(n, e) {
    e === 0 && (n.mode & 1 ? (e = Ch,
    Ch <<= 1,
    !(Ch & 130023424) && (Ch = 4194304)) : e = 1);
    var t = hi();
    n = ws(n, e),
    n !== null && (ff(n, e, t),
    Ci(n, t))
}
function qP(n) {
    var e = n.memoizedState
      , t = 0;
    e !== null && (t = e.retryLane),
    JA(n, t)
}
function ZP(n, e) {
    var t = 0;
    switch (n.tag) {
    case 13:
        var i = n.stateNode
          , r = n.memoizedState;
        r !== null && (t = r.retryLane);
        break;
    case 19:
        i = n.stateNode;
        break;
    default:
        throw Error(_e(314))
    }
    i !== null && i.delete(e),
    JA(n, t)
}
var KA;
KA = function(n, e, t) {
    if (n !== null)
        if (n.memoizedProps !== e.pendingProps || Ti.current)
            Ei = !0;
        else {
            if (!(n.lanes & t) && !(e.flags & 128))
                return Ei = !1,
                OP(n, e, t);
            Ei = !!(n.flags & 131072)
        }
    else
        Ei = !1,
        qt && e.flags & 1048576 && tA(e, fp, e.index);
    switch (e.lanes = 0,
    e.tag) {
    case 2:
        var i = e.type;
        Hd(n, e),
        n = e.pendingProps;
        var r = Wl(e, ii.current);
        zl(e, t),
        r = y_(null, e, i, n, r, t);
        var s = __();
        return e.flags |= 1,
        typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1,
        e.memoizedState = null,
        e.updateQueue = null,
        Ai(i) ? (s = !0,
        up(e)) : s = !1,
        e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null,
        d_(e),
        r.updater = Bp,
        e.stateNode = r,
        r._reactInternals = e,
        bv(e, i, n, t),
        e = Iv(null, e, i, !0, s, t)) : (e.tag = 0,
        qt && s && o_(e),
        ui(null, e, r, t),
        e = e.child),
        e;
    case 16:
        i = e.elementType;
        e: {
            switch (Hd(n, e),
            n = e.pendingProps,
            r = i._init,
            i = r(i._payload),
            e.type = i,
            r = e.tag = KP(i),
            n = _r(i, n),
            r) {
            case 0:
                e = Lv(null, e, i, n, t);
                break e;
            case 1:
                e = eM(null, e, i, n, t);
                break e;
            case 11:
                e = QS(null, e, i, n, t);
                break e;
            case 14:
                e = $S(null, e, i, _r(i.type, n), t);
                break e
            }
            throw Error(_e(306, i, ""))
        }
        return e;
    case 0:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : _r(i, r),
        Lv(n, e, i, r, t);
    case 1:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : _r(i, r),
        eM(n, e, i, r, t);
    case 3:
        e: {
            if (DA(e),
            n === null)
                throw Error(_e(387));
            i = e.pendingProps,
            s = e.memoizedState,
            r = s.element,
            aA(n, e),
            pp(e, i, null, t);
            var o = e.memoizedState;
            if (i = o.element,
            s.isDehydrated)
                if (s = {
                    element: i,
                    isDehydrated: !1,
                    cache: o.cache,
                    pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                    transitions: o.transitions
                },
                e.updateQueue.baseState = s,
                e.memoizedState = s,
                e.flags & 256) {
                    r = ql(Error(_e(423)), e),
                    e = tM(n, e, i, t, r);
                    break e
                } else if (i !== r) {
                    r = ql(Error(_e(424)), e),
                    e = tM(n, e, i, t, r);
                    break e
                } else
                    for (zi = ro(e.stateNode.containerInfo.firstChild),
                    Bi = e,
                    qt = !0,
                    Mr = null,
                    t = sA(e, null, i, t),
                    e.child = t; t; )
                        t.flags = t.flags & -3 | 4096,
                        t = t.sibling;
            else {
                if (Xl(),
                i === r) {
                    e = Es(n, e, t);
                    break e
                }
                ui(n, e, i, t)
            }
            e = e.child
        }
        return e;
    case 5:
        return lA(e),
        n === null && Av(e),
        i = e.type,
        r = e.pendingProps,
        s = n !== null ? n.memoizedProps : null,
        o = r.children,
        Sv(i, r) ? o = null : s !== null && Sv(i, s) && (e.flags |= 32),
        NA(n, e),
        ui(n, e, o, t),
        e.child;
    case 6:
        return n === null && Av(e),
        null;
    case 13:
        return UA(n, e, t);
    case 4:
        return p_(e, e.stateNode.containerInfo),
        i = e.pendingProps,
        n === null ? e.child = Yl(e, null, i, t) : ui(n, e, i, t),
        e.child;
    case 11:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : _r(i, r),
        QS(n, e, i, r, t);
    case 7:
        return ui(n, e, e.pendingProps, t),
        e.child;
    case 8:
        return ui(n, e, e.pendingProps.children, t),
        e.child;
    case 12:
        return ui(n, e, e.pendingProps.children, t),
        e.child;
    case 10:
        e: {
            if (i = e.type._context,
            r = e.pendingProps,
            s = e.memoizedProps,
            o = r.value,
            Ht(hp, i._currentValue),
            i._currentValue = o,
            s !== null)
                if (Cr(s.value, o)) {
                    if (s.children === r.children && !Ti.current) {
                        e = Es(n, e, t);
                        break e
                    }
                } else
                    for (s = e.child,
                    s !== null && (s.return = e); s !== null; ) {
                        var a = s.dependencies;
                        if (a !== null) {
                            o = s.child;
                            for (var c = a.firstContext; c !== null; ) {
                                if (c.context === i) {
                                    if (s.tag === 1) {
                                        c = _s(-1, t & -t),
                                        c.tag = 2;
                                        var f = s.updateQueue;
                                        if (f !== null) {
                                            f = f.shared;
                                            var h = f.pending;
                                            h === null ? c.next = c : (c.next = h.next,
                                            h.next = c),
                                            f.pending = c
                                        }
                                    }
                                    s.lanes |= t,
                                    c = s.alternate,
                                    c !== null && (c.lanes |= t),
                                    Cv(s.return, t, e),
                                    a.lanes |= t;
                                    break
                                }
                                c = c.next
                            }
                        } else if (s.tag === 10)
                            o = s.type === e.type ? null : s.child;
                        else if (s.tag === 18) {
                            if (o = s.return,
                            o === null)
                                throw Error(_e(341));
                            o.lanes |= t,
                            a = o.alternate,
                            a !== null && (a.lanes |= t),
                            Cv(o, t, e),
                            o = s.sibling
                        } else
                            o = s.child;
                        if (o !== null)
                            o.return = s;
                        else
                            for (o = s; o !== null; ) {
                                if (o === e) {
                                    o = null;
                                    break
                                }
                                if (s = o.sibling,
                                s !== null) {
                                    s.return = o.return,
                                    o = s;
                                    break
                                }
                                o = o.return
                            }
                        s = o
                    }
            ui(n, e, r.children, t),
            e = e.child
        }
        return e;
    case 9:
        return r = e.type,
        i = e.pendingProps.children,
        zl(e, t),
        r = lr(r),
        i = i(r),
        e.flags |= 1,
        ui(n, e, i, t),
        e.child;
    case 14:
        return i = e.type,
        r = _r(i, e.pendingProps),
        r = _r(i.type, r),
        $S(n, e, i, r, t);
    case 15:
        return LA(n, e, e.type, e.pendingProps, t);
    case 17:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : _r(i, r),
        Hd(n, e),
        e.tag = 1,
        Ai(i) ? (n = !0,
        up(e)) : n = !1,
        zl(e, t),
        RA(e, i, r),
        bv(e, i, r, t),
        Iv(null, e, i, !0, n, t);
    case 19:
        return OA(n, e, t);
    case 22:
        return IA(n, e, t)
    }
    throw Error(_e(156, e.tag))
}
;
function QA(n, e) {
    return TT(n, e)
}
function JP(n, e, t, i) {
    this.tag = n,
    this.key = t,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = e,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = i,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function or(n, e, t, i) {
    return new JP(n,e,t,i)
}
function b_(n) {
    return n = n.prototype,
    !(!n || !n.isReactComponent)
}
function KP(n) {
    if (typeof n == "function")
        return b_(n) ? 1 : 0;
    if (n != null) {
        if (n = n.$$typeof,
        n === qy)
            return 11;
        if (n === Zy)
            return 14
    }
    return 2
}
function lo(n, e) {
    var t = n.alternate;
    return t === null ? (t = or(n.tag, e, n.key, n.mode),
    t.elementType = n.elementType,
    t.type = n.type,
    t.stateNode = n.stateNode,
    t.alternate = n,
    n.alternate = t) : (t.pendingProps = e,
    t.type = n.type,
    t.flags = 0,
    t.subtreeFlags = 0,
    t.deletions = null),
    t.flags = n.flags & 14680064,
    t.childLanes = n.childLanes,
    t.lanes = n.lanes,
    t.child = n.child,
    t.memoizedProps = n.memoizedProps,
    t.memoizedState = n.memoizedState,
    t.updateQueue = n.updateQueue,
    e = n.dependencies,
    t.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    },
    t.sibling = n.sibling,
    t.index = n.index,
    t.ref = n.ref,
    t
}
function Wd(n, e, t, i, r, s) {
    var o = 2;
    if (i = n,
    typeof n == "function")
        b_(n) && (o = 1);
    else if (typeof n == "string")
        o = 5;
    else
        e: switch (n) {
        case yl:
            return aa(t.children, r, s, e);
        case jy:
            o = 8,
            r |= 8;
            break;
        case $0:
            return n = or(12, t, e, r | 2),
            n.elementType = $0,
            n.lanes = s,
            n;
        case ev:
            return n = or(13, t, e, r),
            n.elementType = ev,
            n.lanes = s,
            n;
        case tv:
            return n = or(19, t, e, r),
            n.elementType = tv,
            n.lanes = s,
            n;
        case lT:
            return Gp(t, r, s, e);
        default:
            if (typeof n == "object" && n !== null)
                switch (n.$$typeof) {
                case oT:
                    o = 10;
                    break e;
                case aT:
                    o = 9;
                    break e;
                case qy:
                    o = 11;
                    break e;
                case Zy:
                    o = 14;
                    break e;
                case js:
                    o = 16,
                    i = null;
                    break e
                }
            throw Error(_e(130, n == null ? n : typeof n, ""))
        }
    return e = or(o, t, e, r),
    e.elementType = n,
    e.type = i,
    e.lanes = s,
    e
}
function aa(n, e, t, i) {
    return n = or(7, n, i, e),
    n.lanes = t,
    n
}
function Gp(n, e, t, i) {
    return n = or(22, n, i, e),
    n.elementType = lT,
    n.lanes = t,
    n.stateNode = {
        isHidden: !1
    },
    n
}
function e0(n, e, t) {
    return n = or(6, n, null, e),
    n.lanes = t,
    n
}
function t0(n, e, t) {
    return e = or(4, n.children !== null ? n.children : [], n.key, e),
    e.lanes = t,
    e.stateNode = {
        containerInfo: n.containerInfo,
        pendingChildren: null,
        implementation: n.implementation
    },
    e
}
function QP(n, e, t, i, r) {
    this.tag = e,
    this.containerInfo = n,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = Ug(0),
    this.expirationTimes = Ug(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = Ug(0),
    this.identifierPrefix = i,
    this.onRecoverableError = r,
    this.mutableSourceEagerHydrationData = null
}
function P_(n, e, t, i, r, s, o, a, c) {
    return n = new QP(n,e,t,a,c),
    e === 1 ? (e = 1,
    s === !0 && (e |= 8)) : e = 0,
    s = or(3, null, null, e),
    n.current = s,
    s.stateNode = n,
    s.memoizedState = {
        element: i,
        isDehydrated: t,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    d_(s),
    n
}
function $P(n, e, t) {
    var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: vl,
        key: i == null ? null : "" + i,
        children: n,
        containerInfo: e,
        implementation: t
    }
}
function $A(n) {
    if (!n)
        return po;
    n = n._reactInternals;
    e: {
        if (Ma(n) !== n || n.tag !== 1)
            throw Error(_e(170));
        var e = n;
        do {
            switch (e.tag) {
            case 3:
                e = e.stateNode.context;
                break e;
            case 1:
                if (Ai(e.type)) {
                    e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            e = e.return
        } while (e !== null);
        throw Error(_e(171))
    }
    if (n.tag === 1) {
        var t = n.type;
        if (Ai(t))
            return $T(n, t, e)
    }
    return e
}
function e2(n, e, t, i, r, s, o, a, c) {
    return n = P_(t, i, !0, n, r, s, o, a, c),
    n.context = $A(null),
    t = n.current,
    i = hi(),
    r = ao(t),
    s = _s(i, r),
    s.callback = e ?? null,
    so(t, s, r),
    n.current.lanes = r,
    ff(n, r, i),
    Ci(n, i),
    n
}
function Wp(n, e, t, i) {
    var r = e.current
      , s = hi()
      , o = ao(r);
    return t = $A(t),
    e.context === null ? e.context = t : e.pendingContext = t,
    e = _s(s, o),
    e.payload = {
        element: n
    },
    i = i === void 0 ? null : i,
    i !== null && (e.callback = i),
    n = so(r, e, o),
    n !== null && (Tr(n, r, o, s),
    kd(n, r, o)),
    o
}
function Mp(n) {
    if (n = n.current,
    !n.child)
        return null;
    switch (n.child.tag) {
    case 5:
        return n.child.stateNode;
    default:
        return n.child.stateNode
    }
}
function fM(n, e) {
    if (n = n.memoizedState,
    n !== null && n.dehydrated !== null) {
        var t = n.retryLane;
        n.retryLane = t !== 0 && t < e ? t : e
    }
}
function L_(n, e) {
    fM(n, e),
    (n = n.alternate) && fM(n, e)
}
function eL() {
    return null
}
var t2 = typeof reportError == "function" ? reportError : function(n) {
    console.error(n)
}
;
function I_(n) {
    this._internalRoot = n
}
Xp.prototype.render = I_.prototype.render = function(n) {
    var e = this._internalRoot;
    if (e === null)
        throw Error(_e(409));
    Wp(n, e, null, null)
}
;
Xp.prototype.unmount = I_.prototype.unmount = function() {
    var n = this._internalRoot;
    if (n !== null) {
        this._internalRoot = null;
        var e = n.containerInfo;
        ga(function() {
            Wp(null, n, null, null)
        }),
        e[Ms] = null
    }
}
;
function Xp(n) {
    this._internalRoot = n
}
Xp.prototype.unstable_scheduleHydration = function(n) {
    if (n) {
        var e = IT();
        n = {
            blockedOn: null,
            target: n,
            priority: e
        };
        for (var t = 0; t < Js.length && e !== 0 && e < Js[t].priority; t++)
            ;
        Js.splice(t, 0, n),
        t === 0 && DT(n)
    }
}
;
function N_(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11)
}
function Yp(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 && (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
}
function hM() {}
function tL(n, e, t, i, r) {
    if (r) {
        if (typeof i == "function") {
            var s = i;
            i = function() {
                var f = Mp(o);
                s.call(f)
            }
        }
        var o = e2(e, i, n, 0, null, !1, !1, "", hM);
        return n._reactRootContainer = o,
        n[Ms] = o.current,
        Ic(n.nodeType === 8 ? n.parentNode : n),
        ga(),
        o
    }
    for (; r = n.lastChild; )
        n.removeChild(r);
    if (typeof i == "function") {
        var a = i;
        i = function() {
            var f = Mp(c);
            a.call(f)
        }
    }
    var c = P_(n, 0, !1, null, null, !1, !1, "", hM);
    return n._reactRootContainer = c,
    n[Ms] = c.current,
    Ic(n.nodeType === 8 ? n.parentNode : n),
    ga(function() {
        Wp(e, c, t, i)
    }),
    c
}
function jp(n, e, t, i, r) {
    var s = t._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof r == "function") {
            var a = r;
            r = function() {
                var c = Mp(o);
                a.call(c)
            }
        }
        Wp(e, o, n, r)
    } else
        o = tL(t, e, n, r, i);
    return Mp(o)
}
PT = function(n) {
    switch (n.tag) {
    case 3:
        var e = n.stateNode;
        if (e.current.memoizedState.isDehydrated) {
            var t = oc(e.pendingLanes);
            t !== 0 && (Qy(e, t | 1),
            Ci(e, dn()),
            !(Rt & 6) && (Zl = dn() + 500,
            _o()))
        }
        break;
    case 13:
        ga(function() {
            var i = ws(n, 1);
            if (i !== null) {
                var r = hi();
                Tr(i, n, 1, r)
            }
        }),
        L_(n, 1)
    }
}
;
$y = function(n) {
    if (n.tag === 13) {
        var e = ws(n, 134217728);
        if (e !== null) {
            var t = hi();
            Tr(e, n, 134217728, t)
        }
        L_(n, 134217728)
    }
}
;
LT = function(n) {
    if (n.tag === 13) {
        var e = ao(n)
          , t = ws(n, e);
        if (t !== null) {
            var i = hi();
            Tr(t, n, e, i)
        }
        L_(n, e)
    }
}
;
IT = function() {
    return Ot
}
;
NT = function(n, e) {
    var t = Ot;
    try {
        return Ot = n,
        e()
    } finally {
        Ot = t
    }
}
;
fv = function(n, e, t) {
    switch (e) {
    case "input":
        if (rv(n, t),
        e = t.name,
        t.type === "radio" && e != null) {
            for (t = n; t.parentNode; )
                t = t.parentNode;
            for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'),
            e = 0; e < t.length; e++) {
                var i = t[e];
                if (i !== n && i.form === n.form) {
                    var r = Fp(i);
                    if (!r)
                        throw Error(_e(90));
                    cT(i),
                    rv(i, r)
                }
            }
        }
        break;
    case "textarea":
        hT(n, t);
        break;
    case "select":
        e = t.value,
        e != null && Ul(n, !!t.multiple, e, !1)
    }
}
;
_T = A_;
xT = ga;
var nL = {
    usingClientEntryPoint: !1,
    Events: [df, Ml, Fp, vT, yT, A_]
}
  , ku = {
    findFiberByHostInstance: Qo,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
}
  , iL = {
    bundleType: ku.bundleType,
    version: ku.version,
    rendererPackageName: ku.rendererPackageName,
    rendererConfig: ku.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: As.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(n) {
        return n = wT(n),
        n === null ? null : n.stateNode
    },
    findFiberByHostInstance: ku.findFiberByHostInstance || eL,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var kh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!kh.isDisabled && kh.supportsFiber)
        try {
            Np = kh.inject(iL),
            Xr = kh
        } catch {}
}
Gi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = nL;
Gi.createPortal = function(n, e) {
    var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!N_(e))
        throw Error(_e(200));
    return $P(n, e, null, t)
}
;
Gi.createRoot = function(n, e) {
    if (!N_(n))
        throw Error(_e(299));
    var t = !1
      , i = ""
      , r = t2;
    return e != null && (e.unstable_strictMode === !0 && (t = !0),
    e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
    e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    e = P_(n, 1, !1, null, null, t, !1, i, r),
    n[Ms] = e.current,
    Ic(n.nodeType === 8 ? n.parentNode : n),
    new I_(e)
}
;
Gi.findDOMNode = function(n) {
    if (n == null)
        return null;
    if (n.nodeType === 1)
        return n;
    var e = n._reactInternals;
    if (e === void 0)
        throw typeof n.render == "function" ? Error(_e(188)) : (n = Object.keys(n).join(","),
        Error(_e(268, n)));
    return n = wT(e),
    n = n === null ? null : n.stateNode,
    n
}
;
Gi.flushSync = function(n) {
    return ga(n)
}
;
Gi.hydrate = function(n, e, t) {
    if (!Yp(e))
        throw Error(_e(200));
    return jp(null, n, e, !0, t)
}
;
Gi.hydrateRoot = function(n, e, t) {
    if (!N_(n))
        throw Error(_e(405));
    var i = t != null && t.hydratedSources || null
      , r = !1
      , s = ""
      , o = t2;
    if (t != null && (t.unstable_strictMode === !0 && (r = !0),
    t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
    t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    e = e2(e, null, n, 1, t ?? null, r, !1, s, o),
    n[Ms] = e.current,
    Ic(n),
    i)
        for (n = 0; n < i.length; n++)
            t = i[n],
            r = t._getVersion,
            r = r(t._source),
            e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, r] : e.mutableSourceEagerHydrationData.push(t, r);
    return new Xp(e)
}
;
Gi.render = function(n, e, t) {
    if (!Yp(e))
        throw Error(_e(200));
    return jp(null, n, e, !1, t)
}
;
Gi.unmountComponentAtNode = function(n) {
    if (!Yp(n))
        throw Error(_e(40));
    return n._reactRootContainer ? (ga(function() {
        jp(null, null, n, !1, function() {
            n._reactRootContainer = null,
            n[Ms] = null
        })
    }),
    !0) : !1
}
;
Gi.unstable_batchedUpdates = A_;
Gi.unstable_renderSubtreeIntoContainer = function(n, e, t, i) {
    if (!Yp(t))
        throw Error(_e(200));
    if (n == null || n._reactInternals === void 0)
        throw Error(_e(38));
    return jp(n, e, t, !1, i)
}
;
Gi.version = "18.3.1-next-f1338f8080-20240426";
function n2() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n2)
        } catch (n) {
            console.error(n)
        }
}
n2(),
nT.exports = Gi;
var rL = nT.exports
  , dM = rL;
K0.createRoot = dM.createRoot,
K0.hydrateRoot = dM.hydrateRoot;
const sL = ({...n})=>{
    const e = `${n.size}px`;
    return ct.jsx("div", {
        className: "relative flex items-center justify-center pointer-events-auto",
        style: {
            width: e,
            height: e
        },
        children: ct.jsxs("svg", {
            width: e,
            height: e,
            viewBox: "0 0 1500 1500",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
            className: "",
            children: [ct.jsx("path", {
                d: "M754.952 683.963C843.052 683.19 951.388 707.242 1044.34 780.903C1127.12 846.498 1177.47 933.679 1209.37 1032.8C1229.07 1094.01 1240.63 1156.94 1248.87 1220.54C1253.29 1254.72 1245.29 1284.81 1214.97 1304.65C1189.15 1321.54 1161.65 1322.58 1134.2 1307.66C1106.59 1292.6 1095.71 1267.25 1092.45 1237.55C1087.36 1190.5 1078.33 1143.96 1065.47 1098.41C1052.06 1051.2 1032.82 1006.69 1005.03 965.903C965.518 907.92 911.89 869.163 843.945 853.911C741.582 830.993 640.125 834.792 541.987 875.776C507.422 890.202 475.802 909.88 449.462 936.585C411.977 974.609 397.673 1020.3 410.884 1072.78C426.733 1135.7 482.347 1172.26 547.066 1167.57C638.845 1160.9 716.641 1124.78 784.346 1063.79C812.606 1038.32 848.691 1035.79 879.084 1054.96C908.411 1073.47 921.555 1108.15 912.557 1142.5C908.717 1157.17 900.253 1168.75 889.468 1178.86C778.56 1282.85 647.737 1333.36 495.384 1321.7C376.505 1312.6 269.809 1207.41 253.439 1086.44C236.99 965.023 279.807 867.95 375.558 793.609C478.948 713.388 598.454 683.723 754.952 683.963Z",
                fill: "#fff"
            }), ct.jsx("path", {
                d: "M724.066 176C950.534 174.307 1118.43 273.993 1230.62 469.019C1253.61 509.016 1239.14 556.279 1201.38 576.758C1161.66 598.303 1117.12 585.157 1093.18 543.053C1039.51 448.634 963.252 381.318 858.969 348.614C692.34 296.325 510.194 370.146 416.002 526.988C411.137 535.094 406.738 543.507 401.486 551.359C378.104 586.33 334.288 596.69 297.722 576.291C280.674 566.82 267.875 551.207 261.931 532.63C255.987 514.053 257.346 493.909 265.73 476.298C287.058 430.435 317.038 389.945 351.39 353.094C440.277 257.714 548.959 198.892 678.449 180C693.513 177.747 708.843 177.333 724.066 176Z",
                fill: "#fff"
            })]
        })
    })
}
;
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const qp = "162"
  , oL = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , aL = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , i2 = 0
  , Wv = 1
  , r2 = 2
  , lL = 3
  , s2 = 0
  , Zp = 1
  , yc = 2
  , xr = 3
  , Zr = 0
  , ti = 1
  , Vr = 2
  , xs = 0
  , la = 1
  , Xv = 2
  , Yv = 3
  , jv = 4
  , o2 = 5
  , Qs = 100
  , a2 = 101
  , l2 = 102
  , qv = 103
  , Zv = 104
  , u2 = 200
  , c2 = 201
  , f2 = 202
  , h2 = 203
  , wp = 204
  , Ep = 205
  , d2 = 206
  , p2 = 207
  , m2 = 208
  , g2 = 209
  , v2 = 210
  , y2 = 211
  , _2 = 212
  , x2 = 213
  , S2 = 214
  , M2 = 0
  , w2 = 1
  , E2 = 2
  , Hc = 3
  , T2 = 4
  , A2 = 5
  , C2 = 6
  , R2 = 7
  , mf = 0
  , b2 = 1
  , P2 = 2
  , Ar = 0
  , L2 = 1
  , I2 = 2
  , N2 = 3
  , Jp = 4
  , D2 = 5
  , U2 = 6
  , O2 = 7
  , Jv = "attached"
  , F2 = "detached"
  , Kp = 300
  , Ts = 301
  , mo = 302
  , Vc = 303
  , Gc = 304
  , ru = 306
  , Wc = 1e3
  , ei = 1001
  , Xc = 1002
  , hn = 1003
  , Tp = 1004
  , uL = 1004
  , Jo = 1005
  , cL = 1005
  , Wt = 1006
  , _c = 1007
  , fL = 1007
  , Gr = 1008
  , hL = 1008
  , jr = 1009
  , k2 = 1010
  , z2 = 1011
  , Qp = 1012
  , D_ = 1013
  , vs = 1014
  , wi = 1015
  , va = 1016
  , U_ = 1017
  , O_ = 1018
  , uo = 1020
  , B2 = 1021
  , ci = 1023
  , H2 = 1024
  , V2 = 1025
  , co = 1026
  , ya = 1027
  , F_ = 1028
  , k_ = 1029
  , G2 = 1030
  , z_ = 1031
  , B_ = 1033
  , Xd = 33776
  , Yd = 33777
  , jd = 33778
  , qd = 33779
  , Kv = 35840
  , Qv = 35841
  , $v = 35842
  , ey = 35843
  , H_ = 36196
  , ty = 37492
  , ny = 37496
  , iy = 37808
  , ry = 37809
  , sy = 37810
  , oy = 37811
  , ay = 37812
  , ly = 37813
  , uy = 37814
  , cy = 37815
  , fy = 37816
  , hy = 37817
  , dy = 37818
  , py = 37819
  , my = 37820
  , gy = 37821
  , Zd = 36492
  , vy = 36494
  , yy = 36495
  , W2 = 36283
  , _y = 36284
  , xy = 36285
  , Sy = 36286
  , X2 = 2200
  , Y2 = 2201
  , j2 = 2202
  , Yc = 2300
  , jc = 2301
  , Jd = 2302
  , ta = 2400
  , na = 2401
  , qc = 2402
  , $p = 2500
  , V_ = 2501
  , dL = 0
  , pL = 1
  , mL = 2
  , q2 = 3200
  , Z2 = 3201
  , xo = 0
  , J2 = 1
  , ds = ""
  , Fi = "srgb"
  , Cs = "srgb-linear"
  , em = "display-p3"
  , gf = "display-p3-linear"
  , Zc = "linear"
  , Bt = "srgb"
  , Jc = "rec709"
  , Kc = "p3"
  , gL = 0
  , qo = 7680
  , vL = 7681
  , yL = 7682
  , _L = 7683
  , xL = 34055
  , SL = 34056
  , ML = 5386
  , wL = 512
  , EL = 513
  , TL = 514
  , AL = 515
  , CL = 516
  , RL = 517
  , bL = 518
  , My = 519
  , K2 = 512
  , Q2 = 513
  , $2 = 514
  , G_ = 515
  , eC = 516
  , tC = 517
  , nC = 518
  , iC = 519
  , Qc = 35044
  , PL = 35048
  , LL = 35040
  , IL = 35045
  , NL = 35049
  , DL = 35041
  , UL = 35046
  , OL = 35050
  , FL = 35042
  , kL = "100"
  , wy = "300 es"
  , Ap = 1035
  , Wr = 2e3
  , $c = 2001;
class Rs {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []),
        i[e].indexOf(t) === -1 && i[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const i = this._listeners;
        return i[e] !== void 0 && i[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const r = this._listeners[e];
        if (r !== void 0) {
            const s = r.indexOf(t);
            s !== -1 && r.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[e.type];
        if (i !== void 0) {
            e.target = this;
            const r = i.slice(0);
            for (let s = 0, o = r.length; s < o; s++)
                r[s].call(this, e);
            e.target = null
        }
    }
}
const Jn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let pM = 1234567;
const ua = Math.PI / 180
  , Jl = 180 / Math.PI;
function Hi() {
    const n = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , i = Math.random() * 4294967295 | 0;
    return (Jn[n & 255] + Jn[n >> 8 & 255] + Jn[n >> 16 & 255] + Jn[n >> 24 & 255] + "-" + Jn[e & 255] + Jn[e >> 8 & 255] + "-" + Jn[e >> 16 & 15 | 64] + Jn[e >> 24 & 255] + "-" + Jn[t & 63 | 128] + Jn[t >> 8 & 255] + "-" + Jn[t >> 16 & 255] + Jn[t >> 24 & 255] + Jn[i & 255] + Jn[i >> 8 & 255] + Jn[i >> 16 & 255] + Jn[i >> 24 & 255]).toLowerCase()
}
function ln(n, e, t) {
    return Math.max(e, Math.min(t, n))
}
function W_(n, e) {
    return (n % e + e) % e
}
function zL(n, e, t, i, r) {
    return i + (n - e) * (r - i) / (t - e)
}
function BL(n, e, t) {
    return n !== e ? (t - n) / (e - n) : 0
}
function xc(n, e, t) {
    return (1 - t) * n + t * e
}
function HL(n, e, t, i) {
    return xc(n, e, 1 - Math.exp(-t * i))
}
function VL(n, e=1) {
    return e - Math.abs(W_(n, e * 2) - e)
}
function GL(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * (3 - 2 * n))
}
function WL(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * n * (n * (n * 6 - 15) + 10))
}
function XL(n, e) {
    return n + Math.floor(Math.random() * (e - n + 1))
}
function YL(n, e) {
    return n + Math.random() * (e - n)
}
function jL(n) {
    return n * (.5 - Math.random())
}
function qL(n) {
    n !== void 0 && (pM = n);
    let e = pM += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function ZL(n) {
    return n * ua
}
function JL(n) {
    return n * Jl
}
function Ey(n) {
    return (n & n - 1) === 0 && n !== 0
}
function KL(n) {
    return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}
function Cp(n) {
    return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}
function QL(n, e, t, i, r) {
    const s = Math.cos
      , o = Math.sin
      , a = s(t / 2)
      , c = o(t / 2)
      , f = s((e + i) / 2)
      , h = o((e + i) / 2)
      , d = s((e - i) / 2)
      , m = o((e - i) / 2)
      , v = s((i - e) / 2)
      , _ = o((i - e) / 2);
    switch (r) {
    case "XYX":
        n.set(a * h, c * d, c * m, a * f);
        break;
    case "YZY":
        n.set(c * m, a * h, c * d, a * f);
        break;
    case "ZXZ":
        n.set(c * d, c * m, a * h, a * f);
        break;
    case "XZX":
        n.set(a * h, c * _, c * v, a * f);
        break;
    case "YXY":
        n.set(c * v, a * h, c * _, a * f);
        break;
    case "ZYZ":
        n.set(c * _, c * v, a * h, a * f);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
    }
}
function fi(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return n / 4294967295;
    case Uint16Array:
        return n / 65535;
    case Uint8Array:
        return n / 255;
    case Int32Array:
        return Math.max(n / 2147483647, -1);
    case Int16Array:
        return Math.max(n / 32767, -1);
    case Int8Array:
        return Math.max(n / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function gt(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return Math.round(n * 4294967295);
    case Uint16Array:
        return Math.round(n * 65535);
    case Uint8Array:
        return Math.round(n * 255);
    case Int32Array:
        return Math.round(n * 2147483647);
    case Int16Array:
        return Math.round(n * 32767);
    case Int8Array:
        return Math.round(n * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
const rC = {
    DEG2RAD: ua,
    RAD2DEG: Jl,
    generateUUID: Hi,
    clamp: ln,
    euclideanModulo: W_,
    mapLinear: zL,
    inverseLerp: BL,
    lerp: xc,
    damp: HL,
    pingpong: VL,
    smoothstep: GL,
    smootherstep: WL,
    randInt: XL,
    randFloat: YL,
    randFloatSpread: jL,
    seededRandom: qL,
    degToRad: ZL,
    radToDeg: JL,
    isPowerOfTwo: Ey,
    ceilPowerOfTwo: KL,
    floorPowerOfTwo: Cp,
    setQuaternionFromProperEuler: QL,
    normalize: gt,
    denormalize: fi
};
class he {
    constructor(e=0, t=0) {
        he.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = e.elements;
        return this.x = r[0] * t + r[3] * i + r[6],
        this.y = r[1] * t + r[4] * i + r[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(ln(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y;
        return t * t + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = this.x - e.x
          , o = this.y - e.y;
        return this.x = s * i - o * r + e.x,
        this.y = s * r + o * i + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class mt {
    constructor(e, t, i, r, s, o, a, c, f) {
        mt.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, i, r, s, o, a, c, f)
    }
    set(e, t, i, r, s, o, a, c, f) {
        const h = this.elements;
        return h[0] = e,
        h[1] = r,
        h[2] = a,
        h[3] = t,
        h[4] = s,
        h[5] = c,
        h[6] = i,
        h[7] = o,
        h[8] = f,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        i.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , a = i[3]
          , c = i[6]
          , f = i[1]
          , h = i[4]
          , d = i[7]
          , m = i[2]
          , v = i[5]
          , _ = i[8]
          , w = r[0]
          , x = r[3]
          , g = r[6]
          , S = r[1]
          , M = r[4]
          , T = r[7]
          , P = r[2]
          , R = r[5]
          , b = r[8];
        return s[0] = o * w + a * S + c * P,
        s[3] = o * x + a * M + c * R,
        s[6] = o * g + a * T + c * b,
        s[1] = f * w + h * S + d * P,
        s[4] = f * x + h * M + d * R,
        s[7] = f * g + h * T + d * b,
        s[2] = m * w + v * S + _ * P,
        s[5] = m * x + v * M + _ * R,
        s[8] = m * g + v * T + _ * b,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , c = e[6]
          , f = e[7]
          , h = e[8];
        return t * o * h - t * a * f - i * s * h + i * a * c + r * s * f - r * o * c
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , c = e[6]
          , f = e[7]
          , h = e[8]
          , d = h * o - a * f
          , m = a * c - h * s
          , v = f * s - o * c
          , _ = t * d + i * m + r * v;
        if (_ === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const w = 1 / _;
        return e[0] = d * w,
        e[1] = (r * f - h * i) * w,
        e[2] = (a * i - r * o) * w,
        e[3] = m * w,
        e[4] = (h * t - r * c) * w,
        e[5] = (r * s - a * t) * w,
        e[6] = v * w,
        e[7] = (i * c - f * t) * w,
        e[8] = (o * t - i * s) * w,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, i, r, s, o, a) {
        const c = Math.cos(s)
          , f = Math.sin(s);
        return this.set(i * c, i * f, -i * (c * o + f * a) + o + e, -r * f, r * c, -r * (-f * o + c * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(n0.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(n0.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(n0.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 9; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 9; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const n0 = new mt;
function sC(n) {
    for (let e = n.length - 1; e >= 0; --e)
        if (n[e] >= 65535)
            return !0;
    return !1
}
const $L = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};
function bl(n, e) {
    return new $L[n](e)
}
function ef(n) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}
function oC() {
    const n = ef("canvas");
    return n.style.display = "block",
    n
}
const mM = {};
function aC(n) {
    n in mM || (mM[n] = !0,
    console.warn(n))
}
const gM = new mt().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
  , vM = new mt().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
  , zh = {
    [Cs]: {
        transfer: Zc,
        primaries: Jc,
        toReference: n=>n,
        fromReference: n=>n
    },
    [Fi]: {
        transfer: Bt,
        primaries: Jc,
        toReference: n=>n.convertSRGBToLinear(),
        fromReference: n=>n.convertLinearToSRGB()
    },
    [gf]: {
        transfer: Zc,
        primaries: Kc,
        toReference: n=>n.applyMatrix3(vM),
        fromReference: n=>n.applyMatrix3(gM)
    },
    [em]: {
        transfer: Bt,
        primaries: Kc,
        toReference: n=>n.convertSRGBToLinear().applyMatrix3(vM),
        fromReference: n=>n.applyMatrix3(gM).convertLinearToSRGB()
    }
}
  , eI = new Set([Cs, gf])
  , Ut = {
    enabled: !0,
    _workingColorSpace: Cs,
    get workingColorSpace() {
        return this._workingColorSpace
    },
    set workingColorSpace(n) {
        if (!eI.has(n))
            throw new Error(`Unsupported working color space, "${n}".`);
        this._workingColorSpace = n
    },
    convert: function(n, e, t) {
        if (this.enabled === !1 || e === t || !e || !t)
            return n;
        const i = zh[e].toReference
          , r = zh[t].fromReference;
        return r(i(n))
    },
    fromWorkingColorSpace: function(n, e) {
        return this.convert(n, this._workingColorSpace, e)
    },
    toWorkingColorSpace: function(n, e) {
        return this.convert(n, e, this._workingColorSpace)
    },
    getPrimaries: function(n) {
        return zh[n].primaries
    },
    getTransfer: function(n) {
        return n === ds ? Zc : zh[n].transfer
    }
};
function Hl(n) {
    return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}
function i0(n) {
    return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
let Wa;
class X_ {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            Wa === void 0 && (Wa = ef("canvas")),
            Wa.width = e.width,
            Wa.height = e.height;
            const i = Wa.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
            t = Wa
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = ef("canvas");
            t.width = e.width,
            t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const r = i.getImageData(0, 0, e.width, e.height)
              , s = r.data;
            for (let o = 0; o < s.length; o++)
                s[o] = Hl(s[o] / 255) * 255;
            return i.putImageData(r, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(Hl(t[i] / 255) * 255) : t[i] = Hl(t[i]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let tI = 0;
class ia {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: tI++
        }),
        this.uuid = Hi(),
        this.data = e,
        this.dataReady = !0,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const i = {
            uuid: this.uuid,
            url: ""
        }
          , r = this.data;
        if (r !== null) {
            let s;
            if (Array.isArray(r)) {
                s = [];
                for (let o = 0, a = r.length; o < a; o++)
                    r[o].isDataTexture ? s.push(r0(r[o].image)) : s.push(r0(r[o]))
            } else
                s = r0(r);
            i.url = s
        }
        return t || (e.images[this.uuid] = i),
        i
    }
}
function r0(n) {
    return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? X_.getDataURL(n) : n.data ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let nI = 0;
class en extends Rs {
    constructor(e=en.DEFAULT_IMAGE, t=en.DEFAULT_MAPPING, i=ei, r=ei, s=Wt, o=Gr, a=ci, c=jr, f=en.DEFAULT_ANISOTROPY, h=ds) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: nI++
        }),
        this.uuid = Hi(),
        this.name = "",
        this.source = new ia(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = i,
        this.wrapT = r,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = f,
        this.format = a,
        this.internalFormat = null,
        this.type = c,
        this.offset = new he(0,0),
        this.repeat = new he(1,1),
        this.center = new he(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new mt,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.colorSpace = h,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const i = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        t || (e.textures[this.uuid] = i),
        i
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== Kp)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case Wc:
                e.x = e.x - Math.floor(e.x);
                break;
            case ei:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case Xc:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case Wc:
                e.y = e.y - Math.floor(e.y);
                break;
            case ei:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case Xc:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
}
en.DEFAULT_IMAGE = null;
en.DEFAULT_MAPPING = Kp;
en.DEFAULT_ANISOTROPY = 1;
class Ct {
    constructor(e=0, t=0, i=0, r=1) {
        Ct.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = i,
        this.w = r
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, i, r) {
        return this.x = e,
        this.y = t,
        this.z = i,
        this.w = r,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s,
        this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s,
        this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s,
        this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, i, r, s;
        const c = e.elements
          , f = c[0]
          , h = c[4]
          , d = c[8]
          , m = c[1]
          , v = c[5]
          , _ = c[9]
          , w = c[2]
          , x = c[6]
          , g = c[10];
        if (Math.abs(h - m) < .01 && Math.abs(d - w) < .01 && Math.abs(_ - x) < .01) {
            if (Math.abs(h + m) < .1 && Math.abs(d + w) < .1 && Math.abs(_ + x) < .1 && Math.abs(f + v + g - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const M = (f + 1) / 2
              , T = (v + 1) / 2
              , P = (g + 1) / 2
              , R = (h + m) / 4
              , b = (d + w) / 4
              , N = (_ + x) / 4;
            return M > T && M > P ? M < .01 ? (i = 0,
            r = .707106781,
            s = .707106781) : (i = Math.sqrt(M),
            r = R / i,
            s = b / i) : T > P ? T < .01 ? (i = .707106781,
            r = 0,
            s = .707106781) : (r = Math.sqrt(T),
            i = R / r,
            s = N / r) : P < .01 ? (i = .707106781,
            r = .707106781,
            s = 0) : (s = Math.sqrt(P),
            i = b / s,
            r = N / s),
            this.set(i, r, s, t),
            this
        }
        let S = Math.sqrt((x - _) * (x - _) + (d - w) * (d - w) + (m - h) * (m - h));
        return Math.abs(S) < .001 && (S = 1),
        this.x = (x - _) / S,
        this.y = (d - w) / S,
        this.z = (m - h) / S,
        this.w = Math.acos((f + v + g - 1) / 2),
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this.w = e.w + (t.w - e.w) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class lC extends Rs {
    constructor(e=1, t=1, i={}) {
        super(),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new Ct(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Ct(0,0,e,t);
        const r = {
            width: e,
            height: t,
            depth: 1
        };
        i = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: Wt,
            depthBuffer: !0,
            stencilBuffer: !1,
            depthTexture: null,
            samples: 0,
            count: 1
        }, i);
        const s = new en(r,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace);
        s.flipY = !1,
        s.generateMipmaps = i.generateMipmaps,
        s.internalFormat = i.internalFormat,
        this.textures = [];
        const o = i.count;
        for (let a = 0; a < o; a++)
            this.textures[a] = s.clone(),
            this.textures[a].isRenderTargetTexture = !0;
        this.depthBuffer = i.depthBuffer,
        this.stencilBuffer = i.stencilBuffer,
        this.depthTexture = i.depthTexture,
        this.samples = i.samples
    }
    get texture() {
        return this.textures[0]
    }
    set texture(e) {
        this.textures[0] = e
    }
    setSize(e, t, i=1) {
        if (this.width !== e || this.height !== t || this.depth !== i) {
            this.width = e,
            this.height = t,
            this.depth = i;
            for (let r = 0, s = this.textures.length; r < s; r++)
                this.textures[r].image.width = e,
                this.textures[r].image.height = t,
                this.textures[r].image.depth = i;
            this.dispose()
        }
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.textures.length = 0;
        for (let i = 0, r = e.textures.length; i < r; i++)
            this.textures[i] = e.textures[i].clone(),
            this.textures[i].isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new ia(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class cr extends lC {
    constructor(e=1, t=1, i={}) {
        super(e, t, i),
        this.isWebGLRenderTarget = !0
    }
}
class tm extends en {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = hn,
        this.minFilter = hn,
        this.wrapR = ei,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class iI extends cr {
    constructor(e=1, t=1, i=1, r={}) {
        super(e, t, r),
        this.isWebGLArrayRenderTarget = !0,
        this.depth = i,
        this.texture = new tm(null,e,t,i),
        this.texture.isRenderTargetTexture = !0
    }
}
class Y_ extends en {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = hn,
        this.minFilter = hn,
        this.wrapR = ei,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class rI extends cr {
    constructor(e=1, t=1, i=1, r={}) {
        super(e, t, r),
        this.isWebGL3DRenderTarget = !0,
        this.depth = i,
        this.texture = new Y_(null,e,t,i),
        this.texture.isRenderTargetTexture = !0
    }
}
class En {
    constructor(e=0, t=0, i=0, r=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._w = r
    }
    static slerpFlat(e, t, i, r, s, o, a) {
        let c = i[r + 0]
          , f = i[r + 1]
          , h = i[r + 2]
          , d = i[r + 3];
        const m = s[o + 0]
          , v = s[o + 1]
          , _ = s[o + 2]
          , w = s[o + 3];
        if (a === 0) {
            e[t + 0] = c,
            e[t + 1] = f,
            e[t + 2] = h,
            e[t + 3] = d;
            return
        }
        if (a === 1) {
            e[t + 0] = m,
            e[t + 1] = v,
            e[t + 2] = _,
            e[t + 3] = w;
            return
        }
        if (d !== w || c !== m || f !== v || h !== _) {
            let x = 1 - a;
            const g = c * m + f * v + h * _ + d * w
              , S = g >= 0 ? 1 : -1
              , M = 1 - g * g;
            if (M > Number.EPSILON) {
                const P = Math.sqrt(M)
                  , R = Math.atan2(P, g * S);
                x = Math.sin(x * R) / P,
                a = Math.sin(a * R) / P
            }
            const T = a * S;
            if (c = c * x + m * T,
            f = f * x + v * T,
            h = h * x + _ * T,
            d = d * x + w * T,
            x === 1 - a) {
                const P = 1 / Math.sqrt(c * c + f * f + h * h + d * d);
                c *= P,
                f *= P,
                h *= P,
                d *= P
            }
        }
        e[t] = c,
        e[t + 1] = f,
        e[t + 2] = h,
        e[t + 3] = d
    }
    static multiplyQuaternionsFlat(e, t, i, r, s, o) {
        const a = i[r]
          , c = i[r + 1]
          , f = i[r + 2]
          , h = i[r + 3]
          , d = s[o]
          , m = s[o + 1]
          , v = s[o + 2]
          , _ = s[o + 3];
        return e[t] = a * _ + h * d + c * v - f * m,
        e[t + 1] = c * _ + h * m + f * d - a * v,
        e[t + 2] = f * _ + h * v + a * m - c * d,
        e[t + 3] = h * _ - a * d - c * m - f * v,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, i, r) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._w = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t=!0) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._order
          , a = Math.cos
          , c = Math.sin
          , f = a(i / 2)
          , h = a(r / 2)
          , d = a(s / 2)
          , m = c(i / 2)
          , v = c(r / 2)
          , _ = c(s / 2);
        switch (o) {
        case "XYZ":
            this._x = m * h * d + f * v * _,
            this._y = f * v * d - m * h * _,
            this._z = f * h * _ + m * v * d,
            this._w = f * h * d - m * v * _;
            break;
        case "YXZ":
            this._x = m * h * d + f * v * _,
            this._y = f * v * d - m * h * _,
            this._z = f * h * _ - m * v * d,
            this._w = f * h * d + m * v * _;
            break;
        case "ZXY":
            this._x = m * h * d - f * v * _,
            this._y = f * v * d + m * h * _,
            this._z = f * h * _ + m * v * d,
            this._w = f * h * d - m * v * _;
            break;
        case "ZYX":
            this._x = m * h * d - f * v * _,
            this._y = f * v * d + m * h * _,
            this._z = f * h * _ - m * v * d,
            this._w = f * h * d + m * v * _;
            break;
        case "YZX":
            this._x = m * h * d + f * v * _,
            this._y = f * v * d + m * h * _,
            this._z = f * h * _ - m * v * d,
            this._w = f * h * d - m * v * _;
            break;
        case "XZY":
            this._x = m * h * d - f * v * _,
            this._y = f * v * d - m * h * _,
            this._z = f * h * _ + m * v * d,
            this._w = f * h * d + m * v * _;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t === !0 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const i = t / 2
          , r = Math.sin(i);
        return this._x = e.x * r,
        this._y = e.y * r,
        this._z = e.z * r,
        this._w = Math.cos(i),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , i = t[0]
          , r = t[4]
          , s = t[8]
          , o = t[1]
          , a = t[5]
          , c = t[9]
          , f = t[2]
          , h = t[6]
          , d = t[10]
          , m = i + a + d;
        if (m > 0) {
            const v = .5 / Math.sqrt(m + 1);
            this._w = .25 / v,
            this._x = (h - c) * v,
            this._y = (s - f) * v,
            this._z = (o - r) * v
        } else if (i > a && i > d) {
            const v = 2 * Math.sqrt(1 + i - a - d);
            this._w = (h - c) / v,
            this._x = .25 * v,
            this._y = (r + o) / v,
            this._z = (s + f) / v
        } else if (a > d) {
            const v = 2 * Math.sqrt(1 + a - i - d);
            this._w = (s - f) / v,
            this._x = (r + o) / v,
            this._y = .25 * v,
            this._z = (c + h) / v
        } else {
            const v = 2 * Math.sqrt(1 + d - i - a);
            this._w = (o - r) / v,
            this._x = (s + f) / v,
            this._y = (c + h) / v,
            this._z = .25 * v
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return i < Number.EPSILON ? (i = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = i) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = i)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = i),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(ln(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (i === 0)
            return this;
        const r = Math.min(1, t / i);
        return this.slerp(e, r),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._w
          , a = t._x
          , c = t._y
          , f = t._z
          , h = t._w;
        return this._x = i * h + o * a + r * f - s * c,
        this._y = r * h + o * c + s * a - i * f,
        this._z = s * h + o * f + i * c - r * a,
        this._w = o * h - i * a - r * c - s * f,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const i = this._x
          , r = this._y
          , s = this._z
          , o = this._w;
        let a = o * e._w + i * e._x + r * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = i,
            this._y = r,
            this._z = s,
            this;
        const c = 1 - a * a;
        if (c <= Number.EPSILON) {
            const v = 1 - t;
            return this._w = v * o + t * this._w,
            this._x = v * i + t * this._x,
            this._y = v * r + t * this._y,
            this._z = v * s + t * this._z,
            this.normalize(),
            this
        }
        const f = Math.sqrt(c)
          , h = Math.atan2(f, a)
          , d = Math.sin((1 - t) * h) / f
          , m = Math.sin(t * h) / f;
        return this._w = o * d + this._w * m,
        this._x = i * d + this._x * m,
        this._y = r * d + this._y * m,
        this._z = s * d + this._z * m,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i)
    }
    random() {
        const e = 2 * Math.PI * Math.random()
          , t = 2 * Math.PI * Math.random()
          , i = Math.random()
          , r = Math.sqrt(1 - i)
          , s = Math.sqrt(i);
        return this.set(r * Math.sin(e), r * Math.cos(e), s * Math.sin(t), s * Math.cos(t))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this._onChangeCallback(),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class U {
    constructor(e=0, t=0, i=0) {
        U.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = i
    }
    set(e, t, i) {
        return i === void 0 && (i = this.z),
        this.x = e,
        this.y = t,
        this.z = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(yM.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(yM.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[3] * i + s[6] * r,
        this.y = s[1] * t + s[4] * i + s[7] * r,
        this.z = s[2] * t + s[5] * i + s[8] * r,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements
          , o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
        return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o,
        this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o,
        this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.x
          , o = e.y
          , a = e.z
          , c = e.w
          , f = 2 * (o * r - a * i)
          , h = 2 * (a * t - s * r)
          , d = 2 * (s * i - o * t);
        return this.x = t + c * f + o * d - a * h,
        this.y = i + c * h + a * f - s * d,
        this.z = r + c * d + s * h - o * f,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[4] * i + s[8] * r,
        this.y = s[1] * t + s[5] * i + s[9] * r,
        this.z = s[2] * t + s[6] * i + s[10] * r,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = t.x
          , a = t.y
          , c = t.z;
        return this.x = r * c - s * a,
        this.y = s * o - i * c,
        this.z = i * a - r * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i)
    }
    projectOnPlane(e) {
        return s0.copy(this).projectOnVector(e),
        this.sub(s0)
    }
    reflect(e) {
        return this.sub(s0.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(ln(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y
          , r = this.z - e.z;
        return t * t + i * i + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, i) {
        const r = Math.sin(t) * e;
        return this.x = r * Math.sin(i),
        this.y = Math.cos(t) * e,
        this.z = r * Math.cos(i),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, i) {
        return this.x = e * Math.sin(t),
        this.y = i,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , i = this.setFromMatrixColumn(e, 1).length()
          , r = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = i,
        this.z = r,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2
          , t = Math.random() * 2 - 1
          , i = Math.sqrt(1 - t * t);
        return this.x = i * Math.cos(e),
        this.y = t,
        this.z = i * Math.sin(e),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const s0 = new U
  , yM = new En;
class di {
    constructor(e=new U(1 / 0,1 / 0,1 / 0), t=new U(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t += 3)
            this.expandByPoint(mr.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, i = e.count; t < i; t++)
            this.expandByPoint(mr.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = mr.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const i = e.geometry;
        if (i !== void 0) {
            const s = i.getAttribute("position");
            if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = s.count; o < a; o++)
                    e.isMesh === !0 ? e.getVertexPosition(o, mr) : mr.fromBufferAttribute(s, o),
                    mr.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(mr);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                Bh.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(),
                Bh.copy(i.boundingBox)),
                Bh.applyMatrix4(e.matrixWorld),
                this.union(Bh)
        }
        const r = e.children;
        for (let s = 0, o = r.length; s < o; s++)
            this.expandByObject(r[s], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, mr),
        mr.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, i;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        i = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        i += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        i += e.normal.z * this.min.z),
        t <= -e.constant && i >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(zu),
        Hh.subVectors(this.max, zu),
        Xa.subVectors(e.a, zu),
        Ya.subVectors(e.b, zu),
        ja.subVectors(e.c, zu),
        zs.subVectors(Ya, Xa),
        Bs.subVectors(ja, Ya),
        No.subVectors(Xa, ja);
        let t = [0, -zs.z, zs.y, 0, -Bs.z, Bs.y, 0, -No.z, No.y, zs.z, 0, -zs.x, Bs.z, 0, -Bs.x, No.z, 0, -No.x, -zs.y, zs.x, 0, -Bs.y, Bs.x, 0, -No.y, No.x, 0];
        return !o0(t, Xa, Ya, ja, Hh) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !o0(t, Xa, Ya, ja, Hh)) ? !1 : (Vh.crossVectors(zs, Bs),
        t = [Vh.x, Vh.y, Vh.z],
        o0(t, Xa, Ya, ja, Hh))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, mr).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(mr).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (rs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        rs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        rs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        rs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        rs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        rs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        rs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        rs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(rs),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const rs = [new U, new U, new U, new U, new U, new U, new U, new U]
  , mr = new U
  , Bh = new di
  , Xa = new U
  , Ya = new U
  , ja = new U
  , zs = new U
  , Bs = new U
  , No = new U
  , zu = new U
  , Hh = new U
  , Vh = new U
  , Do = new U;
function o0(n, e, t, i, r) {
    for (let s = 0, o = n.length - 3; s <= o; s += 3) {
        Do.fromArray(n, s);
        const a = r.x * Math.abs(Do.x) + r.y * Math.abs(Do.y) + r.z * Math.abs(Do.z)
          , c = e.dot(Do)
          , f = t.dot(Do)
          , h = i.dot(Do);
        if (Math.max(-Math.max(c, f, h), Math.min(c, f, h)) > a)
            return !1
    }
    return !0
}
const sI = new di
  , Bu = new U
  , a0 = new U;
class ni {
    constructor(e=new U, t=-1) {
        this.isSphere = !0,
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const i = this.center;
        t !== void 0 ? i.copy(t) : sI.setFromPoints(e).getCenter(i);
        let r = 0;
        for (let s = 0, o = e.length; s < o; s++)
            r = Math.max(r, i.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(r),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return t.copy(e),
        i > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        Bu.subVectors(e, this.center);
        const t = Bu.lengthSq();
        if (t > this.radius * this.radius) {
            const i = Math.sqrt(t)
              , r = (i - this.radius) * .5;
            this.center.addScaledVector(Bu, r / i),
            this.radius += r
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (a0.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(Bu.copy(e.center).add(a0)),
        this.expandByPoint(Bu.copy(e.center).sub(a0))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const ss = new U
  , l0 = new U
  , Gh = new U
  , Hs = new U
  , u0 = new U
  , Wh = new U
  , c0 = new U;
class su {
    constructor(e=new U, t=new U(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, ss)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = ss.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (ss.copy(this.origin).addScaledVector(this.direction, t),
        ss.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, i, r) {
        l0.copy(e).add(t).multiplyScalar(.5),
        Gh.copy(t).sub(e).normalize(),
        Hs.copy(this.origin).sub(l0);
        const s = e.distanceTo(t) * .5
          , o = -this.direction.dot(Gh)
          , a = Hs.dot(this.direction)
          , c = -Hs.dot(Gh)
          , f = Hs.lengthSq()
          , h = Math.abs(1 - o * o);
        let d, m, v, _;
        if (h > 0)
            if (d = o * c - a,
            m = o * a - c,
            _ = s * h,
            d >= 0)
                if (m >= -_)
                    if (m <= _) {
                        const w = 1 / h;
                        d *= w,
                        m *= w,
                        v = d * (d + o * m + 2 * a) + m * (o * d + m + 2 * c) + f
                    } else
                        m = s,
                        d = Math.max(0, -(o * m + a)),
                        v = -d * d + m * (m + 2 * c) + f;
                else
                    m = -s,
                    d = Math.max(0, -(o * m + a)),
                    v = -d * d + m * (m + 2 * c) + f;
            else
                m <= -_ ? (d = Math.max(0, -(-o * s + a)),
                m = d > 0 ? -s : Math.min(Math.max(-s, -c), s),
                v = -d * d + m * (m + 2 * c) + f) : m <= _ ? (d = 0,
                m = Math.min(Math.max(-s, -c), s),
                v = m * (m + 2 * c) + f) : (d = Math.max(0, -(o * s + a)),
                m = d > 0 ? s : Math.min(Math.max(-s, -c), s),
                v = -d * d + m * (m + 2 * c) + f);
        else
            m = o > 0 ? -s : s,
            d = Math.max(0, -(o * m + a)),
            v = -d * d + m * (m + 2 * c) + f;
        return i && i.copy(this.origin).addScaledVector(this.direction, d),
        r && r.copy(l0).addScaledVector(Gh, m),
        v
    }
    intersectSphere(e, t) {
        ss.subVectors(e.center, this.origin);
        const i = ss.dot(this.direction)
          , r = ss.dot(ss) - i * i
          , s = e.radius * e.radius;
        if (r > s)
            return null;
        const o = Math.sqrt(s - r)
          , a = i - o
          , c = i + o;
        return c < 0 ? null : a < 0 ? this.at(c, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null
    }
    intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let i, r, s, o, a, c;
        const f = 1 / this.direction.x
          , h = 1 / this.direction.y
          , d = 1 / this.direction.z
          , m = this.origin;
        return f >= 0 ? (i = (e.min.x - m.x) * f,
        r = (e.max.x - m.x) * f) : (i = (e.max.x - m.x) * f,
        r = (e.min.x - m.x) * f),
        h >= 0 ? (s = (e.min.y - m.y) * h,
        o = (e.max.y - m.y) * h) : (s = (e.max.y - m.y) * h,
        o = (e.min.y - m.y) * h),
        i > o || s > r || ((s > i || isNaN(i)) && (i = s),
        (o < r || isNaN(r)) && (r = o),
        d >= 0 ? (a = (e.min.z - m.z) * d,
        c = (e.max.z - m.z) * d) : (a = (e.max.z - m.z) * d,
        c = (e.min.z - m.z) * d),
        i > c || a > r) || ((a > i || i !== i) && (i = a),
        (c < r || r !== r) && (r = c),
        r < 0) ? null : this.at(i >= 0 ? i : r, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, ss) !== null
    }
    intersectTriangle(e, t, i, r, s) {
        u0.subVectors(t, e),
        Wh.subVectors(i, e),
        c0.crossVectors(u0, Wh);
        let o = this.direction.dot(c0), a;
        if (o > 0) {
            if (r)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        Hs.subVectors(this.origin, e);
        const c = a * this.direction.dot(Wh.crossVectors(Hs, Wh));
        if (c < 0)
            return null;
        const f = a * this.direction.dot(u0.cross(Hs));
        if (f < 0 || c + f > o)
            return null;
        const h = -a * Hs.dot(c0);
        return h < 0 ? null : this.at(h / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class $e {
    constructor(e, t, i, r, s, o, a, c, f, h, d, m, v, _, w, x) {
        $e.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, i, r, s, o, a, c, f, h, d, m, v, _, w, x)
    }
    set(e, t, i, r, s, o, a, c, f, h, d, m, v, _, w, x) {
        const g = this.elements;
        return g[0] = e,
        g[4] = t,
        g[8] = i,
        g[12] = r,
        g[1] = s,
        g[5] = o,
        g[9] = a,
        g[13] = c,
        g[2] = f,
        g[6] = h,
        g[10] = d,
        g[14] = m,
        g[3] = v,
        g[7] = _,
        g[11] = w,
        g[15] = x,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new $e().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t[9] = i[9],
        t[10] = i[10],
        t[11] = i[11],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , i = e.elements;
        return t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        i.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , i = e.elements
          , r = 1 / qa.setFromMatrixColumn(e, 0).length()
          , s = 1 / qa.setFromMatrixColumn(e, 1).length()
          , o = 1 / qa.setFromMatrixColumn(e, 2).length();
        return t[0] = i[0] * r,
        t[1] = i[1] * r,
        t[2] = i[2] * r,
        t[3] = 0,
        t[4] = i[4] * s,
        t[5] = i[5] * s,
        t[6] = i[6] * s,
        t[7] = 0,
        t[8] = i[8] * o,
        t[9] = i[9] * o,
        t[10] = i[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z
          , o = Math.cos(i)
          , a = Math.sin(i)
          , c = Math.cos(r)
          , f = Math.sin(r)
          , h = Math.cos(s)
          , d = Math.sin(s);
        if (e.order === "XYZ") {
            const m = o * h
              , v = o * d
              , _ = a * h
              , w = a * d;
            t[0] = c * h,
            t[4] = -c * d,
            t[8] = f,
            t[1] = v + _ * f,
            t[5] = m - w * f,
            t[9] = -a * c,
            t[2] = w - m * f,
            t[6] = _ + v * f,
            t[10] = o * c
        } else if (e.order === "YXZ") {
            const m = c * h
              , v = c * d
              , _ = f * h
              , w = f * d;
            t[0] = m + w * a,
            t[4] = _ * a - v,
            t[8] = o * f,
            t[1] = o * d,
            t[5] = o * h,
            t[9] = -a,
            t[2] = v * a - _,
            t[6] = w + m * a,
            t[10] = o * c
        } else if (e.order === "ZXY") {
            const m = c * h
              , v = c * d
              , _ = f * h
              , w = f * d;
            t[0] = m - w * a,
            t[4] = -o * d,
            t[8] = _ + v * a,
            t[1] = v + _ * a,
            t[5] = o * h,
            t[9] = w - m * a,
            t[2] = -o * f,
            t[6] = a,
            t[10] = o * c
        } else if (e.order === "ZYX") {
            const m = o * h
              , v = o * d
              , _ = a * h
              , w = a * d;
            t[0] = c * h,
            t[4] = _ * f - v,
            t[8] = m * f + w,
            t[1] = c * d,
            t[5] = w * f + m,
            t[9] = v * f - _,
            t[2] = -f,
            t[6] = a * c,
            t[10] = o * c
        } else if (e.order === "YZX") {
            const m = o * c
              , v = o * f
              , _ = a * c
              , w = a * f;
            t[0] = c * h,
            t[4] = w - m * d,
            t[8] = _ * d + v,
            t[1] = d,
            t[5] = o * h,
            t[9] = -a * h,
            t[2] = -f * h,
            t[6] = v * d + _,
            t[10] = m - w * d
        } else if (e.order === "XZY") {
            const m = o * c
              , v = o * f
              , _ = a * c
              , w = a * f;
            t[0] = c * h,
            t[4] = -d,
            t[8] = f * h,
            t[1] = m * d + w,
            t[5] = o * h,
            t[9] = v * d - _,
            t[2] = _ * d - v,
            t[6] = a * h,
            t[10] = w * d + m
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(oI, e, aI)
    }
    lookAt(e, t, i) {
        const r = this.elements;
        return Di.subVectors(e, t),
        Di.lengthSq() === 0 && (Di.z = 1),
        Di.normalize(),
        Vs.crossVectors(i, Di),
        Vs.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Di.x += 1e-4 : Di.z += 1e-4,
        Di.normalize(),
        Vs.crossVectors(i, Di)),
        Vs.normalize(),
        Xh.crossVectors(Di, Vs),
        r[0] = Vs.x,
        r[4] = Xh.x,
        r[8] = Di.x,
        r[1] = Vs.y,
        r[5] = Xh.y,
        r[9] = Di.y,
        r[2] = Vs.z,
        r[6] = Xh.z,
        r[10] = Di.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , a = i[4]
          , c = i[8]
          , f = i[12]
          , h = i[1]
          , d = i[5]
          , m = i[9]
          , v = i[13]
          , _ = i[2]
          , w = i[6]
          , x = i[10]
          , g = i[14]
          , S = i[3]
          , M = i[7]
          , T = i[11]
          , P = i[15]
          , R = r[0]
          , b = r[4]
          , N = r[8]
          , G = r[12]
          , C = r[1]
          , I = r[5]
          , K = r[9]
          , se = r[13]
          , B = r[2]
          , ie = r[6]
          , J = r[10]
          , ue = r[14]
          , F = r[3]
          , H = r[7]
          , V = r[11]
          , q = r[15];
        return s[0] = o * R + a * C + c * B + f * F,
        s[4] = o * b + a * I + c * ie + f * H,
        s[8] = o * N + a * K + c * J + f * V,
        s[12] = o * G + a * se + c * ue + f * q,
        s[1] = h * R + d * C + m * B + v * F,
        s[5] = h * b + d * I + m * ie + v * H,
        s[9] = h * N + d * K + m * J + v * V,
        s[13] = h * G + d * se + m * ue + v * q,
        s[2] = _ * R + w * C + x * B + g * F,
        s[6] = _ * b + w * I + x * ie + g * H,
        s[10] = _ * N + w * K + x * J + g * V,
        s[14] = _ * G + w * se + x * ue + g * q,
        s[3] = S * R + M * C + T * B + P * F,
        s[7] = S * b + M * I + T * ie + P * H,
        s[11] = S * N + M * K + T * J + P * V,
        s[15] = S * G + M * se + T * ue + P * q,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[4]
          , r = e[8]
          , s = e[12]
          , o = e[1]
          , a = e[5]
          , c = e[9]
          , f = e[13]
          , h = e[2]
          , d = e[6]
          , m = e[10]
          , v = e[14]
          , _ = e[3]
          , w = e[7]
          , x = e[11]
          , g = e[15];
        return _ * (+s * c * d - r * f * d - s * a * m + i * f * m + r * a * v - i * c * v) + w * (+t * c * v - t * f * m + s * o * m - r * o * v + r * f * h - s * c * h) + x * (+t * f * d - t * a * v - s * o * d + i * o * v + s * a * h - i * f * h) + g * (-r * a * h - t * c * d + t * a * m + r * o * d - i * o * m + i * c * h)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, i) {
        const r = this.elements;
        return e.isVector3 ? (r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z) : (r[12] = e,
        r[13] = t,
        r[14] = i),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , c = e[6]
          , f = e[7]
          , h = e[8]
          , d = e[9]
          , m = e[10]
          , v = e[11]
          , _ = e[12]
          , w = e[13]
          , x = e[14]
          , g = e[15]
          , S = d * x * f - w * m * f + w * c * v - a * x * v - d * c * g + a * m * g
          , M = _ * m * f - h * x * f - _ * c * v + o * x * v + h * c * g - o * m * g
          , T = h * w * f - _ * d * f + _ * a * v - o * w * v - h * a * g + o * d * g
          , P = _ * d * c - h * w * c - _ * a * m + o * w * m + h * a * x - o * d * x
          , R = t * S + i * M + r * T + s * P;
        if (R === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const b = 1 / R;
        return e[0] = S * b,
        e[1] = (w * m * s - d * x * s - w * r * v + i * x * v + d * r * g - i * m * g) * b,
        e[2] = (a * x * s - w * c * s + w * r * f - i * x * f - a * r * g + i * c * g) * b,
        e[3] = (d * c * s - a * m * s - d * r * f + i * m * f + a * r * v - i * c * v) * b,
        e[4] = M * b,
        e[5] = (h * x * s - _ * m * s + _ * r * v - t * x * v - h * r * g + t * m * g) * b,
        e[6] = (_ * c * s - o * x * s - _ * r * f + t * x * f + o * r * g - t * c * g) * b,
        e[7] = (o * m * s - h * c * s + h * r * f - t * m * f - o * r * v + t * c * v) * b,
        e[8] = T * b,
        e[9] = (_ * d * s - h * w * s - _ * i * v + t * w * v + h * i * g - t * d * g) * b,
        e[10] = (o * w * s - _ * a * s + _ * i * f - t * w * f - o * i * g + t * a * g) * b,
        e[11] = (h * a * s - o * d * s - h * i * f + t * d * f + o * i * v - t * a * v) * b,
        e[12] = P * b,
        e[13] = (h * w * r - _ * d * r + _ * i * m - t * w * m - h * i * x + t * d * x) * b,
        e[14] = (_ * a * r - o * w * r - _ * i * c + t * w * c + o * i * x - t * a * x) * b,
        e[15] = (o * d * r - h * a * r + h * i * c - t * d * c - o * i * m + t * a * m) * b,
        this
    }
    scale(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z;
        return t[0] *= i,
        t[4] *= r,
        t[8] *= s,
        t[1] *= i,
        t[5] *= r,
        t[9] *= s,
        t[2] *= i,
        t[6] *= r,
        t[10] *= s,
        t[3] *= i,
        t[7] *= r,
        t[11] *= s,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, r))
    }
    makeTranslation(e, t, i) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = 1 - i
          , o = e.x
          , a = e.y
          , c = e.z
          , f = s * o
          , h = s * a;
        return this.set(f * o + i, f * a - r * c, f * c + r * a, 0, f * a + r * c, h * a + i, h * c - r * o, 0, f * c - r * a, h * c + r * o, s * c * c + i, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, i, r, s, o) {
        return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, i) {
        const r = this.elements
          , s = t._x
          , o = t._y
          , a = t._z
          , c = t._w
          , f = s + s
          , h = o + o
          , d = a + a
          , m = s * f
          , v = s * h
          , _ = s * d
          , w = o * h
          , x = o * d
          , g = a * d
          , S = c * f
          , M = c * h
          , T = c * d
          , P = i.x
          , R = i.y
          , b = i.z;
        return r[0] = (1 - (w + g)) * P,
        r[1] = (v + T) * P,
        r[2] = (_ - M) * P,
        r[3] = 0,
        r[4] = (v - T) * R,
        r[5] = (1 - (m + g)) * R,
        r[6] = (x + S) * R,
        r[7] = 0,
        r[8] = (_ + M) * b,
        r[9] = (x - S) * b,
        r[10] = (1 - (m + w)) * b,
        r[11] = 0,
        r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z,
        r[15] = 1,
        this
    }
    decompose(e, t, i) {
        const r = this.elements;
        let s = qa.set(r[0], r[1], r[2]).length();
        const o = qa.set(r[4], r[5], r[6]).length()
          , a = qa.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s),
        e.x = r[12],
        e.y = r[13],
        e.z = r[14],
        gr.copy(this);
        const f = 1 / s
          , h = 1 / o
          , d = 1 / a;
        return gr.elements[0] *= f,
        gr.elements[1] *= f,
        gr.elements[2] *= f,
        gr.elements[4] *= h,
        gr.elements[5] *= h,
        gr.elements[6] *= h,
        gr.elements[8] *= d,
        gr.elements[9] *= d,
        gr.elements[10] *= d,
        t.setFromRotationMatrix(gr),
        i.x = s,
        i.y = o,
        i.z = a,
        this
    }
    makePerspective(e, t, i, r, s, o, a=Wr) {
        const c = this.elements
          , f = 2 * s / (t - e)
          , h = 2 * s / (i - r)
          , d = (t + e) / (t - e)
          , m = (i + r) / (i - r);
        let v, _;
        if (a === Wr)
            v = -(o + s) / (o - s),
            _ = -2 * o * s / (o - s);
        else if (a === $c)
            v = -o / (o - s),
            _ = -o * s / (o - s);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return c[0] = f,
        c[4] = 0,
        c[8] = d,
        c[12] = 0,
        c[1] = 0,
        c[5] = h,
        c[9] = m,
        c[13] = 0,
        c[2] = 0,
        c[6] = 0,
        c[10] = v,
        c[14] = _,
        c[3] = 0,
        c[7] = 0,
        c[11] = -1,
        c[15] = 0,
        this
    }
    makeOrthographic(e, t, i, r, s, o, a=Wr) {
        const c = this.elements
          , f = 1 / (t - e)
          , h = 1 / (i - r)
          , d = 1 / (o - s)
          , m = (t + e) * f
          , v = (i + r) * h;
        let _, w;
        if (a === Wr)
            _ = (o + s) * d,
            w = -2 * d;
        else if (a === $c)
            _ = s * d,
            w = -1 * d;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return c[0] = 2 * f,
        c[4] = 0,
        c[8] = 0,
        c[12] = -m,
        c[1] = 0,
        c[5] = 2 * h,
        c[9] = 0,
        c[13] = -v,
        c[2] = 0,
        c[6] = 0,
        c[10] = w,
        c[14] = -_,
        c[3] = 0,
        c[7] = 0,
        c[11] = 0,
        c[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 16; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 16; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e[t + 9] = i[9],
        e[t + 10] = i[10],
        e[t + 11] = i[11],
        e[t + 12] = i[12],
        e[t + 13] = i[13],
        e[t + 14] = i[14],
        e[t + 15] = i[15],
        e
    }
}
const qa = new U
  , gr = new $e
  , oI = new U(0,0,0)
  , aI = new U(1,1,1)
  , Vs = new U
  , Xh = new U
  , Di = new U
  , _M = new $e
  , xM = new En;
class Ri {
    constructor(e=0, t=0, i=0, r=Ri.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._order = r
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, i, r=this._order) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._order = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, i=!0) {
        const r = e.elements
          , s = r[0]
          , o = r[4]
          , a = r[8]
          , c = r[1]
          , f = r[5]
          , h = r[9]
          , d = r[2]
          , m = r[6]
          , v = r[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(ln(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, v),
            this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(m, f),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-ln(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, v),
            this._z = Math.atan2(c, f)) : (this._y = Math.atan2(-d, s),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(ln(m, -1, 1)),
            Math.abs(m) < .9999999 ? (this._y = Math.atan2(-d, v),
            this._z = Math.atan2(-o, f)) : (this._y = 0,
            this._z = Math.atan2(c, s));
            break;
        case "ZYX":
            this._y = Math.asin(-ln(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._x = Math.atan2(m, v),
            this._z = Math.atan2(c, s)) : (this._x = 0,
            this._z = Math.atan2(-o, f));
            break;
        case "YZX":
            this._z = Math.asin(ln(c, -1, 1)),
            Math.abs(c) < .9999999 ? (this._x = Math.atan2(-h, f),
            this._y = Math.atan2(-d, s)) : (this._x = 0,
            this._y = Math.atan2(a, v));
            break;
        case "XZY":
            this._z = Math.asin(-ln(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(m, f),
            this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-h, v),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        i === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, i) {
        return _M.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(_M, t, i)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return xM.setFromEuler(this),
        this.setFromQuaternion(xM, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
Ri.DEFAULT_ORDER = "XYZ";
class ca {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let lI = 0;
const SM = new U
  , Za = new En
  , os = new $e
  , Yh = new U
  , Hu = new U
  , uI = new U
  , cI = new En
  , MM = new U(1,0,0)
  , wM = new U(0,1,0)
  , EM = new U(0,0,1)
  , fI = {
    type: "added"
}
  , hI = {
    type: "removed"
}
  , f0 = {
    type: "childadded",
    child: null
}
  , h0 = {
    type: "childremoved",
    child: null
};
class bt extends Rs {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: lI++
        }),
        this.uuid = Hi(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = bt.DEFAULT_UP.clone();
        const e = new U
          , t = new Ri
          , i = new En
          , r = new U(1,1,1);
        function s() {
            i.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(i, void 0, !1)
        }
        t._onChange(s),
        i._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new $e
            },
            normalMatrix: {
                value: new mt
            }
        }),
        this.matrix = new $e,
        this.matrixWorld = new $e,
        this.matrixAutoUpdate = bt.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = bt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new ca,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return Za.setFromAxisAngle(e, t),
        this.quaternion.multiply(Za),
        this
    }
    rotateOnWorldAxis(e, t) {
        return Za.setFromAxisAngle(e, t),
        this.quaternion.premultiply(Za),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(MM, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(wM, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(EM, e)
    }
    translateOnAxis(e, t) {
        return SM.copy(e).applyQuaternion(this.quaternion),
        this.position.add(SM.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(MM, e)
    }
    translateY(e) {
        return this.translateOnAxis(wM, e)
    }
    translateZ(e) {
        return this.translateOnAxis(EM, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(os.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, i) {
        e.isVector3 ? Yh.copy(e) : Yh.set(e, t, i);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1),
        Hu.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? os.lookAt(Hu, Yh, this.up) : os.lookAt(Yh, Hu, this.up),
        this.quaternion.setFromRotationMatrix(os),
        r && (os.extractRotation(r.matrixWorld),
        Za.setFromRotationMatrix(os),
        this.quaternion.premultiply(Za.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(fI),
        f0.child = e,
        this.dispatchEvent(f0),
        f0.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++)
                this.remove(arguments[i]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(hI),
        h0.child = e,
        this.dispatchEvent(h0),
        h0.child = null),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        os.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        os.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(os),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let i = 0, r = this.children.length; i < r; i++) {
            const o = this.children[i].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t, i=[]) {
        this[e] === t && i.push(this);
        const r = this.children;
        for (let s = 0, o = r.length; s < o; s++)
            r[s].getObjectsByProperty(e, t, i);
        return i
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Hu, e, uI),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Hu, cI, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const i = this.parent;
        if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        t === !0) {
            const r = this.children;
            for (let s = 0, o = r.length; s < o; s++) {
                const a = r[s];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , i = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        i.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const r = {};
        r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.castShadow === !0 && (r.castShadow = !0),
        this.receiveShadow === !0 && (r.receiveShadow = !0),
        this.visible === !1 && (r.visible = !1),
        this.frustumCulled === !1 && (r.frustumCulled = !1),
        this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        r.layers = this.layers.mask,
        r.matrix = this.matrix.toArray(),
        r.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
        this.isInstancedMesh && (r.type = "InstancedMesh",
        r.count = this.count,
        r.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (r.type = "BatchedMesh",
        r.perObjectFrustumCulled = this.perObjectFrustumCulled,
        r.sortObjects = this.sortObjects,
        r.drawRanges = this._drawRanges,
        r.reservedRanges = this._reservedRanges,
        r.visibility = this._visibility,
        r.active = this._active,
        r.bounds = this._bounds.map(a=>({
            boxInitialized: a.boxInitialized,
            boxMin: a.box.min.toArray(),
            boxMax: a.box.max.toArray(),
            sphereInitialized: a.sphereInitialized,
            sphereRadius: a.sphere.radius,
            sphereCenter: a.sphere.center.toArray()
        })),
        r.maxGeometryCount = this._maxGeometryCount,
        r.maxVertexCount = this._maxVertexCount,
        r.maxIndexCount = this._maxIndexCount,
        r.geometryInitialized = this._geometryInitialized,
        r.geometryCount = this._geometryCount,
        r.matricesTexture = this._matricesTexture.toJSON(e),
        this.boundingSphere !== null && (r.boundingSphere = {
            center: r.boundingSphere.center.toArray(),
            radius: r.boundingSphere.radius
        }),
        this.boundingBox !== null && (r.boundingBox = {
            min: r.boundingBox.min.toArray(),
            max: r.boundingBox.max.toArray()
        }));
        function s(a, c) {
            return a[c.uuid] === void 0 && (a[c.uuid] = c.toJSON(e)),
            c.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const c = a.shapes;
                if (Array.isArray(c))
                    for (let f = 0, h = c.length; f < h; f++) {
                        const d = c[f];
                        s(e.shapes, d)
                    }
                else
                    s(e.shapes, c)
            }
        }
        if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
        r.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (s(e.skeletons, this.skeleton),
        r.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let c = 0, f = this.material.length; c < f; c++)
                    a.push(s(e.materials, this.material[c]));
                r.material = a
            } else
                r.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            r.children = [];
            for (let a = 0; a < this.children.length; a++)
                r.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            r.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const c = this.animations[a];
                r.animations.push(s(e.animations, c))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , c = o(e.materials)
              , f = o(e.textures)
              , h = o(e.images)
              , d = o(e.shapes)
              , m = o(e.skeletons)
              , v = o(e.animations)
              , _ = o(e.nodes);
            a.length > 0 && (i.geometries = a),
            c.length > 0 && (i.materials = c),
            f.length > 0 && (i.textures = f),
            h.length > 0 && (i.images = h),
            d.length > 0 && (i.shapes = d),
            m.length > 0 && (i.skeletons = m),
            v.length > 0 && (i.animations = v),
            _.length > 0 && (i.nodes = _)
        }
        return i.object = r,
        i;
        function o(a) {
            const c = [];
            for (const f in a) {
                const h = a[f];
                delete h.metadata,
                c.push(h)
            }
            return c
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let i = 0; i < e.children.length; i++) {
                const r = e.children[i];
                this.add(r.clone())
            }
        return this
    }
}
bt.DEFAULT_UP = new U(0,1,0);
bt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
bt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const vr = new U
  , as = new U
  , d0 = new U
  , ls = new U
  , Ja = new U
  , Ka = new U
  , TM = new U
  , p0 = new U
  , m0 = new U
  , g0 = new U;
class ki {
    constructor(e=new U, t=new U, i=new U) {
        this.a = e,
        this.b = t,
        this.c = i
    }
    static getNormal(e, t, i, r) {
        r.subVectors(i, t),
        vr.subVectors(e, t),
        r.cross(vr);
        const s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
    }
    static getBarycoord(e, t, i, r, s) {
        vr.subVectors(r, t),
        as.subVectors(i, t),
        d0.subVectors(e, t);
        const o = vr.dot(vr)
          , a = vr.dot(as)
          , c = vr.dot(d0)
          , f = as.dot(as)
          , h = as.dot(d0)
          , d = o * f - a * a;
        if (d === 0)
            return s.set(0, 0, 0),
            null;
        const m = 1 / d
          , v = (f * c - a * h) * m
          , _ = (o * h - a * c) * m;
        return s.set(1 - v - _, _, v)
    }
    static containsPoint(e, t, i, r) {
        return this.getBarycoord(e, t, i, r, ls) === null ? !1 : ls.x >= 0 && ls.y >= 0 && ls.x + ls.y <= 1
    }
    static getInterpolation(e, t, i, r, s, o, a, c) {
        return this.getBarycoord(e, t, i, r, ls) === null ? (c.x = 0,
        c.y = 0,
        "z"in c && (c.z = 0),
        "w"in c && (c.w = 0),
        null) : (c.setScalar(0),
        c.addScaledVector(s, ls.x),
        c.addScaledVector(o, ls.y),
        c.addScaledVector(a, ls.z),
        c)
    }
    static isFrontFacing(e, t, i, r) {
        return vr.subVectors(i, t),
        as.subVectors(e, t),
        vr.cross(as).dot(r) < 0
    }
    set(e, t, i) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(i),
        this
    }
    setFromPointsAndIndices(e, t, i, r) {
        return this.a.copy(e[t]),
        this.b.copy(e[i]),
        this.c.copy(e[r]),
        this
    }
    setFromAttributeAndIndices(e, t, i, r) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, i),
        this.c.fromBufferAttribute(e, r),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return vr.subVectors(this.c, this.b),
        as.subVectors(this.a, this.b),
        vr.cross(as).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return ki.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return ki.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getInterpolation(e, t, i, r, s) {
        return ki.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    }
    containsPoint(e) {
        return ki.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return ki.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const i = this.a
          , r = this.b
          , s = this.c;
        let o, a;
        Ja.subVectors(r, i),
        Ka.subVectors(s, i),
        p0.subVectors(e, i);
        const c = Ja.dot(p0)
          , f = Ka.dot(p0);
        if (c <= 0 && f <= 0)
            return t.copy(i);
        m0.subVectors(e, r);
        const h = Ja.dot(m0)
          , d = Ka.dot(m0);
        if (h >= 0 && d <= h)
            return t.copy(r);
        const m = c * d - h * f;
        if (m <= 0 && c >= 0 && h <= 0)
            return o = c / (c - h),
            t.copy(i).addScaledVector(Ja, o);
        g0.subVectors(e, s);
        const v = Ja.dot(g0)
          , _ = Ka.dot(g0);
        if (_ >= 0 && v <= _)
            return t.copy(s);
        const w = v * f - c * _;
        if (w <= 0 && f >= 0 && _ <= 0)
            return a = f / (f - _),
            t.copy(i).addScaledVector(Ka, a);
        const x = h * _ - v * d;
        if (x <= 0 && d - h >= 0 && v - _ >= 0)
            return TM.subVectors(s, r),
            a = (d - h) / (d - h + (v - _)),
            t.copy(r).addScaledVector(TM, a);
        const g = 1 / (x + w + m);
        return o = w * g,
        a = m * g,
        t.copy(i).addScaledVector(Ja, o).addScaledVector(Ka, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const uC = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , Gs = {
    h: 0,
    s: 0,
    l: 0
}
  , jh = {
    h: 0,
    s: 0,
    l: 0
};
function v0(n, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}
class Ne {
    constructor(e, t, i) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, t, i)
    }
    set(e, t, i) {
        if (t === void 0 && i === void 0) {
            const r = e;
            r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r)
        } else
            this.setRGB(e, t, i);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=Fi) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        Ut.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, i, r=Ut.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = i,
        Ut.toWorkingColorSpace(this, r),
        this
    }
    setHSL(e, t, i, r=Ut.workingColorSpace) {
        if (e = W_(e, 1),
        t = ln(t, 0, 1),
        i = ln(i, 0, 1),
        t === 0)
            this.r = this.g = this.b = i;
        else {
            const s = i <= .5 ? i * (1 + t) : i + t - i * t
              , o = 2 * i - s;
            this.r = v0(o, s, e + 1 / 3),
            this.g = v0(o, s, e),
            this.b = v0(o, s, e - 1 / 3)
        }
        return Ut.toWorkingColorSpace(this, r),
        this
    }
    setStyle(e, t=Fi) {
        function i(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let r;
        if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = r[1]
              , a = r[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = r[1]
              , o = s.length;
            if (o === 3)
                return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
            if (o === 6)
                return this.setHex(parseInt(s, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=Fi) {
        const i = uC[e.toLowerCase()];
        return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = Hl(e.r),
        this.g = Hl(e.g),
        this.b = Hl(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = i0(e.r),
        this.g = i0(e.g),
        this.b = i0(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=Fi) {
        return Ut.fromWorkingColorSpace(Kn.copy(this), e),
        Math.round(ln(Kn.r * 255, 0, 255)) * 65536 + Math.round(ln(Kn.g * 255, 0, 255)) * 256 + Math.round(ln(Kn.b * 255, 0, 255))
    }
    getHexString(e=Fi) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=Ut.workingColorSpace) {
        Ut.fromWorkingColorSpace(Kn.copy(this), t);
        const i = Kn.r
          , r = Kn.g
          , s = Kn.b
          , o = Math.max(i, r, s)
          , a = Math.min(i, r, s);
        let c, f;
        const h = (a + o) / 2;
        if (a === o)
            c = 0,
            f = 0;
        else {
            const d = o - a;
            switch (f = h <= .5 ? d / (o + a) : d / (2 - o - a),
            o) {
            case i:
                c = (r - s) / d + (r < s ? 6 : 0);
                break;
            case r:
                c = (s - i) / d + 2;
                break;
            case s:
                c = (i - r) / d + 4;
                break
            }
            c /= 6
        }
        return e.h = c,
        e.s = f,
        e.l = h,
        e
    }
    getRGB(e, t=Ut.workingColorSpace) {
        return Ut.fromWorkingColorSpace(Kn.copy(this), t),
        e.r = Kn.r,
        e.g = Kn.g,
        e.b = Kn.b,
        e
    }
    getStyle(e=Fi) {
        Ut.fromWorkingColorSpace(Kn.copy(this), e);
        const t = Kn.r
          , i = Kn.g
          , r = Kn.b;
        return e !== Fi ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`
    }
    offsetHSL(e, t, i) {
        return this.getHSL(Gs),
        this.setHSL(Gs.h + e, Gs.s + t, Gs.l + i)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, i) {
        return this.r = e.r + (t.r - e.r) * i,
        this.g = e.g + (t.g - e.g) * i,
        this.b = e.b + (t.b - e.b) * i,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(Gs),
        e.getHSL(jh);
        const i = xc(Gs.h, jh.h, t)
          , r = xc(Gs.s, jh.s, t)
          , s = xc(Gs.l, jh.l, t);
        return this.setHSL(i, r, s),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , i = this.g
          , r = this.b
          , s = e.elements;
        return this.r = s[0] * t + s[3] * i + s[6] * r,
        this.g = s[1] * t + s[4] * i + s[7] * r,
        this.b = s[2] * t + s[5] * i + s[8] * r,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const Kn = new Ne;
Ne.NAMES = uC;
let dI = 0;
class Gn extends Rs {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: dI++
        }),
        this.uuid = Hi(),
        this.name = "",
        this.type = "Material",
        this.blending = la,
        this.side = Zr,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = wp,
        this.blendDst = Ep,
        this.blendEquation = Qs,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new Ne(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = Hc,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = My,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = qo,
        this.stencilZFail = qo,
        this.stencilZPass = qo,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const i = e[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const r = this[t];
                if (r === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const i = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        this.roughness !== void 0 && (i.roughness = this.roughness),
        this.metalness !== void 0 && (i.metalness = this.metalness),
        this.sheen !== void 0 && (i.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (i.shininess = this.shininess),
        this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.iridescence !== void 0 && (i.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid,
        i.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid,
        i.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid,
        i.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid,
        i.normalMapType = this.normalMapType,
        i.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid,
        i.displacementScale = this.displacementScale,
        i.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (i.combine = this.combine)),
        this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()),
        this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (i.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (i.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (i.size = this.size),
        this.shadowSide !== null && (i.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation),
        this.blending !== la && (i.blending = this.blending),
        this.side !== Zr && (i.side = this.side),
        this.vertexColors === !0 && (i.vertexColors = !0),
        this.opacity < 1 && (i.opacity = this.opacity),
        this.transparent === !0 && (i.transparent = !0),
        this.blendSrc !== wp && (i.blendSrc = this.blendSrc),
        this.blendDst !== Ep && (i.blendDst = this.blendDst),
        this.blendEquation !== Qs && (i.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
        this.depthFunc !== Hc && (i.depthFunc = this.depthFunc),
        this.depthTest === !1 && (i.depthTest = this.depthTest),
        this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== My && (i.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== qo && (i.stencilFail = this.stencilFail),
        this.stencilZFail !== qo && (i.stencilZFail = this.stencilZFail),
        this.stencilZPass !== qo && (i.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation),
        this.polygonOffset === !0 && (i.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth),
        this.dashSize !== void 0 && (i.dashSize = this.dashSize),
        this.gapSize !== void 0 && (i.gapSize = this.gapSize),
        this.scale !== void 0 && (i.scale = this.scale),
        this.dithering === !0 && (i.dithering = !0),
        this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (i.alphaHash = !0),
        this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (i.forceSinglePass = !0),
        this.wireframe === !0 && (i.wireframe = !0),
        this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (i.flatShading = !0),
        this.visible === !1 && (i.visible = !1),
        this.toneMapped === !1 && (i.toneMapped = !1),
        this.fog === !1 && (i.fog = !1),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData);
        function r(s) {
            const o = [];
            for (const a in s) {
                const c = s[a];
                delete c.metadata,
                o.push(c)
            }
            return o
        }
        if (t) {
            const s = r(e.textures)
              , o = r(e.images);
            s.length > 0 && (i.textures = s),
            o.length > 0 && (i.images = o)
        }
        return i
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let i = null;
        if (t !== null) {
            const r = t.length;
            i = new Array(r);
            for (let s = 0; s !== r; ++s)
                i[s] = t[s].clone()
        }
        return this.clippingPlanes = i,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class So extends Gn {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new Ne(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Ri,
        this.combine = mf,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const ps = pI();
function pI() {
    const n = new ArrayBuffer(4)
      , e = new Float32Array(n)
      , t = new Uint32Array(n)
      , i = new Uint32Array(512)
      , r = new Uint32Array(512);
    for (let c = 0; c < 256; ++c) {
        const f = c - 127;
        f < -27 ? (i[c] = 0,
        i[c | 256] = 32768,
        r[c] = 24,
        r[c | 256] = 24) : f < -14 ? (i[c] = 1024 >> -f - 14,
        i[c | 256] = 1024 >> -f - 14 | 32768,
        r[c] = -f - 1,
        r[c | 256] = -f - 1) : f <= 15 ? (i[c] = f + 15 << 10,
        i[c | 256] = f + 15 << 10 | 32768,
        r[c] = 13,
        r[c | 256] = 13) : f < 128 ? (i[c] = 31744,
        i[c | 256] = 64512,
        r[c] = 24,
        r[c | 256] = 24) : (i[c] = 31744,
        i[c | 256] = 64512,
        r[c] = 13,
        r[c | 256] = 13)
    }
    const s = new Uint32Array(2048)
      , o = new Uint32Array(64)
      , a = new Uint32Array(64);
    for (let c = 1; c < 1024; ++c) {
        let f = c << 13
          , h = 0;
        for (; !(f & 8388608); )
            f <<= 1,
            h -= 8388608;
        f &= -8388609,
        h += 947912704,
        s[c] = f | h
    }
    for (let c = 1024; c < 2048; ++c)
        s[c] = 939524096 + (c - 1024 << 13);
    for (let c = 1; c < 31; ++c)
        o[c] = c << 23;
    o[31] = 1199570944,
    o[32] = 2147483648;
    for (let c = 33; c < 63; ++c)
        o[c] = 2147483648 + (c - 32 << 23);
    o[63] = 3347054592;
    for (let c = 1; c < 64; ++c)
        c !== 32 && (a[c] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: i,
        shiftTable: r,
        mantissaTable: s,
        exponentTable: o,
        offsetTable: a
    }
}
function Si(n) {
    Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    n = ln(n, -65504, 65504),
    ps.floatView[0] = n;
    const e = ps.uint32View[0]
      , t = e >> 23 & 511;
    return ps.baseTable[t] + ((e & 8388607) >> ps.shiftTable[t])
}
function lc(n) {
    const e = n >> 10;
    return ps.uint32View[0] = ps.mantissaTable[ps.offsetTable[e] + (n & 1023)] + ps.exponentTable[e],
    ps.floatView[0]
}
const mI = {
    toHalfFloat: Si,
    fromHalfFloat: lc
}
  , vn = new U
  , qh = new he;
class Nt {
    constructor(e, t, i=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = i,
        this.usage = Qc,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.gpuType = wi,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return aC("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, t, i) {
        e *= this.itemSize,
        i *= t.itemSize;
        for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[e + r] = t.array[i + r];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, i = this.count; t < i; t++)
                qh.fromBufferAttribute(this, t),
                qh.applyMatrix3(e),
                this.setXY(t, qh.x, qh.y);
        else if (this.itemSize === 3)
            for (let t = 0, i = this.count; t < i; t++)
                vn.fromBufferAttribute(this, t),
                vn.applyMatrix3(e),
                this.setXYZ(t, vn.x, vn.y, vn.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++)
            vn.fromBufferAttribute(this, t),
            vn.applyMatrix4(e),
            this.setXYZ(t, vn.x, vn.y, vn.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            vn.fromBufferAttribute(this, t),
            vn.applyNormalMatrix(e),
            this.setXYZ(t, vn.x, vn.y, vn.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            vn.fromBufferAttribute(this, t),
            vn.transformDirection(e),
            this.setXYZ(t, vn.x, vn.y, vn.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getComponent(e, t) {
        let i = this.array[e * this.itemSize + t];
        return this.normalized && (i = fi(i, this.array)),
        i
    }
    setComponent(e, t, i) {
        return this.normalized && (i = gt(i, this.array)),
        this.array[e * this.itemSize + t] = i,
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = fi(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = gt(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = fi(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = gt(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = fi(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = gt(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = fi(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = gt(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, i) {
        return e *= this.itemSize,
        this.normalized && (t = gt(t, this.array),
        i = gt(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, r) {
        return e *= this.itemSize,
        this.normalized && (t = gt(t, this.array),
        i = gt(i, this.array),
        r = gt(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this
    }
    setXYZW(e, t, i, r, s) {
        return e *= this.itemSize,
        this.normalized && (t = gt(t, this.array),
        i = gt(i, this.array),
        r = gt(r, this.array),
        s = gt(s, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this.array[e + 3] = s,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== Qc && (e.usage = this.usage),
        e
    }
}
class gI extends Nt {
    constructor(e, t, i) {
        super(new Int8Array(e), t, i)
    }
}
class vI extends Nt {
    constructor(e, t, i) {
        super(new Uint8Array(e), t, i)
    }
}
class yI extends Nt {
    constructor(e, t, i) {
        super(new Uint8ClampedArray(e), t, i)
    }
}
class _I extends Nt {
    constructor(e, t, i) {
        super(new Int16Array(e), t, i)
    }
}
class j_ extends Nt {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i)
    }
}
class xI extends Nt {
    constructor(e, t, i) {
        super(new Int32Array(e), t, i)
    }
}
class q_ extends Nt {
    constructor(e, t, i) {
        super(new Uint32Array(e), t, i)
    }
}
class SI extends Nt {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i),
        this.isFloat16BufferAttribute = !0
    }
    getX(e) {
        let t = lc(this.array[e * this.itemSize]);
        return this.normalized && (t = fi(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = gt(t, this.array)),
        this.array[e * this.itemSize] = Si(t),
        this
    }
    getY(e) {
        let t = lc(this.array[e * this.itemSize + 1]);
        return this.normalized && (t = fi(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = gt(t, this.array)),
        this.array[e * this.itemSize + 1] = Si(t),
        this
    }
    getZ(e) {
        let t = lc(this.array[e * this.itemSize + 2]);
        return this.normalized && (t = fi(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = gt(t, this.array)),
        this.array[e * this.itemSize + 2] = Si(t),
        this
    }
    getW(e) {
        let t = lc(this.array[e * this.itemSize + 3]);
        return this.normalized && (t = fi(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = gt(t, this.array)),
        this.array[e * this.itemSize + 3] = Si(t),
        this
    }
    setXY(e, t, i) {
        return e *= this.itemSize,
        this.normalized && (t = gt(t, this.array),
        i = gt(i, this.array)),
        this.array[e + 0] = Si(t),
        this.array[e + 1] = Si(i),
        this
    }
    setXYZ(e, t, i, r) {
        return e *= this.itemSize,
        this.normalized && (t = gt(t, this.array),
        i = gt(i, this.array),
        r = gt(r, this.array)),
        this.array[e + 0] = Si(t),
        this.array[e + 1] = Si(i),
        this.array[e + 2] = Si(r),
        this
    }
    setXYZW(e, t, i, r, s) {
        return e *= this.itemSize,
        this.normalized && (t = gt(t, this.array),
        i = gt(i, this.array),
        r = gt(r, this.array),
        s = gt(s, this.array)),
        this.array[e + 0] = Si(t),
        this.array[e + 1] = Si(i),
        this.array[e + 2] = Si(r),
        this.array[e + 3] = Si(s),
        this
    }
}
class We extends Nt {
    constructor(e, t, i) {
        super(new Float32Array(e), t, i)
    }
}
let MI = 0;
const nr = new $e
  , y0 = new bt
  , Qa = new U
  , Ui = new di
  , Vu = new di
  , In = new U;
class _t extends Rs {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: MI++
        }),
        this.uuid = Hi(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (sC(e) ? q_ : j_)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, i=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: i
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const i = this.attributes.normal;
        if (i !== void 0) {
            const s = new mt().getNormalMatrix(e);
            i.applyNormalMatrix(s),
            i.needsUpdate = !0
        }
        const r = this.attributes.tangent;
        return r !== void 0 && (r.transformDirection(e),
        r.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return nr.makeRotationFromQuaternion(e),
        this.applyMatrix4(nr),
        this
    }
    rotateX(e) {
        return nr.makeRotationX(e),
        this.applyMatrix4(nr),
        this
    }
    rotateY(e) {
        return nr.makeRotationY(e),
        this.applyMatrix4(nr),
        this
    }
    rotateZ(e) {
        return nr.makeRotationZ(e),
        this.applyMatrix4(nr),
        this
    }
    translate(e, t, i) {
        return nr.makeTranslation(e, t, i),
        this.applyMatrix4(nr),
        this
    }
    scale(e, t, i) {
        return nr.makeScale(e, t, i),
        this.applyMatrix4(nr),
        this
    }
    lookAt(e) {
        return y0.lookAt(e),
        y0.updateMatrix(),
        this.applyMatrix4(y0.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(Qa).negate(),
        this.translate(Qa.x, Qa.y, Qa.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let i = 0, r = e.length; i < r; i++) {
            const s = e[i];
            t.push(s.x, s.y, s.z || 0)
        }
        return this.setAttribute("position", new We(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new di);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
            this.boundingBox.set(new U(-1 / 0,-1 / 0,-1 / 0), new U(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let i = 0, r = t.length; i < r; i++) {
                    const s = t[i];
                    Ui.setFromBufferAttribute(s),
                    this.morphTargetsRelative ? (In.addVectors(this.boundingBox.min, Ui.min),
                    this.boundingBox.expandByPoint(In),
                    In.addVectors(this.boundingBox.max, Ui.max),
                    this.boundingBox.expandByPoint(In)) : (this.boundingBox.expandByPoint(Ui.min),
                    this.boundingBox.expandByPoint(Ui.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new ni);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
            this.boundingSphere.set(new U, 1 / 0);
            return
        }
        if (e) {
            const i = this.boundingSphere.center;
            if (Ui.setFromBufferAttribute(e),
            t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    Vu.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (In.addVectors(Ui.min, Vu.min),
                    Ui.expandByPoint(In),
                    In.addVectors(Ui.max, Vu.max),
                    Ui.expandByPoint(In)) : (Ui.expandByPoint(Vu.min),
                    Ui.expandByPoint(Vu.max))
                }
            Ui.getCenter(i);
            let r = 0;
            for (let s = 0, o = e.count; s < o; s++)
                In.fromBufferAttribute(e, s),
                r = Math.max(r, i.distanceToSquared(In));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s]
                      , c = this.morphTargetsRelative;
                    for (let f = 0, h = a.count; f < h; f++)
                        In.fromBufferAttribute(a, f),
                        c && (Qa.fromBufferAttribute(e, f),
                        In.add(Qa)),
                        r = Math.max(r, i.distanceToSquared(In))
                }
            this.boundingSphere.radius = Math.sqrt(r),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const i = t.position
          , r = t.normal
          , s = t.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Nt(new Float32Array(4 * i.count),4));
        const o = this.getAttribute("tangent")
          , a = []
          , c = [];
        for (let N = 0; N < i.count; N++)
            a[N] = new U,
            c[N] = new U;
        const f = new U
          , h = new U
          , d = new U
          , m = new he
          , v = new he
          , _ = new he
          , w = new U
          , x = new U;
        function g(N, G, C) {
            f.fromBufferAttribute(i, N),
            h.fromBufferAttribute(i, G),
            d.fromBufferAttribute(i, C),
            m.fromBufferAttribute(s, N),
            v.fromBufferAttribute(s, G),
            _.fromBufferAttribute(s, C),
            h.sub(f),
            d.sub(f),
            v.sub(m),
            _.sub(m);
            const I = 1 / (v.x * _.y - _.x * v.y);
            isFinite(I) && (w.copy(h).multiplyScalar(_.y).addScaledVector(d, -v.y).multiplyScalar(I),
            x.copy(d).multiplyScalar(v.x).addScaledVector(h, -_.x).multiplyScalar(I),
            a[N].add(w),
            a[G].add(w),
            a[C].add(w),
            c[N].add(x),
            c[G].add(x),
            c[C].add(x))
        }
        let S = this.groups;
        S.length === 0 && (S = [{
            start: 0,
            count: e.count
        }]);
        for (let N = 0, G = S.length; N < G; ++N) {
            const C = S[N]
              , I = C.start
              , K = C.count;
            for (let se = I, B = I + K; se < B; se += 3)
                g(e.getX(se + 0), e.getX(se + 1), e.getX(se + 2))
        }
        const M = new U
          , T = new U
          , P = new U
          , R = new U;
        function b(N) {
            P.fromBufferAttribute(r, N),
            R.copy(P);
            const G = a[N];
            M.copy(G),
            M.sub(P.multiplyScalar(P.dot(G))).normalize(),
            T.crossVectors(R, G);
            const I = T.dot(c[N]) < 0 ? -1 : 1;
            o.setXYZW(N, M.x, M.y, M.z, I)
        }
        for (let N = 0, G = S.length; N < G; ++N) {
            const C = S[N]
              , I = C.start
              , K = C.count;
            for (let se = I, B = I + K; se < B; se += 3)
                b(e.getX(se + 0)),
                b(e.getX(se + 1)),
                b(e.getX(se + 2))
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0)
                i = new Nt(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", i);
            else
                for (let m = 0, v = i.count; m < v; m++)
                    i.setXYZ(m, 0, 0, 0);
            const r = new U
              , s = new U
              , o = new U
              , a = new U
              , c = new U
              , f = new U
              , h = new U
              , d = new U;
            if (e)
                for (let m = 0, v = e.count; m < v; m += 3) {
                    const _ = e.getX(m + 0)
                      , w = e.getX(m + 1)
                      , x = e.getX(m + 2);
                    r.fromBufferAttribute(t, _),
                    s.fromBufferAttribute(t, w),
                    o.fromBufferAttribute(t, x),
                    h.subVectors(o, s),
                    d.subVectors(r, s),
                    h.cross(d),
                    a.fromBufferAttribute(i, _),
                    c.fromBufferAttribute(i, w),
                    f.fromBufferAttribute(i, x),
                    a.add(h),
                    c.add(h),
                    f.add(h),
                    i.setXYZ(_, a.x, a.y, a.z),
                    i.setXYZ(w, c.x, c.y, c.z),
                    i.setXYZ(x, f.x, f.y, f.z)
                }
            else
                for (let m = 0, v = t.count; m < v; m += 3)
                    r.fromBufferAttribute(t, m + 0),
                    s.fromBufferAttribute(t, m + 1),
                    o.fromBufferAttribute(t, m + 2),
                    h.subVectors(o, s),
                    d.subVectors(r, s),
                    h.cross(d),
                    i.setXYZ(m + 0, h.x, h.y, h.z),
                    i.setXYZ(m + 1, h.x, h.y, h.z),
                    i.setXYZ(m + 2, h.x, h.y, h.z);
            this.normalizeNormals(),
            i.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++)
            In.fromBufferAttribute(e, t),
            In.normalize(),
            e.setXYZ(t, In.x, In.y, In.z)
    }
    toNonIndexed() {
        function e(a, c) {
            const f = a.array
              , h = a.itemSize
              , d = a.normalized
              , m = new f.constructor(c.length * h);
            let v = 0
              , _ = 0;
            for (let w = 0, x = c.length; w < x; w++) {
                a.isInterleavedBufferAttribute ? v = c[w] * a.data.stride + a.offset : v = c[w] * h;
                for (let g = 0; g < h; g++)
                    m[_++] = f[v++]
            }
            return new Nt(m,h,d)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new _t
          , i = this.index.array
          , r = this.attributes;
        for (const a in r) {
            const c = r[a]
              , f = e(c, i);
            t.setAttribute(a, f)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const c = []
              , f = s[a];
            for (let h = 0, d = f.length; h < d; h++) {
                const m = f[h]
                  , v = e(m, i);
                c.push(v)
            }
            t.morphAttributes[a] = c
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, c = o.length; a < c; a++) {
            const f = o[a];
            t.addGroup(f.start, f.count, f.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const c = this.parameters;
            for (const f in c)
                c[f] !== void 0 && (e[f] = c[f]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const i = this.attributes;
        for (const c in i) {
            const f = i[c];
            e.data.attributes[c] = f.toJSON(e.data)
        }
        const r = {};
        let s = !1;
        for (const c in this.morphAttributes) {
            const f = this.morphAttributes[c]
              , h = [];
            for (let d = 0, m = f.length; d < m; d++) {
                const v = f[d];
                h.push(v.toJSON(e.data))
            }
            h.length > 0 && (r[c] = h,
            s = !0)
        }
        s && (e.data.morphAttributes = r,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone(t));
        const r = e.attributes;
        for (const f in r) {
            const h = r[f];
            this.setAttribute(f, h.clone(t))
        }
        const s = e.morphAttributes;
        for (const f in s) {
            const h = []
              , d = s[f];
            for (let m = 0, v = d.length; m < v; m++)
                h.push(d[m].clone(t));
            this.morphAttributes[f] = h
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let f = 0, h = o.length; f < h; f++) {
            const d = o[f];
            this.addGroup(d.start, d.count, d.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const c = e.boundingSphere;
        return c !== null && (this.boundingSphere = c.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const AM = new $e
  , Uo = new su
  , Zh = new ni
  , CM = new U
  , $a = new U
  , el = new U
  , tl = new U
  , _0 = new U
  , Jh = new U
  , Kh = new he
  , Qh = new he
  , $h = new he
  , RM = new U
  , bM = new U
  , PM = new U
  , ed = new U
  , td = new U;
class _n extends bt {
    constructor(e=new _t, t=new So) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const i = this.geometry
          , r = i.attributes.position
          , s = i.morphAttributes.position
          , o = i.morphTargetsRelative;
        t.fromBufferAttribute(r, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            Jh.set(0, 0, 0);
            for (let c = 0, f = s.length; c < f; c++) {
                const h = a[c]
                  , d = s[c];
                h !== 0 && (_0.fromBufferAttribute(d, e),
                o ? Jh.addScaledVector(_0, h) : Jh.addScaledVector(_0.sub(t), h))
            }
            t.add(Jh)
        }
        return t
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.material
          , s = this.matrixWorld;
        r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(),
        Zh.copy(i.boundingSphere),
        Zh.applyMatrix4(s),
        Uo.copy(e.ray).recast(e.near),
        !(Zh.containsPoint(Uo.origin) === !1 && (Uo.intersectSphere(Zh, CM) === null || Uo.origin.distanceToSquared(CM) > (e.far - e.near) ** 2)) && (AM.copy(s).invert(),
        Uo.copy(e.ray).applyMatrix4(AM),
        !(i.boundingBox !== null && Uo.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, Uo)))
    }
    _computeIntersections(e, t, i) {
        let r;
        const s = this.geometry
          , o = this.material
          , a = s.index
          , c = s.attributes.position
          , f = s.attributes.uv
          , h = s.attributes.uv1
          , d = s.attributes.normal
          , m = s.groups
          , v = s.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let _ = 0, w = m.length; _ < w; _++) {
                    const x = m[_]
                      , g = o[x.materialIndex]
                      , S = Math.max(x.start, v.start)
                      , M = Math.min(a.count, Math.min(x.start + x.count, v.start + v.count));
                    for (let T = S, P = M; T < P; T += 3) {
                        const R = a.getX(T)
                          , b = a.getX(T + 1)
                          , N = a.getX(T + 2);
                        r = nd(this, g, e, i, f, h, d, R, b, N),
                        r && (r.faceIndex = Math.floor(T / 3),
                        r.face.materialIndex = x.materialIndex,
                        t.push(r))
                    }
                }
            else {
                const _ = Math.max(0, v.start)
                  , w = Math.min(a.count, v.start + v.count);
                for (let x = _, g = w; x < g; x += 3) {
                    const S = a.getX(x)
                      , M = a.getX(x + 1)
                      , T = a.getX(x + 2);
                    r = nd(this, o, e, i, f, h, d, S, M, T),
                    r && (r.faceIndex = Math.floor(x / 3),
                    t.push(r))
                }
            }
        else if (c !== void 0)
            if (Array.isArray(o))
                for (let _ = 0, w = m.length; _ < w; _++) {
                    const x = m[_]
                      , g = o[x.materialIndex]
                      , S = Math.max(x.start, v.start)
                      , M = Math.min(c.count, Math.min(x.start + x.count, v.start + v.count));
                    for (let T = S, P = M; T < P; T += 3) {
                        const R = T
                          , b = T + 1
                          , N = T + 2;
                        r = nd(this, g, e, i, f, h, d, R, b, N),
                        r && (r.faceIndex = Math.floor(T / 3),
                        r.face.materialIndex = x.materialIndex,
                        t.push(r))
                    }
                }
            else {
                const _ = Math.max(0, v.start)
                  , w = Math.min(c.count, v.start + v.count);
                for (let x = _, g = w; x < g; x += 3) {
                    const S = x
                      , M = x + 1
                      , T = x + 2;
                    r = nd(this, o, e, i, f, h, d, S, M, T),
                    r && (r.faceIndex = Math.floor(x / 3),
                    t.push(r))
                }
            }
    }
}
function wI(n, e, t, i, r, s, o, a) {
    let c;
    if (e.side === ti ? c = i.intersectTriangle(o, s, r, !0, a) : c = i.intersectTriangle(r, s, o, e.side === Zr, a),
    c === null)
        return null;
    td.copy(a),
    td.applyMatrix4(n.matrixWorld);
    const f = t.ray.origin.distanceTo(td);
    return f < t.near || f > t.far ? null : {
        distance: f,
        point: td.clone(),
        object: n
    }
}
function nd(n, e, t, i, r, s, o, a, c, f) {
    n.getVertexPosition(a, $a),
    n.getVertexPosition(c, el),
    n.getVertexPosition(f, tl);
    const h = wI(n, e, t, i, $a, el, tl, ed);
    if (h) {
        r && (Kh.fromBufferAttribute(r, a),
        Qh.fromBufferAttribute(r, c),
        $h.fromBufferAttribute(r, f),
        h.uv = ki.getInterpolation(ed, $a, el, tl, Kh, Qh, $h, new he)),
        s && (Kh.fromBufferAttribute(s, a),
        Qh.fromBufferAttribute(s, c),
        $h.fromBufferAttribute(s, f),
        h.uv1 = ki.getInterpolation(ed, $a, el, tl, Kh, Qh, $h, new he)),
        o && (RM.fromBufferAttribute(o, a),
        bM.fromBufferAttribute(o, c),
        PM.fromBufferAttribute(o, f),
        h.normal = ki.getInterpolation(ed, $a, el, tl, RM, bM, PM, new U),
        h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
        const d = {
            a,
            b: c,
            c: f,
            normal: new U,
            materialIndex: 0
        };
        ki.getNormal($a, el, tl, d.normal),
        h.face = d
    }
    return h
}
class wa extends _t {
    constructor(e=1, t=1, i=1, r=1, s=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: r,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        r = Math.floor(r),
        s = Math.floor(s),
        o = Math.floor(o);
        const c = []
          , f = []
          , h = []
          , d = [];
        let m = 0
          , v = 0;
        _("z", "y", "x", -1, -1, i, t, e, o, s, 0),
        _("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
        _("x", "z", "y", 1, 1, e, i, t, r, o, 2),
        _("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
        _("x", "y", "z", 1, -1, e, t, i, r, s, 4),
        _("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
        this.setIndex(c),
        this.setAttribute("position", new We(f,3)),
        this.setAttribute("normal", new We(h,3)),
        this.setAttribute("uv", new We(d,2));
        function _(w, x, g, S, M, T, P, R, b, N, G) {
            const C = T / b
              , I = P / N
              , K = T / 2
              , se = P / 2
              , B = R / 2
              , ie = b + 1
              , J = N + 1;
            let ue = 0
              , F = 0;
            const H = new U;
            for (let V = 0; V < J; V++) {
                const q = V * I - se;
                for (let ce = 0; ce < ie; ce++) {
                    const Ce = ce * C - K;
                    H[w] = Ce * S,
                    H[x] = q * M,
                    H[g] = B,
                    f.push(H.x, H.y, H.z),
                    H[w] = 0,
                    H[x] = 0,
                    H[g] = R > 0 ? 1 : -1,
                    h.push(H.x, H.y, H.z),
                    d.push(ce / b),
                    d.push(1 - V / N),
                    ue += 1
                }
            }
            for (let V = 0; V < N; V++)
                for (let q = 0; q < b; q++) {
                    const ce = m + q + ie * V
                      , Ce = m + q + ie * (V + 1)
                      , Z = m + (q + 1) + ie * (V + 1)
                      , de = m + (q + 1) + ie * V;
                    c.push(ce, Ce, de),
                    c.push(Ce, Z, de),
                    F += 6
                }
            a.addGroup(v, F, G),
            v += F,
            m += ue
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new wa(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function Kl(n) {
    const e = {};
    for (const t in n) {
        e[t] = {};
        for (const i in n[t]) {
            const r = n[t][i];
            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[t][i] = null) : e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r
        }
    }
    return e
}
function li(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = Kl(n[t]);
        for (const r in i)
            e[r] = i[r]
    }
    return e
}
function EI(n) {
    const e = [];
    for (let t = 0; t < n.length; t++)
        e.push(n[t].clone());
    return e
}
function cC(n) {
    return n.getRenderTarget() === null ? n.outputColorSpace : Ut.workingColorSpace
}
const Z_ = {
    clone: Kl,
    merge: li
};
var TI = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , AI = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class fr extends Gn {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = TI,
        this.fragmentShader = AI,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1,
            clipCullDistance: !1,
            multiDraw: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = Kl(e.uniforms),
        this.uniformsGroups = EI(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const r in this.uniforms) {
            const o = this.uniforms[r].value;
            o && o.isTexture ? t.uniforms[r] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[r] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[r] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[r] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[r] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[r] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[r] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[r] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const i = {};
        for (const r in this.extensions)
            this.extensions[r] === !0 && (i[r] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i),
        t
    }
}
class vf extends bt {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new $e,
        this.projectionMatrix = new $e,
        this.projectionMatrixInverse = new $e,
        this.coordinateSystem = Wr
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Ws = new U
  , LM = new he
  , IM = new he;
class Dn extends vf {
    constructor(e=50, t=1, i=.1, r=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = i,
        this.far = r,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = Jl * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(ua * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Jl * 2 * Math.atan(Math.tan(ua * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, t, i) {
        Ws.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
        t.set(Ws.x, Ws.y).multiplyScalar(-e / Ws.z),
        Ws.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
        i.set(Ws.x, Ws.y).multiplyScalar(-e / Ws.z)
    }
    getViewSize(e, t) {
        return this.getViewBounds(e, LM, IM),
        t.subVectors(IM, LM)
    }
    setViewOffset(e, t, i, r, s, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(ua * .5 * this.fov) / this.zoom
          , i = 2 * t
          , r = this.aspect * i
          , s = -.5 * r;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const c = o.fullWidth
              , f = o.fullHeight;
            s += o.offsetX * r / c,
            t -= o.offsetY * i / f,
            r *= o.width / c,
            i *= o.height / f
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const nl = -90
  , il = 1;
class fC extends bt {
    constructor(e, t, i) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = i,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const r = new Dn(nl,il,e,t);
        r.layers = this.layers,
        this.add(r);
        const s = new Dn(nl,il,e,t);
        s.layers = this.layers,
        this.add(s);
        const o = new Dn(nl,il,e,t);
        o.layers = this.layers,
        this.add(o);
        const a = new Dn(nl,il,e,t);
        a.layers = this.layers,
        this.add(a);
        const c = new Dn(nl,il,e,t);
        c.layers = this.layers,
        this.add(c);
        const f = new Dn(nl,il,e,t);
        f.layers = this.layers,
        this.add(f)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , t = this.children.concat()
          , [i,r,s,o,a,c] = t;
        for (const f of t)
            this.remove(f);
        if (e === Wr)
            i.up.set(0, 1, 0),
            i.lookAt(1, 0, 0),
            r.up.set(0, 1, 0),
            r.lookAt(-1, 0, 0),
            s.up.set(0, 0, -1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, -1, 0),
            a.up.set(0, 1, 0),
            a.lookAt(0, 0, 1),
            c.up.set(0, 1, 0),
            c.lookAt(0, 0, -1);
        else if (e === $c)
            i.up.set(0, -1, 0),
            i.lookAt(-1, 0, 0),
            r.up.set(0, -1, 0),
            r.lookAt(1, 0, 0),
            s.up.set(0, 0, 1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, -1, 0),
            a.up.set(0, -1, 0),
            a.lookAt(0, 0, 1),
            c.up.set(0, -1, 0),
            c.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const f of t)
            this.add(f),
            f.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: i, activeMipmapLevel: r} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [s,o,a,c,f,h] = this.children
          , d = e.getRenderTarget()
          , m = e.getActiveCubeFace()
          , v = e.getActiveMipmapLevel()
          , _ = e.xr.enabled;
        e.xr.enabled = !1;
        const w = i.texture.generateMipmaps;
        i.texture.generateMipmaps = !1,
        e.setRenderTarget(i, 0, r),
        e.render(t, s),
        e.setRenderTarget(i, 1, r),
        e.render(t, o),
        e.setRenderTarget(i, 2, r),
        e.render(t, a),
        e.setRenderTarget(i, 3, r),
        e.render(t, c),
        e.setRenderTarget(i, 4, r),
        e.render(t, f),
        i.texture.generateMipmaps = w,
        e.setRenderTarget(i, 5, r),
        e.render(t, h),
        e.setRenderTarget(d, m, v),
        e.xr.enabled = _,
        i.texture.needsPMREMUpdate = !0
    }
}
class yf extends en {
    constructor(e, t, i, r, s, o, a, c, f, h) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : Ts,
        super(e, t, i, r, s, o, a, c, f, h),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class hC extends cr {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const i = {
            width: e,
            height: e,
            depth: 1
        }
          , r = [i, i, i, i, i, i];
        this.texture = new yf(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Wt
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const i = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , r = new wa(5,5,5)
          , s = new fr({
            name: "CubemapFromEquirect",
            uniforms: Kl(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: ti,
            blending: xs
        });
        s.uniforms.tEquirect.value = t;
        const o = new _n(r,s)
          , a = t.minFilter;
        return t.minFilter === Gr && (t.minFilter = Wt),
        new fC(1,10,this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t, i, r) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, i, r);
        e.setRenderTarget(s)
    }
}
const x0 = new U
  , CI = new U
  , RI = new mt;
let Zs = class {
    constructor(e=new U(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, i, r) {
        return this.normal.set(e, t, i),
        this.constant = r,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, i) {
        const r = x0.subVectors(i, t).cross(CI.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const i = e.delta(x0)
          , r = this.normal.dot(i);
        if (r === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , i = this.distanceToPoint(e.end);
        return t < 0 && i > 0 || i < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const i = t || RI.getNormalMatrix(e)
          , r = this.coplanarPoint(x0).applyMatrix4(e)
          , s = this.normal.applyMatrix3(i).normalize();
        return this.constant = -r.dot(s),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
;
const Oo = new ni
  , id = new U;
class _f {
    constructor(e=new Zs, t=new Zs, i=new Zs, r=new Zs, s=new Zs, o=new Zs) {
        this.planes = [e, t, i, r, s, o]
    }
    set(e, t, i, r, s, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(i),
        a[3].copy(r),
        a[4].copy(s),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            t[i].copy(e.planes[i]);
        return this
    }
    setFromProjectionMatrix(e, t=Wr) {
        const i = this.planes
          , r = e.elements
          , s = r[0]
          , o = r[1]
          , a = r[2]
          , c = r[3]
          , f = r[4]
          , h = r[5]
          , d = r[6]
          , m = r[7]
          , v = r[8]
          , _ = r[9]
          , w = r[10]
          , x = r[11]
          , g = r[12]
          , S = r[13]
          , M = r[14]
          , T = r[15];
        if (i[0].setComponents(c - s, m - f, x - v, T - g).normalize(),
        i[1].setComponents(c + s, m + f, x + v, T + g).normalize(),
        i[2].setComponents(c + o, m + h, x + _, T + S).normalize(),
        i[3].setComponents(c - o, m - h, x - _, T - S).normalize(),
        i[4].setComponents(c - a, m - d, x - w, T - M).normalize(),
        t === Wr)
            i[5].setComponents(c + a, m + d, x + w, T + M).normalize();
        else if (t === $c)
            i[5].setComponents(a, d, w, M).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            Oo.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            Oo.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(Oo)
    }
    intersectsSprite(e) {
        return Oo.center.set(0, 0, 0),
        Oo.radius = .7071067811865476,
        Oo.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Oo)
    }
    intersectsSphere(e) {
        const t = this.planes
          , i = e.center
          , r = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(i) < r)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
            const r = t[i];
            if (id.x = r.normal.x > 0 ? e.max.x : e.min.x,
            id.y = r.normal.y > 0 ? e.max.y : e.min.y,
            id.z = r.normal.z > 0 ? e.max.z : e.min.z,
            r.distanceToPoint(id) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            if (t[i].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function dC() {
    let n = null
      , e = !1
      , t = null
      , i = null;
    function r(s, o) {
        t(s, o),
        i = n.requestAnimationFrame(r)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (i = n.requestAnimationFrame(r),
            e = !0)
        },
        stop: function() {
            n.cancelAnimationFrame(i),
            e = !1
        },
        setAnimationLoop: function(s) {
            t = s
        },
        setContext: function(s) {
            n = s
        }
    }
}
function bI(n, e) {
    const t = e.isWebGL2
      , i = new WeakMap;
    function r(f, h) {
        const d = f.array
          , m = f.usage
          , v = d.byteLength
          , _ = n.createBuffer();
        n.bindBuffer(h, _),
        n.bufferData(h, d, m),
        f.onUploadCallback();
        let w;
        if (d instanceof Float32Array)
            w = n.FLOAT;
        else if (d instanceof Uint16Array)
            if (f.isFloat16BufferAttribute)
                if (t)
                    w = n.HALF_FLOAT;
                else
                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            else
                w = n.UNSIGNED_SHORT;
        else if (d instanceof Int16Array)
            w = n.SHORT;
        else if (d instanceof Uint32Array)
            w = n.UNSIGNED_INT;
        else if (d instanceof Int32Array)
            w = n.INT;
        else if (d instanceof Int8Array)
            w = n.BYTE;
        else if (d instanceof Uint8Array)
            w = n.UNSIGNED_BYTE;
        else if (d instanceof Uint8ClampedArray)
            w = n.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + d);
        return {
            buffer: _,
            type: w,
            bytesPerElement: d.BYTES_PER_ELEMENT,
            version: f.version,
            size: v
        }
    }
    function s(f, h, d) {
        const m = h.array
          , v = h._updateRange
          , _ = h.updateRanges;
        if (n.bindBuffer(d, f),
        v.count === -1 && _.length === 0 && n.bufferSubData(d, 0, m),
        _.length !== 0) {
            for (let w = 0, x = _.length; w < x; w++) {
                const g = _[w];
                t ? n.bufferSubData(d, g.start * m.BYTES_PER_ELEMENT, m, g.start, g.count) : n.bufferSubData(d, g.start * m.BYTES_PER_ELEMENT, m.subarray(g.start, g.start + g.count))
            }
            h.clearUpdateRanges()
        }
        v.count !== -1 && (t ? n.bufferSubData(d, v.offset * m.BYTES_PER_ELEMENT, m, v.offset, v.count) : n.bufferSubData(d, v.offset * m.BYTES_PER_ELEMENT, m.subarray(v.offset, v.offset + v.count)),
        v.count = -1),
        h.onUploadCallback()
    }
    function o(f) {
        return f.isInterleavedBufferAttribute && (f = f.data),
        i.get(f)
    }
    function a(f) {
        f.isInterleavedBufferAttribute && (f = f.data);
        const h = i.get(f);
        h && (n.deleteBuffer(h.buffer),
        i.delete(f))
    }
    function c(f, h) {
        if (f.isGLBufferAttribute) {
            const m = i.get(f);
            (!m || m.version < f.version) && i.set(f, {
                buffer: f.buffer,
                type: f.type,
                bytesPerElement: f.elementSize,
                version: f.version
            });
            return
        }
        f.isInterleavedBufferAttribute && (f = f.data);
        const d = i.get(f);
        if (d === void 0)
            i.set(f, r(f, h));
        else if (d.version < f.version) {
            if (d.size !== f.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            s(d.buffer, f, h),
            d.version = f.version
        }
    }
    return {
        get: o,
        remove: a,
        update: c
    }
}
class ou extends _t {
    constructor(e=1, t=1, i=1, r=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: r
        };
        const s = e / 2
          , o = t / 2
          , a = Math.floor(i)
          , c = Math.floor(r)
          , f = a + 1
          , h = c + 1
          , d = e / a
          , m = t / c
          , v = []
          , _ = []
          , w = []
          , x = [];
        for (let g = 0; g < h; g++) {
            const S = g * m - o;
            for (let M = 0; M < f; M++) {
                const T = M * d - s;
                _.push(T, -S, 0),
                w.push(0, 0, 1),
                x.push(M / a),
                x.push(1 - g / c)
            }
        }
        for (let g = 0; g < c; g++)
            for (let S = 0; S < a; S++) {
                const M = S + f * g
                  , T = S + f * (g + 1)
                  , P = S + 1 + f * (g + 1)
                  , R = S + 1 + f * g;
                v.push(M, T, R),
                v.push(T, P, R)
            }
        this.setIndex(v),
        this.setAttribute("position", new We(_,3)),
        this.setAttribute("normal", new We(w,3)),
        this.setAttribute("uv", new We(x,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new ou(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var PI = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`
  , LI = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`
  , II = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , NI = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , DI = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`
  , UI = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , OI = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT )
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN )
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , FI = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , kI = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , zI = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`
  , BI = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`
  , HI = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , VI = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , GI = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , WI = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , XI = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`
  , YI = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , jI = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , qI = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , ZI = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , JI = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , KI = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`
  , QI = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`
  , $I = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , eN = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , tN = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , nN = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , iN = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , rN = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , sN = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , oN = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , aN = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`
  , lN = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , uN = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif

#endif`
  , cN = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , fN = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , hN = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , dN = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , pN = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , mN = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , gN = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , vN = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , yN = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`
  , _N = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , xN = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , SN = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , MN = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , wN = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
  , EN = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , TN = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , AN = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , CN = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , RN = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`
  , bN = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , PN = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , LN = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , IN = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`
  , NN = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , DN = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , UN = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`
  , ON = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`
  , FN = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );

	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , kN = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , zN = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , BN = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , HN = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , VN = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , GN = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`
  , WN = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , XN = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`
  , YN = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`
  , jN = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`
  , qN = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`
  , ZN = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , JN = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , KN = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , QN = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , $N = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , eD = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`
  , tD = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , nD = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , iD = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , rD = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , sD = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , oD = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , aD = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , lD = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , uD = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , cD = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , fD = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , hD = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`
  , dD = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , pD = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , mD = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , gD = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , vD = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , yD = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , _D = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , xD = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , SD = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , MD = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , wD = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	float startCompression = 0.8 - 0.04;
	float desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min(color.r, min(color.g, color.b));
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max(color.r, max(color.g, color.b));
	if (peak < startCompression) return color;
	float d = 1. - startCompression;
	float newPeak = 1. - d * d / (peak + d - startCompression);
	color *= newPeak / peak;
	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
	return mix(color, vec3(1, 1, 1), g);
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , ED = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`
  , TD = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`
  , AD = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , CD = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , RD = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , bD = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const PD = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , LD = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , ID = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , ND = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , DD = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , UD = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , OD = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , FD = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`
  , kD = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , zD = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , BD = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , HD = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , VD = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , GD = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , WD = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , XD = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , YD = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , jD = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , qD = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , ZD = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , JD = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , KD = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , QD = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , $D = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , eU = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , tU = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , nU = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , iU = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , rU = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , sU = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , oU = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , aU = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , lU = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , uU = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , yt = {
    alphahash_fragment: PI,
    alphahash_pars_fragment: LI,
    alphamap_fragment: II,
    alphamap_pars_fragment: NI,
    alphatest_fragment: DI,
    alphatest_pars_fragment: UI,
    aomap_fragment: OI,
    aomap_pars_fragment: FI,
    batching_pars_vertex: kI,
    batching_vertex: zI,
    begin_vertex: BI,
    beginnormal_vertex: HI,
    bsdfs: VI,
    iridescence_fragment: GI,
    bumpmap_pars_fragment: WI,
    clipping_planes_fragment: XI,
    clipping_planes_pars_fragment: YI,
    clipping_planes_pars_vertex: jI,
    clipping_planes_vertex: qI,
    color_fragment: ZI,
    color_pars_fragment: JI,
    color_pars_vertex: KI,
    color_vertex: QI,
    common: $I,
    cube_uv_reflection_fragment: eN,
    defaultnormal_vertex: tN,
    displacementmap_pars_vertex: nN,
    displacementmap_vertex: iN,
    emissivemap_fragment: rN,
    emissivemap_pars_fragment: sN,
    colorspace_fragment: oN,
    colorspace_pars_fragment: aN,
    envmap_fragment: lN,
    envmap_common_pars_fragment: uN,
    envmap_pars_fragment: cN,
    envmap_pars_vertex: fN,
    envmap_physical_pars_fragment: wN,
    envmap_vertex: hN,
    fog_vertex: dN,
    fog_pars_vertex: pN,
    fog_fragment: mN,
    fog_pars_fragment: gN,
    gradientmap_pars_fragment: vN,
    lightmap_fragment: yN,
    lightmap_pars_fragment: _N,
    lights_lambert_fragment: xN,
    lights_lambert_pars_fragment: SN,
    lights_pars_begin: MN,
    lights_toon_fragment: EN,
    lights_toon_pars_fragment: TN,
    lights_phong_fragment: AN,
    lights_phong_pars_fragment: CN,
    lights_physical_fragment: RN,
    lights_physical_pars_fragment: bN,
    lights_fragment_begin: PN,
    lights_fragment_maps: LN,
    lights_fragment_end: IN,
    logdepthbuf_fragment: NN,
    logdepthbuf_pars_fragment: DN,
    logdepthbuf_pars_vertex: UN,
    logdepthbuf_vertex: ON,
    map_fragment: FN,
    map_pars_fragment: kN,
    map_particle_fragment: zN,
    map_particle_pars_fragment: BN,
    metalnessmap_fragment: HN,
    metalnessmap_pars_fragment: VN,
    morphinstance_vertex: GN,
    morphcolor_vertex: WN,
    morphnormal_vertex: XN,
    morphtarget_pars_vertex: YN,
    morphtarget_vertex: jN,
    normal_fragment_begin: qN,
    normal_fragment_maps: ZN,
    normal_pars_fragment: JN,
    normal_pars_vertex: KN,
    normal_vertex: QN,
    normalmap_pars_fragment: $N,
    clearcoat_normal_fragment_begin: eD,
    clearcoat_normal_fragment_maps: tD,
    clearcoat_pars_fragment: nD,
    iridescence_pars_fragment: iD,
    opaque_fragment: rD,
    packing: sD,
    premultiplied_alpha_fragment: oD,
    project_vertex: aD,
    dithering_fragment: lD,
    dithering_pars_fragment: uD,
    roughnessmap_fragment: cD,
    roughnessmap_pars_fragment: fD,
    shadowmap_pars_fragment: hD,
    shadowmap_pars_vertex: dD,
    shadowmap_vertex: pD,
    shadowmask_pars_fragment: mD,
    skinbase_vertex: gD,
    skinning_pars_vertex: vD,
    skinning_vertex: yD,
    skinnormal_vertex: _D,
    specularmap_fragment: xD,
    specularmap_pars_fragment: SD,
    tonemapping_fragment: MD,
    tonemapping_pars_fragment: wD,
    transmission_fragment: ED,
    transmission_pars_fragment: TD,
    uv_pars_fragment: AD,
    uv_pars_vertex: CD,
    uv_vertex: RD,
    worldpos_vertex: bD,
    background_vert: PD,
    background_frag: LD,
    backgroundCube_vert: ID,
    backgroundCube_frag: ND,
    cube_vert: DD,
    cube_frag: UD,
    depth_vert: OD,
    depth_frag: FD,
    distanceRGBA_vert: kD,
    distanceRGBA_frag: zD,
    equirect_vert: BD,
    equirect_frag: HD,
    linedashed_vert: VD,
    linedashed_frag: GD,
    meshbasic_vert: WD,
    meshbasic_frag: XD,
    meshlambert_vert: YD,
    meshlambert_frag: jD,
    meshmatcap_vert: qD,
    meshmatcap_frag: ZD,
    meshnormal_vert: JD,
    meshnormal_frag: KD,
    meshphong_vert: QD,
    meshphong_frag: $D,
    meshphysical_vert: eU,
    meshphysical_frag: tU,
    meshtoon_vert: nU,
    meshtoon_frag: iU,
    points_vert: rU,
    points_frag: sU,
    shadow_vert: oU,
    shadow_frag: aU,
    sprite_vert: lU,
    sprite_frag: uU
}
  , Ae = {
    common: {
        diffuse: {
            value: new Ne(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new mt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new mt
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new mt
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        envMapRotation: {
            value: new mt
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new mt
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new mt
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new mt
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new mt
        },
        normalScale: {
            value: new he(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new mt
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new mt
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new mt
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new mt
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new Ne(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Ne(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new mt
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new mt
        }
    },
    sprite: {
        diffuse: {
            value: new Ne(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new he(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new mt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new mt
        },
        alphaTest: {
            value: 0
        }
    }
}
  , wr = {
    basic: {
        uniforms: li([Ae.common, Ae.specularmap, Ae.envmap, Ae.aomap, Ae.lightmap, Ae.fog]),
        vertexShader: yt.meshbasic_vert,
        fragmentShader: yt.meshbasic_frag
    },
    lambert: {
        uniforms: li([Ae.common, Ae.specularmap, Ae.envmap, Ae.aomap, Ae.lightmap, Ae.emissivemap, Ae.bumpmap, Ae.normalmap, Ae.displacementmap, Ae.fog, Ae.lights, {
            emissive: {
                value: new Ne(0)
            }
        }]),
        vertexShader: yt.meshlambert_vert,
        fragmentShader: yt.meshlambert_frag
    },
    phong: {
        uniforms: li([Ae.common, Ae.specularmap, Ae.envmap, Ae.aomap, Ae.lightmap, Ae.emissivemap, Ae.bumpmap, Ae.normalmap, Ae.displacementmap, Ae.fog, Ae.lights, {
            emissive: {
                value: new Ne(0)
            },
            specular: {
                value: new Ne(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: yt.meshphong_vert,
        fragmentShader: yt.meshphong_frag
    },
    standard: {
        uniforms: li([Ae.common, Ae.envmap, Ae.aomap, Ae.lightmap, Ae.emissivemap, Ae.bumpmap, Ae.normalmap, Ae.displacementmap, Ae.roughnessmap, Ae.metalnessmap, Ae.fog, Ae.lights, {
            emissive: {
                value: new Ne(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: yt.meshphysical_vert,
        fragmentShader: yt.meshphysical_frag
    },
    toon: {
        uniforms: li([Ae.common, Ae.aomap, Ae.lightmap, Ae.emissivemap, Ae.bumpmap, Ae.normalmap, Ae.displacementmap, Ae.gradientmap, Ae.fog, Ae.lights, {
            emissive: {
                value: new Ne(0)
            }
        }]),
        vertexShader: yt.meshtoon_vert,
        fragmentShader: yt.meshtoon_frag
    },
    matcap: {
        uniforms: li([Ae.common, Ae.bumpmap, Ae.normalmap, Ae.displacementmap, Ae.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: yt.meshmatcap_vert,
        fragmentShader: yt.meshmatcap_frag
    },
    points: {
        uniforms: li([Ae.points, Ae.fog]),
        vertexShader: yt.points_vert,
        fragmentShader: yt.points_frag
    },
    dashed: {
        uniforms: li([Ae.common, Ae.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: yt.linedashed_vert,
        fragmentShader: yt.linedashed_frag
    },
    depth: {
        uniforms: li([Ae.common, Ae.displacementmap]),
        vertexShader: yt.depth_vert,
        fragmentShader: yt.depth_frag
    },
    normal: {
        uniforms: li([Ae.common, Ae.bumpmap, Ae.normalmap, Ae.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: yt.meshnormal_vert,
        fragmentShader: yt.meshnormal_frag
    },
    sprite: {
        uniforms: li([Ae.sprite, Ae.fog]),
        vertexShader: yt.sprite_vert,
        fragmentShader: yt.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new mt
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: yt.background_vert,
        fragmentShader: yt.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            },
            backgroundRotation: {
                value: new mt
            }
        },
        vertexShader: yt.backgroundCube_vert,
        fragmentShader: yt.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: yt.cube_vert,
        fragmentShader: yt.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: yt.equirect_vert,
        fragmentShader: yt.equirect_frag
    },
    distanceRGBA: {
        uniforms: li([Ae.common, Ae.displacementmap, {
            referencePosition: {
                value: new U
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: yt.distanceRGBA_vert,
        fragmentShader: yt.distanceRGBA_frag
    },
    shadow: {
        uniforms: li([Ae.lights, Ae.fog, {
            color: {
                value: new Ne(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: yt.shadow_vert,
        fragmentShader: yt.shadow_frag
    }
};
wr.physical = {
    uniforms: li([wr.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new mt
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new mt
        },
        clearcoatNormalScale: {
            value: new he(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new mt
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new mt
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new mt
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Ne(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new mt
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new mt
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new mt
        },
        transmissionSamplerSize: {
            value: new he
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new mt
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Ne(0)
        },
        specularColor: {
            value: new Ne(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new mt
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new mt
        },
        anisotropyVector: {
            value: new he
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new mt
        }
    }]),
    vertexShader: yt.meshphysical_vert,
    fragmentShader: yt.meshphysical_frag
};
const rd = {
    r: 0,
    b: 0,
    g: 0
}
  , Fo = new Ri
  , cU = new $e;
function fU(n, e, t, i, r, s, o) {
    const a = new Ne(0);
    let c = s === !0 ? 0 : 1, f, h, d = null, m = 0, v = null;
    function _(x, g) {
        let S = !1
          , M = g.isScene === !0 ? g.background : null;
        M && M.isTexture && (M = (g.backgroundBlurriness > 0 ? t : e).get(M)),
        M === null ? w(a, c) : M && M.isColor && (w(M, 1),
        S = !0);
        const T = n.xr.getEnvironmentBlendMode();
        T === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : T === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o),
        (n.autoClear || S) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
        M && (M.isCubeTexture || M.mapping === ru) ? (h === void 0 && (h = new _n(new wa(1,1,1),new fr({
            name: "BackgroundCubeMaterial",
            uniforms: Kl(wr.backgroundCube.uniforms),
            vertexShader: wr.backgroundCube.vertexShader,
            fragmentShader: wr.backgroundCube.fragmentShader,
            side: ti,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        h.geometry.deleteAttribute("normal"),
        h.geometry.deleteAttribute("uv"),
        h.onBeforeRender = function(P, R, b) {
            this.matrixWorld.copyPosition(b.matrixWorld)
        }
        ,
        Object.defineProperty(h.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        r.update(h)),
        Fo.copy(g.backgroundRotation),
        Fo.x *= -1,
        Fo.y *= -1,
        Fo.z *= -1,
        M.isCubeTexture && M.isRenderTargetTexture === !1 && (Fo.y *= -1,
        Fo.z *= -1),
        h.material.uniforms.envMap.value = M,
        h.material.uniforms.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1,
        h.material.uniforms.backgroundBlurriness.value = g.backgroundBlurriness,
        h.material.uniforms.backgroundIntensity.value = g.backgroundIntensity,
        h.material.uniforms.backgroundRotation.value.setFromMatrix4(cU.makeRotationFromEuler(Fo)),
        h.material.toneMapped = Ut.getTransfer(M.colorSpace) !== Bt,
        (d !== M || m !== M.version || v !== n.toneMapping) && (h.material.needsUpdate = !0,
        d = M,
        m = M.version,
        v = n.toneMapping),
        h.layers.enableAll(),
        x.unshift(h, h.geometry, h.material, 0, 0, null)) : M && M.isTexture && (f === void 0 && (f = new _n(new ou(2,2),new fr({
            name: "BackgroundMaterial",
            uniforms: Kl(wr.background.uniforms),
            vertexShader: wr.background.vertexShader,
            fragmentShader: wr.background.fragmentShader,
            side: Zr,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        f.geometry.deleteAttribute("normal"),
        Object.defineProperty(f.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        r.update(f)),
        f.material.uniforms.t2D.value = M,
        f.material.uniforms.backgroundIntensity.value = g.backgroundIntensity,
        f.material.toneMapped = Ut.getTransfer(M.colorSpace) !== Bt,
        M.matrixAutoUpdate === !0 && M.updateMatrix(),
        f.material.uniforms.uvTransform.value.copy(M.matrix),
        (d !== M || m !== M.version || v !== n.toneMapping) && (f.material.needsUpdate = !0,
        d = M,
        m = M.version,
        v = n.toneMapping),
        f.layers.enableAll(),
        x.unshift(f, f.geometry, f.material, 0, 0, null))
    }
    function w(x, g) {
        x.getRGB(rd, cC(n)),
        i.buffers.color.setClear(rd.r, rd.g, rd.b, g, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(x, g=1) {
            a.set(x),
            c = g,
            w(a, c)
        },
        getClearAlpha: function() {
            return c
        },
        setClearAlpha: function(x) {
            c = x,
            w(a, c)
        },
        render: _
    }
}
function hU(n, e, t, i) {
    const r = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , s = i.isWebGL2 ? null : e.get("OES_vertex_array_object")
      , o = i.isWebGL2 || s !== null
      , a = {}
      , c = x(null);
    let f = c
      , h = !1;
    function d(B, ie, J, ue, F) {
        let H = !1;
        if (o) {
            const V = w(ue, J, ie);
            f !== V && (f = V,
            v(f.object)),
            H = g(B, ue, J, F),
            H && S(B, ue, J, F)
        } else {
            const V = ie.wireframe === !0;
            (f.geometry !== ue.id || f.program !== J.id || f.wireframe !== V) && (f.geometry = ue.id,
            f.program = J.id,
            f.wireframe = V,
            H = !0)
        }
        F !== null && t.update(F, n.ELEMENT_ARRAY_BUFFER),
        (H || h) && (h = !1,
        N(B, ie, J, ue),
        F !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(F).buffer))
    }
    function m() {
        return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES()
    }
    function v(B) {
        return i.isWebGL2 ? n.bindVertexArray(B) : s.bindVertexArrayOES(B)
    }
    function _(B) {
        return i.isWebGL2 ? n.deleteVertexArray(B) : s.deleteVertexArrayOES(B)
    }
    function w(B, ie, J) {
        const ue = J.wireframe === !0;
        let F = a[B.id];
        F === void 0 && (F = {},
        a[B.id] = F);
        let H = F[ie.id];
        H === void 0 && (H = {},
        F[ie.id] = H);
        let V = H[ue];
        return V === void 0 && (V = x(m()),
        H[ue] = V),
        V
    }
    function x(B) {
        const ie = []
          , J = []
          , ue = [];
        for (let F = 0; F < r; F++)
            ie[F] = 0,
            J[F] = 0,
            ue[F] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: ie,
            enabledAttributes: J,
            attributeDivisors: ue,
            object: B,
            attributes: {},
            index: null
        }
    }
    function g(B, ie, J, ue) {
        const F = f.attributes
          , H = ie.attributes;
        let V = 0;
        const q = J.getAttributes();
        for (const ce in q)
            if (q[ce].location >= 0) {
                const Z = F[ce];
                let de = H[ce];
                if (de === void 0 && (ce === "instanceMatrix" && B.instanceMatrix && (de = B.instanceMatrix),
                ce === "instanceColor" && B.instanceColor && (de = B.instanceColor)),
                Z === void 0 || Z.attribute !== de || de && Z.data !== de.data)
                    return !0;
                V++
            }
        return f.attributesNum !== V || f.index !== ue
    }
    function S(B, ie, J, ue) {
        const F = {}
          , H = ie.attributes;
        let V = 0;
        const q = J.getAttributes();
        for (const ce in q)
            if (q[ce].location >= 0) {
                let Z = H[ce];
                Z === void 0 && (ce === "instanceMatrix" && B.instanceMatrix && (Z = B.instanceMatrix),
                ce === "instanceColor" && B.instanceColor && (Z = B.instanceColor));
                const de = {};
                de.attribute = Z,
                Z && Z.data && (de.data = Z.data),
                F[ce] = de,
                V++
            }
        f.attributes = F,
        f.attributesNum = V,
        f.index = ue
    }
    function M() {
        const B = f.newAttributes;
        for (let ie = 0, J = B.length; ie < J; ie++)
            B[ie] = 0
    }
    function T(B) {
        P(B, 0)
    }
    function P(B, ie) {
        const J = f.newAttributes
          , ue = f.enabledAttributes
          , F = f.attributeDivisors;
        J[B] = 1,
        ue[B] === 0 && (n.enableVertexAttribArray(B),
        ue[B] = 1),
        F[B] !== ie && ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](B, ie),
        F[B] = ie)
    }
    function R() {
        const B = f.newAttributes
          , ie = f.enabledAttributes;
        for (let J = 0, ue = ie.length; J < ue; J++)
            ie[J] !== B[J] && (n.disableVertexAttribArray(J),
            ie[J] = 0)
    }
    function b(B, ie, J, ue, F, H, V) {
        V === !0 ? n.vertexAttribIPointer(B, ie, J, F, H) : n.vertexAttribPointer(B, ie, J, ue, F, H)
    }
    function N(B, ie, J, ue) {
        if (i.isWebGL2 === !1 && (B.isInstancedMesh || ue.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
            return;
        M();
        const F = ue.attributes
          , H = J.getAttributes()
          , V = ie.defaultAttributeValues;
        for (const q in H) {
            const ce = H[q];
            if (ce.location >= 0) {
                let Ce = F[q];
                if (Ce === void 0 && (q === "instanceMatrix" && B.instanceMatrix && (Ce = B.instanceMatrix),
                q === "instanceColor" && B.instanceColor && (Ce = B.instanceColor)),
                Ce !== void 0) {
                    const Z = Ce.normalized
                      , de = Ce.itemSize
                      , Se = t.get(Ce);
                    if (Se === void 0)
                        continue;
                    const ke = Se.buffer
                      , Xe = Se.type
                      , ze = Se.bytesPerElement
                      , ut = i.isWebGL2 === !0 && (Xe === n.INT || Xe === n.UNSIGNED_INT || Ce.gpuType === D_);
                    if (Ce.isInterleavedBufferAttribute) {
                        const He = Ce.data
                          , z = He.stride
                          , ge = Ce.offset;
                        if (He.isInstancedInterleavedBuffer) {
                            for (let fe = 0; fe < ce.locationSize; fe++)
                                P(ce.location + fe, He.meshPerAttribute);
                            B.isInstancedMesh !== !0 && ue._maxInstanceCount === void 0 && (ue._maxInstanceCount = He.meshPerAttribute * He.count)
                        } else
                            for (let fe = 0; fe < ce.locationSize; fe++)
                                T(ce.location + fe);
                        n.bindBuffer(n.ARRAY_BUFFER, ke);
                        for (let fe = 0; fe < ce.locationSize; fe++)
                            b(ce.location + fe, de / ce.locationSize, Xe, Z, z * ze, (ge + de / ce.locationSize * fe) * ze, ut)
                    } else {
                        if (Ce.isInstancedBufferAttribute) {
                            for (let He = 0; He < ce.locationSize; He++)
                                P(ce.location + He, Ce.meshPerAttribute);
                            B.isInstancedMesh !== !0 && ue._maxInstanceCount === void 0 && (ue._maxInstanceCount = Ce.meshPerAttribute * Ce.count)
                        } else
                            for (let He = 0; He < ce.locationSize; He++)
                                T(ce.location + He);
                        n.bindBuffer(n.ARRAY_BUFFER, ke);
                        for (let He = 0; He < ce.locationSize; He++)
                            b(ce.location + He, de / ce.locationSize, Xe, Z, de * ze, de / ce.locationSize * He * ze, ut)
                    }
                } else if (V !== void 0) {
                    const Z = V[q];
                    if (Z !== void 0)
                        switch (Z.length) {
                        case 2:
                            n.vertexAttrib2fv(ce.location, Z);
                            break;
                        case 3:
                            n.vertexAttrib3fv(ce.location, Z);
                            break;
                        case 4:
                            n.vertexAttrib4fv(ce.location, Z);
                            break;
                        default:
                            n.vertexAttrib1fv(ce.location, Z)
                        }
                }
            }
        }
        R()
    }
    function G() {
        K();
        for (const B in a) {
            const ie = a[B];
            for (const J in ie) {
                const ue = ie[J];
                for (const F in ue)
                    _(ue[F].object),
                    delete ue[F];
                delete ie[J]
            }
            delete a[B]
        }
    }
    function C(B) {
        if (a[B.id] === void 0)
            return;
        const ie = a[B.id];
        for (const J in ie) {
            const ue = ie[J];
            for (const F in ue)
                _(ue[F].object),
                delete ue[F];
            delete ie[J]
        }
        delete a[B.id]
    }
    function I(B) {
        for (const ie in a) {
            const J = a[ie];
            if (J[B.id] === void 0)
                continue;
            const ue = J[B.id];
            for (const F in ue)
                _(ue[F].object),
                delete ue[F];
            delete J[B.id]
        }
    }
    function K() {
        se(),
        h = !0,
        f !== c && (f = c,
        v(f.object))
    }
    function se() {
        c.geometry = null,
        c.program = null,
        c.wireframe = !1
    }
    return {
        setup: d,
        reset: K,
        resetDefaultState: se,
        dispose: G,
        releaseStatesOfGeometry: C,
        releaseStatesOfProgram: I,
        initAttributes: M,
        enableAttribute: T,
        disableUnusedAttributes: R
    }
}
function dU(n, e, t, i) {
    const r = i.isWebGL2;
    let s;
    function o(h) {
        s = h
    }
    function a(h, d) {
        n.drawArrays(s, h, d),
        t.update(d, s, 1)
    }
    function c(h, d, m) {
        if (m === 0)
            return;
        let v, _;
        if (r)
            v = n,
            _ = "drawArraysInstanced";
        else if (v = e.get("ANGLE_instanced_arrays"),
        _ = "drawArraysInstancedANGLE",
        v === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        v[_](s, h, d, m),
        t.update(d, s, m)
    }
    function f(h, d, m) {
        if (m === 0)
            return;
        const v = e.get("WEBGL_multi_draw");
        if (v === null)
            for (let _ = 0; _ < m; _++)
                this.render(h[_], d[_]);
        else {
            v.multiDrawArraysWEBGL(s, h, 0, d, 0, m);
            let _ = 0;
            for (let w = 0; w < m; w++)
                _ += d[w];
            t.update(_, s, 1)
        }
    }
    this.setMode = o,
    this.render = a,
    this.renderInstances = c,
    this.renderMultiDraw = f
}
function pU(n, e, t) {
    let i;
    function r() {
        if (i !== void 0)
            return i;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const b = e.get("EXT_texture_filter_anisotropic");
            i = n.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            i = 0;
        return i
    }
    function s(b) {
        if (b === "highp") {
            if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0)
                return "highp";
            b = "mediump"
        }
        return b === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    const o = typeof WebGL2RenderingContext < "u" && n.constructor.name === "WebGL2RenderingContext";
    let a = t.precision !== void 0 ? t.precision : "highp";
    const c = s(a);
    c !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", c, "instead."),
    a = c);
    const f = o || e.has("WEBGL_draw_buffers")
      , h = t.logarithmicDepthBuffer === !0
      , d = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)
      , m = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , v = n.getParameter(n.MAX_TEXTURE_SIZE)
      , _ = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)
      , w = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , x = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)
      , g = n.getParameter(n.MAX_VARYING_VECTORS)
      , S = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)
      , M = m > 0
      , T = o || e.has("OES_texture_float")
      , P = M && T
      , R = o ? n.getParameter(n.MAX_SAMPLES) : 0;
    return {
        isWebGL2: o,
        drawBuffers: f,
        getMaxAnisotropy: r,
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: h,
        maxTextures: d,
        maxVertexTextures: m,
        maxTextureSize: v,
        maxCubemapSize: _,
        maxAttributes: w,
        maxVertexUniforms: x,
        maxVaryings: g,
        maxFragmentUniforms: S,
        vertexTextures: M,
        floatFragmentTextures: T,
        floatVertexTextures: P,
        maxSamples: R
    }
}
function mU(n) {
    const e = this;
    let t = null
      , i = 0
      , r = !1
      , s = !1;
    const o = new Zs
      , a = new mt
      , c = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = c,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(d, m) {
        const v = d.length !== 0 || m || i !== 0 || r;
        return r = m,
        i = d.length,
        v
    }
    ,
    this.beginShadows = function() {
        s = !0,
        h(null)
    }
    ,
    this.endShadows = function() {
        s = !1
    }
    ,
    this.setGlobalState = function(d, m) {
        t = h(d, m, 0)
    }
    ,
    this.setState = function(d, m, v) {
        const _ = d.clippingPlanes
          , w = d.clipIntersection
          , x = d.clipShadows
          , g = n.get(d);
        if (!r || _ === null || _.length === 0 || s && !x)
            s ? h(null) : f();
        else {
            const S = s ? 0 : i
              , M = S * 4;
            let T = g.clippingState || null;
            c.value = T,
            T = h(_, m, M, v);
            for (let P = 0; P !== M; ++P)
                T[P] = t[P];
            g.clippingState = T,
            this.numIntersection = w ? this.numPlanes : 0,
            this.numPlanes += S
        }
    }
    ;
    function f() {
        c.value !== t && (c.value = t,
        c.needsUpdate = i > 0),
        e.numPlanes = i,
        e.numIntersection = 0
    }
    function h(d, m, v, _) {
        const w = d !== null ? d.length : 0;
        let x = null;
        if (w !== 0) {
            if (x = c.value,
            _ !== !0 || x === null) {
                const g = v + w * 4
                  , S = m.matrixWorldInverse;
                a.getNormalMatrix(S),
                (x === null || x.length < g) && (x = new Float32Array(g));
                for (let M = 0, T = v; M !== w; ++M,
                T += 4)
                    o.copy(d[M]).applyMatrix4(S, a),
                    o.normal.toArray(x, T),
                    x[T + 3] = o.constant
            }
            c.value = x,
            c.needsUpdate = !0
        }
        return e.numPlanes = w,
        e.numIntersection = 0,
        x
    }
}
function gU(n) {
    let e = new WeakMap;
    function t(o, a) {
        return a === Vc ? o.mapping = Ts : a === Gc && (o.mapping = mo),
        o
    }
    function i(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === Vc || a === Gc)
                if (e.has(o)) {
                    const c = e.get(o).texture;
                    return t(c, o.mapping)
                } else {
                    const c = o.image;
                    if (c && c.height > 0) {
                        const f = new hC(c.height);
                        return f.fromEquirectangularTexture(n, o),
                        e.set(o, f),
                        o.addEventListener("dispose", r),
                        t(f.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function r(o) {
        const a = o.target;
        a.removeEventListener("dispose", r);
        const c = e.get(a);
        c !== void 0 && (e.delete(a),
        c.dispose())
    }
    function s() {
        e = new WeakMap
    }
    return {
        get: i,
        dispose: s
    }
}
class xf extends vf {
    constructor(e=-1, t=1, i=1, r=-1, s=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = i,
        this.bottom = r,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, i, r, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , i = (this.right + this.left) / 2
          , r = (this.top + this.bottom) / 2;
        let s = i - e
          , o = i + e
          , a = r + t
          , c = r - t;
        if (this.view !== null && this.view.enabled) {
            const f = (this.right - this.left) / this.view.fullWidth / this.zoom
              , h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += f * this.view.offsetX,
            o = s + f * this.view.width,
            a -= h * this.view.offsetY,
            c = a - h * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, c, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const Pl = 4
  , NM = [.125, .215, .35, .446, .526, .582]
  , Ko = 20
  , S0 = new xf
  , DM = new Ne;
let M0 = null
  , w0 = 0
  , E0 = 0;
const Zo = (1 + Math.sqrt(5)) / 2
  , rl = 1 / Zo
  , UM = [new U(1,1,1), new U(-1,1,1), new U(1,1,-1), new U(-1,1,-1), new U(0,Zo,rl), new U(0,Zo,-rl), new U(rl,0,Zo), new U(-rl,0,Zo), new U(Zo,rl,0), new U(-Zo,rl,0)];
class Ty {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, i=.1, r=100) {
        M0 = this._renderer.getRenderTarget(),
        w0 = this._renderer.getActiveCubeFace(),
        E0 = this._renderer.getActiveMipmapLevel(),
        this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0,
        this._sceneToCubeUV(e, i, r, s),
        t > 0 && this._blur(s, 0, 0, t),
        this._applyPMREM(s),
        this._cleanup(s),
        s
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = kM(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = FM(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(M0, w0, E0),
        e.scissorTest = !1,
        sd(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === Ts || e.mapping === mo ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        M0 = this._renderer.getRenderTarget(),
        w0 = this._renderer.getActiveCubeFace(),
        E0 = this._renderer.getActiveMipmapLevel();
        const i = t || this._allocateTargets();
        return this._textureToCubeUV(e, i),
        this._applyPMREM(i),
        this._cleanup(i),
        i
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , i = {
            magFilter: Wt,
            minFilter: Wt,
            generateMipmaps: !1,
            type: va,
            format: ci,
            colorSpace: Cs,
            depthBuffer: !1
        }
          , r = OM(e, t, i);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = OM(e, t, i);
            const {_lodMax: s} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = vU(s)),
            this._blurMaterial = yU(s, e, t)
        }
        return r
    }
    _compileMaterial(e) {
        const t = new _n(this._lodPlanes[0],e);
        this._renderer.compile(t, S0)
    }
    _sceneToCubeUV(e, t, i, r) {
        const a = new Dn(90,1,t,i)
          , c = [1, -1, 1, 1, 1, 1]
          , f = [1, 1, 1, -1, -1, -1]
          , h = this._renderer
          , d = h.autoClear
          , m = h.toneMapping;
        h.getClearColor(DM),
        h.toneMapping = Ar,
        h.autoClear = !1;
        const v = new So({
            name: "PMREM.Background",
            side: ti,
            depthWrite: !1,
            depthTest: !1
        })
          , _ = new _n(new wa,v);
        let w = !1;
        const x = e.background;
        x ? x.isColor && (v.color.copy(x),
        e.background = null,
        w = !0) : (v.color.copy(DM),
        w = !0);
        for (let g = 0; g < 6; g++) {
            const S = g % 3;
            S === 0 ? (a.up.set(0, c[g], 0),
            a.lookAt(f[g], 0, 0)) : S === 1 ? (a.up.set(0, 0, c[g]),
            a.lookAt(0, f[g], 0)) : (a.up.set(0, c[g], 0),
            a.lookAt(0, 0, f[g]));
            const M = this._cubeSize;
            sd(r, S * M, g > 2 ? M : 0, M, M),
            h.setRenderTarget(r),
            w && h.render(_, a),
            h.render(e, a)
        }
        _.geometry.dispose(),
        _.material.dispose(),
        h.toneMapping = m,
        h.autoClear = d,
        e.background = x
    }
    _textureToCubeUV(e, t) {
        const i = this._renderer
          , r = e.mapping === Ts || e.mapping === mo;
        r ? (this._cubemapMaterial === null && (this._cubemapMaterial = kM()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = FM());
        const s = r ? this._cubemapMaterial : this._equirectMaterial
          , o = new _n(this._lodPlanes[0],s)
          , a = s.uniforms;
        a.envMap.value = e;
        const c = this._cubeSize;
        sd(t, 0, 0, 3 * c, 2 * c),
        i.setRenderTarget(t),
        i.render(o, S0)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , i = t.autoClear;
        t.autoClear = !1;
        for (let r = 1; r < this._lodPlanes.length; r++) {
            const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1])
              , o = UM[(r - 1) % UM.length];
            this._blur(e, r - 1, r, s, o)
        }
        t.autoClear = i
    }
    _blur(e, t, i, r, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, i, r, "latitudinal", s),
        this._halfBlur(o, e, i, i, r, "longitudinal", s)
    }
    _halfBlur(e, t, i, r, s, o, a) {
        const c = this._renderer
          , f = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const h = 3
          , d = new _n(this._lodPlanes[r],f)
          , m = f.uniforms
          , v = this._sizeLods[i] - 1
          , _ = isFinite(s) ? Math.PI / (2 * v) : 2 * Math.PI / (2 * Ko - 1)
          , w = s / _
          , x = isFinite(s) ? 1 + Math.floor(h * w) : Ko;
        x > Ko && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${Ko}`);
        const g = [];
        let S = 0;
        for (let b = 0; b < Ko; ++b) {
            const N = b / w
              , G = Math.exp(-N * N / 2);
            g.push(G),
            b === 0 ? S += G : b < x && (S += 2 * G)
        }
        for (let b = 0; b < g.length; b++)
            g[b] = g[b] / S;
        m.envMap.value = e.texture,
        m.samples.value = x,
        m.weights.value = g,
        m.latitudinal.value = o === "latitudinal",
        a && (m.poleAxis.value = a);
        const {_lodMax: M} = this;
        m.dTheta.value = _,
        m.mipInt.value = M - i;
        const T = this._sizeLods[r]
          , P = 3 * T * (r > M - Pl ? r - M + Pl : 0)
          , R = 4 * (this._cubeSize - T);
        sd(t, P, R, 3 * T, 2 * T),
        c.setRenderTarget(t),
        c.render(d, S0)
    }
}
function vU(n) {
    const e = []
      , t = []
      , i = [];
    let r = n;
    const s = n - Pl + 1 + NM.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, r);
        t.push(a);
        let c = 1 / a;
        o > n - Pl ? c = NM[o - n + Pl - 1] : o === 0 && (c = 0),
        i.push(c);
        const f = 1 / (a - 2)
          , h = -f
          , d = 1 + f
          , m = [h, h, d, h, d, d, h, h, d, d, h, d]
          , v = 6
          , _ = 6
          , w = 3
          , x = 2
          , g = 1
          , S = new Float32Array(w * _ * v)
          , M = new Float32Array(x * _ * v)
          , T = new Float32Array(g * _ * v);
        for (let R = 0; R < v; R++) {
            const b = R % 3 * 2 / 3 - 1
              , N = R > 2 ? 0 : -1
              , G = [b, N, 0, b + 2 / 3, N, 0, b + 2 / 3, N + 1, 0, b, N, 0, b + 2 / 3, N + 1, 0, b, N + 1, 0];
            S.set(G, w * _ * R),
            M.set(m, x * _ * R);
            const C = [R, R, R, R, R, R];
            T.set(C, g * _ * R)
        }
        const P = new _t;
        P.setAttribute("position", new Nt(S,w)),
        P.setAttribute("uv", new Nt(M,x)),
        P.setAttribute("faceIndex", new Nt(T,g)),
        e.push(P),
        r > Pl && r--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: i
    }
}
function OM(n, e, t) {
    const i = new cr(n,e,t);
    return i.texture.mapping = ru,
    i.texture.name = "PMREM.cubeUv",
    i.scissorTest = !0,
    i
}
function sd(n, e, t, i, r) {
    n.viewport.set(e, t, i, r),
    n.scissor.set(e, t, i, r)
}
function yU(n, e, t) {
    const i = new Float32Array(Ko)
      , r = new U(0,1,0);
    return new fr({
        name: "SphericalGaussianBlur",
        defines: {
            n: Ko,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: i
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: r
            }
        },
        vertexShader: J_(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: xs,
        depthTest: !1,
        depthWrite: !1
    })
}
function FM() {
    return new fr({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: J_(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: xs,
        depthTest: !1,
        depthWrite: !1
    })
}
function kM() {
    return new fr({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: J_(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: xs,
        depthTest: !1,
        depthWrite: !1
    })
}
function J_() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function _U(n) {
    let e = new WeakMap
      , t = null;
    function i(a) {
        if (a && a.isTexture) {
            const c = a.mapping
              , f = c === Vc || c === Gc
              , h = c === Ts || c === mo;
            if (f || h)
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                    a.needsPMREMUpdate = !1;
                    let d = e.get(a);
                    return t === null && (t = new Ty(n)),
                    d = f ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d),
                    e.set(a, d),
                    d.texture
                } else {
                    if (e.has(a))
                        return e.get(a).texture;
                    {
                        const d = a.image;
                        if (f && d && d.height > 0 || h && d && r(d)) {
                            t === null && (t = new Ty(n));
                            const m = f ? t.fromEquirectangular(a) : t.fromCubemap(a);
                            return e.set(a, m),
                            a.addEventListener("dispose", s),
                            m.texture
                        } else
                            return null
                    }
                }
        }
        return a
    }
    function r(a) {
        let c = 0;
        const f = 6;
        for (let h = 0; h < f; h++)
            a[h] !== void 0 && c++;
        return c === f
    }
    function s(a) {
        const c = a.target;
        c.removeEventListener("dispose", s);
        const f = e.get(c);
        f !== void 0 && (e.delete(c),
        f.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: i,
        dispose: o
    }
}
function xU(n) {
    const e = {};
    function t(i) {
        if (e[i] !== void 0)
            return e[i];
        let r;
        switch (i) {
        case "WEBGL_depth_texture":
            r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            r = n.getExtension(i)
        }
        return e[i] = r,
        r
    }
    return {
        has: function(i) {
            return t(i) !== null
        },
        init: function(i) {
            i.isWebGL2 ? (t("EXT_color_buffer_float"),
            t("WEBGL_clip_cull_distance")) : (t("WEBGL_depth_texture"),
            t("OES_texture_float"),
            t("OES_texture_half_float"),
            t("OES_texture_half_float_linear"),
            t("OES_standard_derivatives"),
            t("OES_element_index_uint"),
            t("OES_vertex_array_object"),
            t("ANGLE_instanced_arrays")),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture")
        },
        get: function(i) {
            const r = t(i);
            return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."),
            r
        }
    }
}
function SU(n, e, t, i) {
    const r = {}
      , s = new WeakMap;
    function o(d) {
        const m = d.target;
        m.index !== null && e.remove(m.index);
        for (const _ in m.attributes)
            e.remove(m.attributes[_]);
        for (const _ in m.morphAttributes) {
            const w = m.morphAttributes[_];
            for (let x = 0, g = w.length; x < g; x++)
                e.remove(w[x])
        }
        m.removeEventListener("dispose", o),
        delete r[m.id];
        const v = s.get(m);
        v && (e.remove(v),
        s.delete(m)),
        i.releaseStatesOfGeometry(m),
        m.isInstancedBufferGeometry === !0 && delete m._maxInstanceCount,
        t.memory.geometries--
    }
    function a(d, m) {
        return r[m.id] === !0 || (m.addEventListener("dispose", o),
        r[m.id] = !0,
        t.memory.geometries++),
        m
    }
    function c(d) {
        const m = d.attributes;
        for (const _ in m)
            e.update(m[_], n.ARRAY_BUFFER);
        const v = d.morphAttributes;
        for (const _ in v) {
            const w = v[_];
            for (let x = 0, g = w.length; x < g; x++)
                e.update(w[x], n.ARRAY_BUFFER)
        }
    }
    function f(d) {
        const m = []
          , v = d.index
          , _ = d.attributes.position;
        let w = 0;
        if (v !== null) {
            const S = v.array;
            w = v.version;
            for (let M = 0, T = S.length; M < T; M += 3) {
                const P = S[M + 0]
                  , R = S[M + 1]
                  , b = S[M + 2];
                m.push(P, R, R, b, b, P)
            }
        } else if (_ !== void 0) {
            const S = _.array;
            w = _.version;
            for (let M = 0, T = S.length / 3 - 1; M < T; M += 3) {
                const P = M + 0
                  , R = M + 1
                  , b = M + 2;
                m.push(P, R, R, b, b, P)
            }
        } else
            return;
        const x = new (sC(m) ? q_ : j_)(m,1);
        x.version = w;
        const g = s.get(d);
        g && e.remove(g),
        s.set(d, x)
    }
    function h(d) {
        const m = s.get(d);
        if (m) {
            const v = d.index;
            v !== null && m.version < v.version && f(d)
        } else
            f(d);
        return s.get(d)
    }
    return {
        get: a,
        update: c,
        getWireframeAttribute: h
    }
}
function MU(n, e, t, i) {
    const r = i.isWebGL2;
    let s;
    function o(v) {
        s = v
    }
    let a, c;
    function f(v) {
        a = v.type,
        c = v.bytesPerElement
    }
    function h(v, _) {
        n.drawElements(s, _, a, v * c),
        t.update(_, s, 1)
    }
    function d(v, _, w) {
        if (w === 0)
            return;
        let x, g;
        if (r)
            x = n,
            g = "drawElementsInstanced";
        else if (x = e.get("ANGLE_instanced_arrays"),
        g = "drawElementsInstancedANGLE",
        x === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        x[g](s, _, a, v * c, w),
        t.update(_, s, w)
    }
    function m(v, _, w) {
        if (w === 0)
            return;
        const x = e.get("WEBGL_multi_draw");
        if (x === null)
            for (let g = 0; g < w; g++)
                this.render(v[g] / c, _[g]);
        else {
            x.multiDrawElementsWEBGL(s, _, 0, a, v, 0, w);
            let g = 0;
            for (let S = 0; S < w; S++)
                g += _[S];
            t.update(g, s, 1)
        }
    }
    this.setMode = o,
    this.setIndex = f,
    this.render = h,
    this.renderInstances = d,
    this.renderMultiDraw = m
}
function wU(n) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function i(s, o, a) {
        switch (t.calls++,
        o) {
        case n.TRIANGLES:
            t.triangles += a * (s / 3);
            break;
        case n.LINES:
            t.lines += a * (s / 2);
            break;
        case n.LINE_STRIP:
            t.lines += a * (s - 1);
            break;
        case n.LINE_LOOP:
            t.lines += a * s;
            break;
        case n.POINTS:
            t.points += a * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function r() {
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: r,
        update: i
    }
}
function EU(n, e) {
    return n[0] - e[0]
}
function TU(n, e) {
    return Math.abs(e[1]) - Math.abs(n[1])
}
function AU(n, e, t) {
    const i = {}
      , r = new Float32Array(8)
      , s = new WeakMap
      , o = new Ct
      , a = [];
    for (let f = 0; f < 8; f++)
        a[f] = [f, 0];
    function c(f, h, d) {
        const m = f.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            const _ = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color
              , w = _ !== void 0 ? _.length : 0;
            let x = s.get(h);
            if (x === void 0 || x.count !== w) {
                let se = function() {
                    I.dispose(),
                    s.delete(h),
                    h.removeEventListener("dispose", se)
                };
                var v = se;
                x !== void 0 && x.texture.dispose();
                const g = h.morphAttributes.position !== void 0
                  , S = h.morphAttributes.normal !== void 0
                  , M = h.morphAttributes.color !== void 0
                  , T = h.morphAttributes.position || []
                  , P = h.morphAttributes.normal || []
                  , R = h.morphAttributes.color || [];
                let b = 0;
                g === !0 && (b = 1),
                S === !0 && (b = 2),
                M === !0 && (b = 3);
                let N = h.attributes.position.count * b
                  , G = 1;
                N > e.maxTextureSize && (G = Math.ceil(N / e.maxTextureSize),
                N = e.maxTextureSize);
                const C = new Float32Array(N * G * 4 * w)
                  , I = new tm(C,N,G,w);
                I.type = wi,
                I.needsUpdate = !0;
                const K = b * 4;
                for (let B = 0; B < w; B++) {
                    const ie = T[B]
                      , J = P[B]
                      , ue = R[B]
                      , F = N * G * 4 * B;
                    for (let H = 0; H < ie.count; H++) {
                        const V = H * K;
                        g === !0 && (o.fromBufferAttribute(ie, H),
                        C[F + V + 0] = o.x,
                        C[F + V + 1] = o.y,
                        C[F + V + 2] = o.z,
                        C[F + V + 3] = 0),
                        S === !0 && (o.fromBufferAttribute(J, H),
                        C[F + V + 4] = o.x,
                        C[F + V + 5] = o.y,
                        C[F + V + 6] = o.z,
                        C[F + V + 7] = 0),
                        M === !0 && (o.fromBufferAttribute(ue, H),
                        C[F + V + 8] = o.x,
                        C[F + V + 9] = o.y,
                        C[F + V + 10] = o.z,
                        C[F + V + 11] = ue.itemSize === 4 ? o.w : 1)
                    }
                }
                x = {
                    count: w,
                    texture: I,
                    size: new he(N,G)
                },
                s.set(h, x),
                h.addEventListener("dispose", se)
            }
            if (f.isInstancedMesh === !0 && f.morphTexture !== null)
                d.getUniforms().setValue(n, "morphTexture", f.morphTexture, t);
            else {
                let g = 0;
                for (let M = 0; M < m.length; M++)
                    g += m[M];
                const S = h.morphTargetsRelative ? 1 : 1 - g;
                d.getUniforms().setValue(n, "morphTargetBaseInfluence", S),
                d.getUniforms().setValue(n, "morphTargetInfluences", m)
            }
            d.getUniforms().setValue(n, "morphTargetsTexture", x.texture, t),
            d.getUniforms().setValue(n, "morphTargetsTextureSize", x.size)
        } else {
            const _ = m === void 0 ? 0 : m.length;
            let w = i[h.id];
            if (w === void 0 || w.length !== _) {
                w = [];
                for (let T = 0; T < _; T++)
                    w[T] = [T, 0];
                i[h.id] = w
            }
            for (let T = 0; T < _; T++) {
                const P = w[T];
                P[0] = T,
                P[1] = m[T]
            }
            w.sort(TU);
            for (let T = 0; T < 8; T++)
                T < _ && w[T][1] ? (a[T][0] = w[T][0],
                a[T][1] = w[T][1]) : (a[T][0] = Number.MAX_SAFE_INTEGER,
                a[T][1] = 0);
            a.sort(EU);
            const x = h.morphAttributes.position
              , g = h.morphAttributes.normal;
            let S = 0;
            for (let T = 0; T < 8; T++) {
                const P = a[T]
                  , R = P[0]
                  , b = P[1];
                R !== Number.MAX_SAFE_INTEGER && b ? (x && h.getAttribute("morphTarget" + T) !== x[R] && h.setAttribute("morphTarget" + T, x[R]),
                g && h.getAttribute("morphNormal" + T) !== g[R] && h.setAttribute("morphNormal" + T, g[R]),
                r[T] = b,
                S += b) : (x && h.hasAttribute("morphTarget" + T) === !0 && h.deleteAttribute("morphTarget" + T),
                g && h.hasAttribute("morphNormal" + T) === !0 && h.deleteAttribute("morphNormal" + T),
                r[T] = 0)
            }
            const M = h.morphTargetsRelative ? 1 : 1 - S;
            d.getUniforms().setValue(n, "morphTargetBaseInfluence", M),
            d.getUniforms().setValue(n, "morphTargetInfluences", r)
        }
    }
    return {
        update: c
    }
}
function CU(n, e, t, i) {
    let r = new WeakMap;
    function s(c) {
        const f = i.render.frame
          , h = c.geometry
          , d = e.get(c, h);
        if (r.get(d) !== f && (e.update(d),
        r.set(d, f)),
        c.isInstancedMesh && (c.hasEventListener("dispose", a) === !1 && c.addEventListener("dispose", a),
        r.get(c) !== f && (t.update(c.instanceMatrix, n.ARRAY_BUFFER),
        c.instanceColor !== null && t.update(c.instanceColor, n.ARRAY_BUFFER),
        r.set(c, f))),
        c.isSkinnedMesh) {
            const m = c.skeleton;
            r.get(m) !== f && (m.update(),
            r.set(m, f))
        }
        return d
    }
    function o() {
        r = new WeakMap
    }
    function a(c) {
        const f = c.target;
        f.removeEventListener("dispose", a),
        t.remove(f.instanceMatrix),
        f.instanceColor !== null && t.remove(f.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
class nm extends en {
    constructor(e, t, i, r, s, o, a, c, f, h) {
        if (h = h !== void 0 ? h : co,
        h !== co && h !== ya)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        i === void 0 && h === co && (i = vs),
        i === void 0 && h === ya && (i = uo),
        super(null, r, s, o, a, c, h, i, f),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = a !== void 0 ? a : hn,
        this.minFilter = c !== void 0 ? c : hn,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
        t
    }
}
const pC = new en
  , mC = new nm(1,1);
mC.compareFunction = G_;
const gC = new tm
  , vC = new Y_
  , yC = new yf
  , zM = []
  , BM = []
  , HM = new Float32Array(16)
  , VM = new Float32Array(9)
  , GM = new Float32Array(4);
function au(n, e, t) {
    const i = n[0];
    if (i <= 0 || i > 0)
        return n;
    const r = e * t;
    let s = zM[r];
    if (s === void 0 && (s = new Float32Array(r),
    zM[r] = s),
    e !== 0) {
        i.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += t,
            n[o].toArray(s, a)
    }
    return s
}
function Tn(n, e) {
    if (n.length !== e.length)
        return !1;
    for (let t = 0, i = n.length; t < i; t++)
        if (n[t] !== e[t])
            return !1;
    return !0
}
function An(n, e) {
    for (let t = 0, i = e.length; t < i; t++)
        n[t] = e[t]
}
function im(n, e) {
    let t = BM[e];
    t === void 0 && (t = new Int32Array(e),
    BM[e] = t);
    for (let i = 0; i !== e; ++i)
        t[i] = n.allocateTextureUnit();
    return t
}
function RU(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e),
    t[0] = e)
}
function bU(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Tn(t, e))
            return;
        n.uniform2fv(this.addr, e),
        An(t, e)
    }
}
function PU(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (Tn(t, e))
            return;
        n.uniform3fv(this.addr, e),
        An(t, e)
    }
}
function LU(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Tn(t, e))
            return;
        n.uniform4fv(this.addr, e),
        An(t, e)
    }
}
function IU(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Tn(t, e))
            return;
        n.uniformMatrix2fv(this.addr, !1, e),
        An(t, e)
    } else {
        if (Tn(t, i))
            return;
        GM.set(i),
        n.uniformMatrix2fv(this.addr, !1, GM),
        An(t, i)
    }
}
function NU(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Tn(t, e))
            return;
        n.uniformMatrix3fv(this.addr, !1, e),
        An(t, e)
    } else {
        if (Tn(t, i))
            return;
        VM.set(i),
        n.uniformMatrix3fv(this.addr, !1, VM),
        An(t, i)
    }
}
function DU(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Tn(t, e))
            return;
        n.uniformMatrix4fv(this.addr, !1, e),
        An(t, e)
    } else {
        if (Tn(t, i))
            return;
        HM.set(i),
        n.uniformMatrix4fv(this.addr, !1, HM),
        An(t, i)
    }
}
function UU(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e),
    t[0] = e)
}
function OU(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Tn(t, e))
            return;
        n.uniform2iv(this.addr, e),
        An(t, e)
    }
}
function FU(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Tn(t, e))
            return;
        n.uniform3iv(this.addr, e),
        An(t, e)
    }
}
function kU(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Tn(t, e))
            return;
        n.uniform4iv(this.addr, e),
        An(t, e)
    }
}
function zU(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e),
    t[0] = e)
}
function BU(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Tn(t, e))
            return;
        n.uniform2uiv(this.addr, e),
        An(t, e)
    }
}
function HU(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Tn(t, e))
            return;
        n.uniform3uiv(this.addr, e),
        An(t, e)
    }
}
function VU(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Tn(t, e))
            return;
        n.uniform4uiv(this.addr, e),
        An(t, e)
    }
}
function GU(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r);
    const s = this.type === n.SAMPLER_2D_SHADOW ? mC : pC;
    t.setTexture2D(e || s, r)
}
function WU(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture3D(e || vC, r)
}
function XU(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTextureCube(e || yC, r)
}
function YU(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture2DArray(e || gC, r)
}
function jU(n) {
    switch (n) {
    case 5126:
        return RU;
    case 35664:
        return bU;
    case 35665:
        return PU;
    case 35666:
        return LU;
    case 35674:
        return IU;
    case 35675:
        return NU;
    case 35676:
        return DU;
    case 5124:
    case 35670:
        return UU;
    case 35667:
    case 35671:
        return OU;
    case 35668:
    case 35672:
        return FU;
    case 35669:
    case 35673:
        return kU;
    case 5125:
        return zU;
    case 36294:
        return BU;
    case 36295:
        return HU;
    case 36296:
        return VU;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return GU;
    case 35679:
    case 36299:
    case 36307:
        return WU;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return XU;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return YU
    }
}
function qU(n, e) {
    n.uniform1fv(this.addr, e)
}
function ZU(n, e) {
    const t = au(e, this.size, 2);
    n.uniform2fv(this.addr, t)
}
function JU(n, e) {
    const t = au(e, this.size, 3);
    n.uniform3fv(this.addr, t)
}
function KU(n, e) {
    const t = au(e, this.size, 4);
    n.uniform4fv(this.addr, t)
}
function QU(n, e) {
    const t = au(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t)
}
function $U(n, e) {
    const t = au(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t)
}
function eO(n, e) {
    const t = au(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t)
}
function tO(n, e) {
    n.uniform1iv(this.addr, e)
}
function nO(n, e) {
    n.uniform2iv(this.addr, e)
}
function iO(n, e) {
    n.uniform3iv(this.addr, e)
}
function rO(n, e) {
    n.uniform4iv(this.addr, e)
}
function sO(n, e) {
    n.uniform1uiv(this.addr, e)
}
function oO(n, e) {
    n.uniform2uiv(this.addr, e)
}
function aO(n, e) {
    n.uniform3uiv(this.addr, e)
}
function lO(n, e) {
    n.uniform4uiv(this.addr, e)
}
function uO(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = im(t, r);
    Tn(i, s) || (n.uniform1iv(this.addr, s),
    An(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2D(e[o] || pC, s[o])
}
function cO(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = im(t, r);
    Tn(i, s) || (n.uniform1iv(this.addr, s),
    An(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture3D(e[o] || vC, s[o])
}
function fO(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = im(t, r);
    Tn(i, s) || (n.uniform1iv(this.addr, s),
    An(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTextureCube(e[o] || yC, s[o])
}
function hO(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = im(t, r);
    Tn(i, s) || (n.uniform1iv(this.addr, s),
    An(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2DArray(e[o] || gC, s[o])
}
function dO(n) {
    switch (n) {
    case 5126:
        return qU;
    case 35664:
        return ZU;
    case 35665:
        return JU;
    case 35666:
        return KU;
    case 35674:
        return QU;
    case 35675:
        return $U;
    case 35676:
        return eO;
    case 5124:
    case 35670:
        return tO;
    case 35667:
    case 35671:
        return nO;
    case 35668:
    case 35672:
        return iO;
    case 35669:
    case 35673:
        return rO;
    case 5125:
        return sO;
    case 36294:
        return oO;
    case 36295:
        return aO;
    case 36296:
        return lO;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return uO;
    case 35679:
    case 36299:
    case 36307:
        return cO;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return fO;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return hO
    }
}
class pO {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.type = t.type,
        this.setValue = jU(t.type)
    }
}
class mO {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.type = t.type,
        this.size = t.size,
        this.setValue = dO(t.type)
    }
}
class gO {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, i) {
        const r = this.seq;
        for (let s = 0, o = r.length; s !== o; ++s) {
            const a = r[s];
            a.setValue(e, t[a.id], i)
        }
    }
}
const T0 = /(\w+)(\])?(\[|\.)?/g;
function WM(n, e) {
    n.seq.push(e),
    n.map[e.id] = e
}
function vO(n, e, t) {
    const i = n.name
      , r = i.length;
    for (T0.lastIndex = 0; ; ) {
        const s = T0.exec(i)
          , o = T0.lastIndex;
        let a = s[1];
        const c = s[2] === "]"
          , f = s[3];
        if (c && (a = a | 0),
        f === void 0 || f === "[" && o + 2 === r) {
            WM(t, f === void 0 ? new pO(a,n,e) : new mO(a,n,e));
            break
        } else {
            let d = t.map[a];
            d === void 0 && (d = new gO(a),
            WM(t, d)),
            t = d
        }
    }
}
class Kd {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let r = 0; r < i; ++r) {
            const s = e.getActiveUniform(t, r)
              , o = e.getUniformLocation(t, s.name);
            vO(s, o, this)
        }
    }
    setValue(e, t, i, r) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, i, r)
    }
    setOptional(e, t, i) {
        const r = t[i];
        r !== void 0 && this.setValue(e, i, r)
    }
    static upload(e, t, i, r) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s]
              , c = i[a.id];
            c.needsUpdate !== !1 && a.setValue(e, c.value, r)
        }
    }
    static seqWithValue(e, t) {
        const i = [];
        for (let r = 0, s = e.length; r !== s; ++r) {
            const o = e[r];
            o.id in t && i.push(o)
        }
        return i
    }
}
function XM(n, e, t) {
    const i = n.createShader(e);
    return n.shaderSource(i, t),
    n.compileShader(i),
    i
}
const yO = 37297;
let _O = 0;
function xO(n, e) {
    const t = n.split(`
`)
      , i = []
      , r = Math.max(e - 6, 0)
      , s = Math.min(e + 6, t.length);
    for (let o = r; o < s; o++) {
        const a = o + 1;
        i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
    }
    return i.join(`
`)
}
function SO(n) {
    const e = Ut.getPrimaries(Ut.workingColorSpace)
      , t = Ut.getPrimaries(n);
    let i;
    switch (e === t ? i = "" : e === Kc && t === Jc ? i = "LinearDisplayP3ToLinearSRGB" : e === Jc && t === Kc && (i = "LinearSRGBToLinearDisplayP3"),
    n) {
    case Cs:
    case gf:
        return [i, "LinearTransferOETF"];
    case Fi:
    case em:
        return [i, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        [i, "LinearTransferOETF"]
    }
}
function YM(n, e, t) {
    const i = n.getShaderParameter(e, n.COMPILE_STATUS)
      , r = n.getShaderInfoLog(e).trim();
    if (i && r === "")
        return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + `

` + r + `

` + xO(n.getShaderSource(e), o)
    } else
        return r
}
function MO(n, e) {
    const t = SO(e);
    return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`
}
function wO(n, e) {
    let t;
    switch (e) {
    case L2:
        t = "Linear";
        break;
    case I2:
        t = "Reinhard";
        break;
    case N2:
        t = "OptimizedCineon";
        break;
    case Jp:
        t = "ACESFilmic";
        break;
    case U2:
        t = "AgX";
        break;
    case O2:
        t = "Neutral";
        break;
    case D2:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
function EO(n) {
    return [n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.normalMapTangentSpace || n.clearcoatNormalMap || n.flatShading || n.alphaToCoverage || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ll).join(`
`)
}
function TO(n) {
    return [n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Ll).join(`
`)
}
function AO(n) {
    const e = [];
    for (const t in n) {
        const i = n[t];
        i !== !1 && e.push("#define " + t + " " + i)
    }
    return e.join(`
`)
}
function CO(n, e) {
    const t = {}
      , i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
    for (let r = 0; r < i; r++) {
        const s = n.getActiveAttrib(e, r)
          , o = s.name;
        let a = 1;
        s.type === n.FLOAT_MAT2 && (a = 2),
        s.type === n.FLOAT_MAT3 && (a = 3),
        s.type === n.FLOAT_MAT4 && (a = 4),
        t[o] = {
            type: s.type,
            location: n.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}
function Ll(n) {
    return n !== ""
}
function jM(n, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function qM(n, e) {
    return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const RO = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Ay(n) {
    return n.replace(RO, PO)
}
const bO = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);
function PO(n, e) {
    let t = yt[e];
    if (t === void 0) {
        const i = bO.get(e);
        if (i !== void 0)
            t = yt[i],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return Ay(t)
}
const LO = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function ZM(n) {
    return n.replace(LO, IO)
}
function IO(n, e, t, i) {
    let r = "";
    for (let s = parseInt(e); s < parseInt(t); s++)
        r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return r
}
function JM(n) {
    let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	`;
    return n.isWebGL2 && (e += `precision ${n.precision} sampler3D;
		precision ${n.precision} sampler2DArray;
		precision ${n.precision} sampler2DShadow;
		precision ${n.precision} samplerCubeShadow;
		precision ${n.precision} sampler2DArrayShadow;
		precision ${n.precision} isampler2D;
		precision ${n.precision} isampler3D;
		precision ${n.precision} isamplerCube;
		precision ${n.precision} isampler2DArray;
		precision ${n.precision} usampler2D;
		precision ${n.precision} usampler3D;
		precision ${n.precision} usamplerCube;
		precision ${n.precision} usampler2DArray;
		`),
    n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function NO(n) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return n.shadowMapType === Zp ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === yc ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === xr && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function DO(n) {
    let e = "ENVMAP_TYPE_CUBE";
    if (n.envMap)
        switch (n.envMapMode) {
        case Ts:
        case mo:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case ru:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function UO(n) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (n.envMap)
        switch (n.envMapMode) {
        case mo:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function OO(n) {
    let e = "ENVMAP_BLENDING_NONE";
    if (n.envMap)
        switch (n.combine) {
        case mf:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case b2:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case P2:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function FO(n) {
    const e = n.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , i = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: i,
        maxMip: t
    }
}
function kO(n, e, t, i) {
    const r = n.getContext()
      , s = t.defines;
    let o = t.vertexShader
      , a = t.fragmentShader;
    const c = NO(t)
      , f = DO(t)
      , h = UO(t)
      , d = OO(t)
      , m = FO(t)
      , v = t.isWebGL2 ? "" : EO(t)
      , _ = TO(t)
      , w = AO(s)
      , x = r.createProgram();
    let g, S, M = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, w].filter(Ll).join(`
`),
    g.length > 0 && (g += `
`),
    S = [v, "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, w].filter(Ll).join(`
`),
    S.length > 0 && (S += `
`)) : (g = [JM(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, w, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + c : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Ll).join(`
`),
    S = [v, JM(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, w, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + f : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + d : "", m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "", m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "", m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + c : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Ar ? "#define TONE_MAPPING" : "", t.toneMapping !== Ar ? yt.tonemapping_pars_fragment : "", t.toneMapping !== Ar ? wO("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", yt.colorspace_pars_fragment, MO("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Ll).join(`
`)),
    o = Ay(o),
    o = jM(o, t),
    o = qM(o, t),
    a = Ay(a),
    a = jM(a, t),
    a = qM(a, t),
    o = ZM(o),
    a = ZM(a),
    t.isWebGL2 && t.isRawShaderMaterial !== !0 && (M = `#version 300 es
`,
    g = [_, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + g,
    S = ["precision mediump sampler2DArray;", "#define varying in", t.glslVersion === wy ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === wy ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + S);
    const T = M + g + o
      , P = M + S + a
      , R = XM(r, r.VERTEX_SHADER, T)
      , b = XM(r, r.FRAGMENT_SHADER, P);
    r.attachShader(x, R),
    r.attachShader(x, b),
    t.index0AttributeName !== void 0 ? r.bindAttribLocation(x, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(x, 0, "position"),
    r.linkProgram(x);
    function N(K) {
        if (n.debug.checkShaderErrors) {
            const se = r.getProgramInfoLog(x).trim()
              , B = r.getShaderInfoLog(R).trim()
              , ie = r.getShaderInfoLog(b).trim();
            let J = !0
              , ue = !0;
            if (r.getProgramParameter(x, r.LINK_STATUS) === !1)
                if (J = !1,
                typeof n.debug.onShaderError == "function")
                    n.debug.onShaderError(r, x, R, b);
                else {
                    const F = YM(r, R, "vertex")
                      , H = YM(r, b, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(x, r.VALIDATE_STATUS) + `

Material Name: ` + K.name + `
Material Type: ` + K.type + `

Program Info Log: ` + se + `
` + F + `
` + H)
                }
            else
                se !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", se) : (B === "" || ie === "") && (ue = !1);
            ue && (K.diagnostics = {
                runnable: J,
                programLog: se,
                vertexShader: {
                    log: B,
                    prefix: g
                },
                fragmentShader: {
                    log: ie,
                    prefix: S
                }
            })
        }
        r.deleteShader(R),
        r.deleteShader(b),
        G = new Kd(r,x),
        C = CO(r, x)
    }
    let G;
    this.getUniforms = function() {
        return G === void 0 && N(this),
        G
    }
    ;
    let C;
    this.getAttributes = function() {
        return C === void 0 && N(this),
        C
    }
    ;
    let I = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return I === !1 && (I = r.getProgramParameter(x, yO)),
        I
    }
    ,
    this.destroy = function() {
        i.releaseStatesOfProgram(this),
        r.deleteProgram(x),
        this.program = void 0
    }
    ,
    this.type = t.shaderType,
    this.name = t.shaderName,
    this.id = _O++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = x,
    this.vertexShader = R,
    this.fragmentShader = b,
    this
}
let zO = 0;
class BO {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , i = e.fragmentShader
          , r = this._getShaderStage(t)
          , s = this._getShaderStage(i)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(r) === !1 && (o.add(r),
        r.usedTimes++),
        o.has(s) === !1 && (o.add(s),
        s.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const i of t)
            i.usedTimes--,
            i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let i = t.get(e);
        return i === void 0 && (i = new Set,
        t.set(e, i)),
        i
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let i = t.get(e);
        return i === void 0 && (i = new HO(e),
        t.set(e, i)),
        i
    }
}
class HO {
    constructor(e) {
        this.id = zO++,
        this.code = e,
        this.usedTimes = 0
    }
}
function VO(n, e, t, i, r, s, o) {
    const a = new ca
      , c = new BO
      , f = new Set
      , h = []
      , d = r.isWebGL2
      , m = r.logarithmicDepthBuffer
      , v = r.vertexTextures;
    let _ = r.precision;
    const w = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function x(C) {
        return f.add(C),
        C === 0 ? "uv" : `uv${C}`
    }
    function g(C, I, K, se, B) {
        const ie = se.fog
          , J = B.geometry
          , ue = C.isMeshStandardMaterial ? se.environment : null
          , F = (C.isMeshStandardMaterial ? t : e).get(C.envMap || ue)
          , H = F && F.mapping === ru ? F.image.height : null
          , V = w[C.type];
        C.precision !== null && (_ = r.getMaxPrecision(C.precision),
        _ !== C.precision && console.warn("THREE.WebGLProgram.getParameters:", C.precision, "not supported, using", _, "instead."));
        const q = J.morphAttributes.position || J.morphAttributes.normal || J.morphAttributes.color
          , ce = q !== void 0 ? q.length : 0;
        let Ce = 0;
        J.morphAttributes.position !== void 0 && (Ce = 1),
        J.morphAttributes.normal !== void 0 && (Ce = 2),
        J.morphAttributes.color !== void 0 && (Ce = 3);
        let Z, de, Se, ke;
        if (V) {
            const Dt = wr[V];
            Z = Dt.vertexShader,
            de = Dt.fragmentShader
        } else
            Z = C.vertexShader,
            de = C.fragmentShader,
            c.update(C),
            Se = c.getVertexShaderID(C),
            ke = c.getFragmentShaderID(C);
        const Xe = n.getRenderTarget()
          , ze = B.isInstancedMesh === !0
          , ut = B.isBatchedMesh === !0
          , He = !!C.map
          , z = !!C.matcap
          , ge = !!F
          , fe = !!C.aoMap
          , Me = !!C.lightMap
          , pe = !!C.bumpMap
          , Oe = !!C.normalMap
          , De = !!C.displacementMap
          , Ge = !!C.emissiveMap
          , ft = !!C.metalnessMap
          , O = !!C.roughnessMap
          , L = C.anisotropy > 0
          , oe = C.clearcoat > 0
          , le = C.iridescence > 0
          , ye = C.sheen > 0
          , me = C.transmission > 0
          , st = L && !!C.anisotropyMap
          , et = oe && !!C.clearcoatMap
          , Te = oe && !!C.clearcoatNormalMap
          , Re = oe && !!C.clearcoatRoughnessMap
          , ot = le && !!C.iridescenceMap
          , we = le && !!C.iridescenceThicknessMap
          , nn = ye && !!C.sheenColorMap
          , St = ye && !!C.sheenRoughnessMap
          , Ke = !!C.specularMap
          , Ye = !!C.specularColorMap
          , je = !!C.specularIntensityMap
          , Tt = me && !!C.transmissionMap
          , ht = me && !!C.thicknessMap
          , zt = !!C.gradientMap
          , X = !!C.alphaMap
          , be = C.alphaTest > 0
          , ee = !!C.alphaHash
          , Ee = !!C.extensions;
        let Pe = Ar;
        C.toneMapped && (Xe === null || Xe.isXRRenderTarget === !0) && (Pe = n.toneMapping);
        const wt = {
            isWebGL2: d,
            shaderID: V,
            shaderType: C.type,
            shaderName: C.name,
            vertexShader: Z,
            fragmentShader: de,
            defines: C.defines,
            customVertexShaderID: Se,
            customFragmentShaderID: ke,
            isRawShaderMaterial: C.isRawShaderMaterial === !0,
            glslVersion: C.glslVersion,
            precision: _,
            batching: ut,
            instancing: ze,
            instancingColor: ze && B.instanceColor !== null,
            instancingMorph: ze && B.morphTexture !== null,
            supportsVertexTextures: v,
            outputColorSpace: Xe === null ? n.outputColorSpace : Xe.isXRRenderTarget === !0 ? Xe.texture.colorSpace : Cs,
            alphaToCoverage: !!C.alphaToCoverage,
            map: He,
            matcap: z,
            envMap: ge,
            envMapMode: ge && F.mapping,
            envMapCubeUVHeight: H,
            aoMap: fe,
            lightMap: Me,
            bumpMap: pe,
            normalMap: Oe,
            displacementMap: v && De,
            emissiveMap: Ge,
            normalMapObjectSpace: Oe && C.normalMapType === J2,
            normalMapTangentSpace: Oe && C.normalMapType === xo,
            metalnessMap: ft,
            roughnessMap: O,
            anisotropy: L,
            anisotropyMap: st,
            clearcoat: oe,
            clearcoatMap: et,
            clearcoatNormalMap: Te,
            clearcoatRoughnessMap: Re,
            iridescence: le,
            iridescenceMap: ot,
            iridescenceThicknessMap: we,
            sheen: ye,
            sheenColorMap: nn,
            sheenRoughnessMap: St,
            specularMap: Ke,
            specularColorMap: Ye,
            specularIntensityMap: je,
            transmission: me,
            transmissionMap: Tt,
            thicknessMap: ht,
            gradientMap: zt,
            opaque: C.transparent === !1 && C.blending === la && C.alphaToCoverage === !1,
            alphaMap: X,
            alphaTest: be,
            alphaHash: ee,
            combine: C.combine,
            mapUv: He && x(C.map.channel),
            aoMapUv: fe && x(C.aoMap.channel),
            lightMapUv: Me && x(C.lightMap.channel),
            bumpMapUv: pe && x(C.bumpMap.channel),
            normalMapUv: Oe && x(C.normalMap.channel),
            displacementMapUv: De && x(C.displacementMap.channel),
            emissiveMapUv: Ge && x(C.emissiveMap.channel),
            metalnessMapUv: ft && x(C.metalnessMap.channel),
            roughnessMapUv: O && x(C.roughnessMap.channel),
            anisotropyMapUv: st && x(C.anisotropyMap.channel),
            clearcoatMapUv: et && x(C.clearcoatMap.channel),
            clearcoatNormalMapUv: Te && x(C.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: Re && x(C.clearcoatRoughnessMap.channel),
            iridescenceMapUv: ot && x(C.iridescenceMap.channel),
            iridescenceThicknessMapUv: we && x(C.iridescenceThicknessMap.channel),
            sheenColorMapUv: nn && x(C.sheenColorMap.channel),
            sheenRoughnessMapUv: St && x(C.sheenRoughnessMap.channel),
            specularMapUv: Ke && x(C.specularMap.channel),
            specularColorMapUv: Ye && x(C.specularColorMap.channel),
            specularIntensityMapUv: je && x(C.specularIntensityMap.channel),
            transmissionMapUv: Tt && x(C.transmissionMap.channel),
            thicknessMapUv: ht && x(C.thicknessMap.channel),
            alphaMapUv: X && x(C.alphaMap.channel),
            vertexTangents: !!J.attributes.tangent && (Oe || L),
            vertexColors: C.vertexColors,
            vertexAlphas: C.vertexColors === !0 && !!J.attributes.color && J.attributes.color.itemSize === 4,
            pointsUvs: B.isPoints === !0 && !!J.attributes.uv && (He || X),
            fog: !!ie,
            useFog: C.fog === !0,
            fogExp2: !!ie && ie.isFogExp2,
            flatShading: C.flatShading === !0,
            sizeAttenuation: C.sizeAttenuation === !0,
            logarithmicDepthBuffer: m,
            skinning: B.isSkinnedMesh === !0,
            morphTargets: J.morphAttributes.position !== void 0,
            morphNormals: J.morphAttributes.normal !== void 0,
            morphColors: J.morphAttributes.color !== void 0,
            morphTargetsCount: ce,
            morphTextureStride: Ce,
            numDirLights: I.directional.length,
            numPointLights: I.point.length,
            numSpotLights: I.spot.length,
            numSpotLightMaps: I.spotLightMap.length,
            numRectAreaLights: I.rectArea.length,
            numHemiLights: I.hemi.length,
            numDirLightShadows: I.directionalShadowMap.length,
            numPointLightShadows: I.pointShadowMap.length,
            numSpotLightShadows: I.spotShadowMap.length,
            numSpotLightShadowsWithMaps: I.numSpotLightShadowsWithMaps,
            numLightProbes: I.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: C.dithering,
            shadowMapEnabled: n.shadowMap.enabled && K.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: Pe,
            useLegacyLights: n._useLegacyLights,
            decodeVideoTexture: He && C.map.isVideoTexture === !0 && Ut.getTransfer(C.map.colorSpace) === Bt,
            premultipliedAlpha: C.premultipliedAlpha,
            doubleSided: C.side === Vr,
            flipSided: C.side === ti,
            useDepthPacking: C.depthPacking >= 0,
            depthPacking: C.depthPacking || 0,
            index0AttributeName: C.index0AttributeName,
            extensionDerivatives: Ee && C.extensions.derivatives === !0,
            extensionFragDepth: Ee && C.extensions.fragDepth === !0,
            extensionDrawBuffers: Ee && C.extensions.drawBuffers === !0,
            extensionShaderTextureLOD: Ee && C.extensions.shaderTextureLOD === !0,
            extensionClipCullDistance: Ee && C.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: Ee && C.extensions.multiDraw === !0 && i.has("WEBGL_multi_draw"),
            rendererExtensionFragDepth: d || i.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: d || i.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: d || i.has("EXT_shader_texture_lod"),
            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: C.customProgramCacheKey()
        };
        return wt.vertexUv1s = f.has(1),
        wt.vertexUv2s = f.has(2),
        wt.vertexUv3s = f.has(3),
        f.clear(),
        wt
    }
    function S(C) {
        const I = [];
        if (C.shaderID ? I.push(C.shaderID) : (I.push(C.customVertexShaderID),
        I.push(C.customFragmentShaderID)),
        C.defines !== void 0)
            for (const K in C.defines)
                I.push(K),
                I.push(C.defines[K]);
        return C.isRawShaderMaterial === !1 && (M(I, C),
        T(I, C),
        I.push(n.outputColorSpace)),
        I.push(C.customProgramCacheKey),
        I.join()
    }
    function M(C, I) {
        C.push(I.precision),
        C.push(I.outputColorSpace),
        C.push(I.envMapMode),
        C.push(I.envMapCubeUVHeight),
        C.push(I.mapUv),
        C.push(I.alphaMapUv),
        C.push(I.lightMapUv),
        C.push(I.aoMapUv),
        C.push(I.bumpMapUv),
        C.push(I.normalMapUv),
        C.push(I.displacementMapUv),
        C.push(I.emissiveMapUv),
        C.push(I.metalnessMapUv),
        C.push(I.roughnessMapUv),
        C.push(I.anisotropyMapUv),
        C.push(I.clearcoatMapUv),
        C.push(I.clearcoatNormalMapUv),
        C.push(I.clearcoatRoughnessMapUv),
        C.push(I.iridescenceMapUv),
        C.push(I.iridescenceThicknessMapUv),
        C.push(I.sheenColorMapUv),
        C.push(I.sheenRoughnessMapUv),
        C.push(I.specularMapUv),
        C.push(I.specularColorMapUv),
        C.push(I.specularIntensityMapUv),
        C.push(I.transmissionMapUv),
        C.push(I.thicknessMapUv),
        C.push(I.combine),
        C.push(I.fogExp2),
        C.push(I.sizeAttenuation),
        C.push(I.morphTargetsCount),
        C.push(I.morphAttributeCount),
        C.push(I.numDirLights),
        C.push(I.numPointLights),
        C.push(I.numSpotLights),
        C.push(I.numSpotLightMaps),
        C.push(I.numHemiLights),
        C.push(I.numRectAreaLights),
        C.push(I.numDirLightShadows),
        C.push(I.numPointLightShadows),
        C.push(I.numSpotLightShadows),
        C.push(I.numSpotLightShadowsWithMaps),
        C.push(I.numLightProbes),
        C.push(I.shadowMapType),
        C.push(I.toneMapping),
        C.push(I.numClippingPlanes),
        C.push(I.numClipIntersection),
        C.push(I.depthPacking)
    }
    function T(C, I) {
        a.disableAll(),
        I.isWebGL2 && a.enable(0),
        I.supportsVertexTextures && a.enable(1),
        I.instancing && a.enable(2),
        I.instancingColor && a.enable(3),
        I.instancingMorph && a.enable(4),
        I.matcap && a.enable(5),
        I.envMap && a.enable(6),
        I.normalMapObjectSpace && a.enable(7),
        I.normalMapTangentSpace && a.enable(8),
        I.clearcoat && a.enable(9),
        I.iridescence && a.enable(10),
        I.alphaTest && a.enable(11),
        I.vertexColors && a.enable(12),
        I.vertexAlphas && a.enable(13),
        I.vertexUv1s && a.enable(14),
        I.vertexUv2s && a.enable(15),
        I.vertexUv3s && a.enable(16),
        I.vertexTangents && a.enable(17),
        I.anisotropy && a.enable(18),
        I.alphaHash && a.enable(19),
        I.batching && a.enable(20),
        C.push(a.mask),
        a.disableAll(),
        I.fog && a.enable(0),
        I.useFog && a.enable(1),
        I.flatShading && a.enable(2),
        I.logarithmicDepthBuffer && a.enable(3),
        I.skinning && a.enable(4),
        I.morphTargets && a.enable(5),
        I.morphNormals && a.enable(6),
        I.morphColors && a.enable(7),
        I.premultipliedAlpha && a.enable(8),
        I.shadowMapEnabled && a.enable(9),
        I.useLegacyLights && a.enable(10),
        I.doubleSided && a.enable(11),
        I.flipSided && a.enable(12),
        I.useDepthPacking && a.enable(13),
        I.dithering && a.enable(14),
        I.transmission && a.enable(15),
        I.sheen && a.enable(16),
        I.opaque && a.enable(17),
        I.pointsUvs && a.enable(18),
        I.decodeVideoTexture && a.enable(19),
        I.alphaToCoverage && a.enable(20),
        C.push(a.mask)
    }
    function P(C) {
        const I = w[C.type];
        let K;
        if (I) {
            const se = wr[I];
            K = Z_.clone(se.uniforms)
        } else
            K = C.uniforms;
        return K
    }
    function R(C, I) {
        let K;
        for (let se = 0, B = h.length; se < B; se++) {
            const ie = h[se];
            if (ie.cacheKey === I) {
                K = ie,
                ++K.usedTimes;
                break
            }
        }
        return K === void 0 && (K = new kO(n,I,C,s),
        h.push(K)),
        K
    }
    function b(C) {
        if (--C.usedTimes === 0) {
            const I = h.indexOf(C);
            h[I] = h[h.length - 1],
            h.pop(),
            C.destroy()
        }
    }
    function N(C) {
        c.remove(C)
    }
    function G() {
        c.dispose()
    }
    return {
        getParameters: g,
        getProgramCacheKey: S,
        getUniforms: P,
        acquireProgram: R,
        releaseProgram: b,
        releaseShaderCache: N,
        programs: h,
        dispose: G
    }
}
function GO() {
    let n = new WeakMap;
    function e(s) {
        let o = n.get(s);
        return o === void 0 && (o = {},
        n.set(s, o)),
        o
    }
    function t(s) {
        n.delete(s)
    }
    function i(s, o, a) {
        n.get(s)[o] = a
    }
    function r() {
        n = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: i,
        dispose: r
    }
}
function WO(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}
function KM(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}
function QM() {
    const n = [];
    let e = 0;
    const t = []
      , i = []
      , r = [];
    function s() {
        e = 0,
        t.length = 0,
        i.length = 0,
        r.length = 0
    }
    function o(d, m, v, _, w, x) {
        let g = n[e];
        return g === void 0 ? (g = {
            id: d.id,
            object: d,
            geometry: m,
            material: v,
            groupOrder: _,
            renderOrder: d.renderOrder,
            z: w,
            group: x
        },
        n[e] = g) : (g.id = d.id,
        g.object = d,
        g.geometry = m,
        g.material = v,
        g.groupOrder = _,
        g.renderOrder = d.renderOrder,
        g.z = w,
        g.group = x),
        e++,
        g
    }
    function a(d, m, v, _, w, x) {
        const g = o(d, m, v, _, w, x);
        v.transmission > 0 ? i.push(g) : v.transparent === !0 ? r.push(g) : t.push(g)
    }
    function c(d, m, v, _, w, x) {
        const g = o(d, m, v, _, w, x);
        v.transmission > 0 ? i.unshift(g) : v.transparent === !0 ? r.unshift(g) : t.unshift(g)
    }
    function f(d, m) {
        t.length > 1 && t.sort(d || WO),
        i.length > 1 && i.sort(m || KM),
        r.length > 1 && r.sort(m || KM)
    }
    function h() {
        for (let d = e, m = n.length; d < m; d++) {
            const v = n[d];
            if (v.id === null)
                break;
            v.id = null,
            v.object = null,
            v.geometry = null,
            v.material = null,
            v.group = null
        }
    }
    return {
        opaque: t,
        transmissive: i,
        transparent: r,
        init: s,
        push: a,
        unshift: c,
        finish: h,
        sort: f
    }
}
function XO() {
    let n = new WeakMap;
    function e(i, r) {
        const s = n.get(i);
        let o;
        return s === void 0 ? (o = new QM,
        n.set(i, [o])) : r >= s.length ? (o = new QM,
        s.push(o)) : o = s[r],
        o
    }
    function t() {
        n = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function YO() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new U,
                    color: new Ne
                };
                break;
            case "SpotLight":
                t = {
                    position: new U,
                    direction: new U,
                    color: new Ne,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new U,
                    color: new Ne,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new U,
                    skyColor: new Ne,
                    groundColor: new Ne
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new Ne,
                    position: new U,
                    halfWidth: new U,
                    halfHeight: new U
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
function jO() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new he
                };
                break;
            case "SpotLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new he
                };
                break;
            case "PointLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new he,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
let qO = 0;
function ZO(n, e) {
    return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}
function JO(n, e) {
    const t = new YO
      , i = jO()
      , r = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let h = 0; h < 9; h++)
        r.probe.push(new U);
    const s = new U
      , o = new $e
      , a = new $e;
    function c(h, d) {
        let m = 0
          , v = 0
          , _ = 0;
        for (let K = 0; K < 9; K++)
            r.probe[K].set(0, 0, 0);
        let w = 0
          , x = 0
          , g = 0
          , S = 0
          , M = 0
          , T = 0
          , P = 0
          , R = 0
          , b = 0
          , N = 0
          , G = 0;
        h.sort(ZO);
        const C = d === !0 ? Math.PI : 1;
        for (let K = 0, se = h.length; K < se; K++) {
            const B = h[K]
              , ie = B.color
              , J = B.intensity
              , ue = B.distance
              , F = B.shadow && B.shadow.map ? B.shadow.map.texture : null;
            if (B.isAmbientLight)
                m += ie.r * J * C,
                v += ie.g * J * C,
                _ += ie.b * J * C;
            else if (B.isLightProbe) {
                for (let H = 0; H < 9; H++)
                    r.probe[H].addScaledVector(B.sh.coefficients[H], J);
                G++
            } else if (B.isDirectionalLight) {
                const H = t.get(B);
                if (H.color.copy(B.color).multiplyScalar(B.intensity * C),
                B.castShadow) {
                    const V = B.shadow
                      , q = i.get(B);
                    q.shadowBias = V.bias,
                    q.shadowNormalBias = V.normalBias,
                    q.shadowRadius = V.radius,
                    q.shadowMapSize = V.mapSize,
                    r.directionalShadow[w] = q,
                    r.directionalShadowMap[w] = F,
                    r.directionalShadowMatrix[w] = B.shadow.matrix,
                    T++
                }
                r.directional[w] = H,
                w++
            } else if (B.isSpotLight) {
                const H = t.get(B);
                H.position.setFromMatrixPosition(B.matrixWorld),
                H.color.copy(ie).multiplyScalar(J * C),
                H.distance = ue,
                H.coneCos = Math.cos(B.angle),
                H.penumbraCos = Math.cos(B.angle * (1 - B.penumbra)),
                H.decay = B.decay,
                r.spot[g] = H;
                const V = B.shadow;
                if (B.map && (r.spotLightMap[b] = B.map,
                b++,
                V.updateMatrices(B),
                B.castShadow && N++),
                r.spotLightMatrix[g] = V.matrix,
                B.castShadow) {
                    const q = i.get(B);
                    q.shadowBias = V.bias,
                    q.shadowNormalBias = V.normalBias,
                    q.shadowRadius = V.radius,
                    q.shadowMapSize = V.mapSize,
                    r.spotShadow[g] = q,
                    r.spotShadowMap[g] = F,
                    R++
                }
                g++
            } else if (B.isRectAreaLight) {
                const H = t.get(B);
                H.color.copy(ie).multiplyScalar(J),
                H.halfWidth.set(B.width * .5, 0, 0),
                H.halfHeight.set(0, B.height * .5, 0),
                r.rectArea[S] = H,
                S++
            } else if (B.isPointLight) {
                const H = t.get(B);
                if (H.color.copy(B.color).multiplyScalar(B.intensity * C),
                H.distance = B.distance,
                H.decay = B.decay,
                B.castShadow) {
                    const V = B.shadow
                      , q = i.get(B);
                    q.shadowBias = V.bias,
                    q.shadowNormalBias = V.normalBias,
                    q.shadowRadius = V.radius,
                    q.shadowMapSize = V.mapSize,
                    q.shadowCameraNear = V.camera.near,
                    q.shadowCameraFar = V.camera.far,
                    r.pointShadow[x] = q,
                    r.pointShadowMap[x] = F,
                    r.pointShadowMatrix[x] = B.shadow.matrix,
                    P++
                }
                r.point[x] = H,
                x++
            } else if (B.isHemisphereLight) {
                const H = t.get(B);
                H.skyColor.copy(B.color).multiplyScalar(J * C),
                H.groundColor.copy(B.groundColor).multiplyScalar(J * C),
                r.hemi[M] = H,
                M++
            }
        }
        S > 0 && (e.isWebGL2 ? n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Ae.LTC_FLOAT_1,
        r.rectAreaLTC2 = Ae.LTC_FLOAT_2) : (r.rectAreaLTC1 = Ae.LTC_HALF_1,
        r.rectAreaLTC2 = Ae.LTC_HALF_2) : n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Ae.LTC_FLOAT_1,
        r.rectAreaLTC2 = Ae.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = Ae.LTC_HALF_1,
        r.rectAreaLTC2 = Ae.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
        r.ambient[0] = m,
        r.ambient[1] = v,
        r.ambient[2] = _;
        const I = r.hash;
        (I.directionalLength !== w || I.pointLength !== x || I.spotLength !== g || I.rectAreaLength !== S || I.hemiLength !== M || I.numDirectionalShadows !== T || I.numPointShadows !== P || I.numSpotShadows !== R || I.numSpotMaps !== b || I.numLightProbes !== G) && (r.directional.length = w,
        r.spot.length = g,
        r.rectArea.length = S,
        r.point.length = x,
        r.hemi.length = M,
        r.directionalShadow.length = T,
        r.directionalShadowMap.length = T,
        r.pointShadow.length = P,
        r.pointShadowMap.length = P,
        r.spotShadow.length = R,
        r.spotShadowMap.length = R,
        r.directionalShadowMatrix.length = T,
        r.pointShadowMatrix.length = P,
        r.spotLightMatrix.length = R + b - N,
        r.spotLightMap.length = b,
        r.numSpotLightShadowsWithMaps = N,
        r.numLightProbes = G,
        I.directionalLength = w,
        I.pointLength = x,
        I.spotLength = g,
        I.rectAreaLength = S,
        I.hemiLength = M,
        I.numDirectionalShadows = T,
        I.numPointShadows = P,
        I.numSpotShadows = R,
        I.numSpotMaps = b,
        I.numLightProbes = G,
        r.version = qO++)
    }
    function f(h, d) {
        let m = 0
          , v = 0
          , _ = 0
          , w = 0
          , x = 0;
        const g = d.matrixWorldInverse;
        for (let S = 0, M = h.length; S < M; S++) {
            const T = h[S];
            if (T.isDirectionalLight) {
                const P = r.directional[m];
                P.direction.setFromMatrixPosition(T.matrixWorld),
                s.setFromMatrixPosition(T.target.matrixWorld),
                P.direction.sub(s),
                P.direction.transformDirection(g),
                m++
            } else if (T.isSpotLight) {
                const P = r.spot[_];
                P.position.setFromMatrixPosition(T.matrixWorld),
                P.position.applyMatrix4(g),
                P.direction.setFromMatrixPosition(T.matrixWorld),
                s.setFromMatrixPosition(T.target.matrixWorld),
                P.direction.sub(s),
                P.direction.transformDirection(g),
                _++
            } else if (T.isRectAreaLight) {
                const P = r.rectArea[w];
                P.position.setFromMatrixPosition(T.matrixWorld),
                P.position.applyMatrix4(g),
                a.identity(),
                o.copy(T.matrixWorld),
                o.premultiply(g),
                a.extractRotation(o),
                P.halfWidth.set(T.width * .5, 0, 0),
                P.halfHeight.set(0, T.height * .5, 0),
                P.halfWidth.applyMatrix4(a),
                P.halfHeight.applyMatrix4(a),
                w++
            } else if (T.isPointLight) {
                const P = r.point[v];
                P.position.setFromMatrixPosition(T.matrixWorld),
                P.position.applyMatrix4(g),
                v++
            } else if (T.isHemisphereLight) {
                const P = r.hemi[x];
                P.direction.setFromMatrixPosition(T.matrixWorld),
                P.direction.transformDirection(g),
                x++
            }
        }
    }
    return {
        setup: c,
        setupView: f,
        state: r
    }
}
function $M(n, e) {
    const t = new JO(n,e)
      , i = []
      , r = [];
    function s() {
        i.length = 0,
        r.length = 0
    }
    function o(d) {
        i.push(d)
    }
    function a(d) {
        r.push(d)
    }
    function c(d) {
        t.setup(i, d)
    }
    function f(d) {
        t.setupView(i, d)
    }
    return {
        init: s,
        state: {
            lightsArray: i,
            shadowsArray: r,
            lights: t
        },
        setupLights: c,
        setupLightsView: f,
        pushLight: o,
        pushShadow: a
    }
}
function KO(n, e) {
    let t = new WeakMap;
    function i(s, o=0) {
        const a = t.get(s);
        let c;
        return a === void 0 ? (c = new $M(n,e),
        t.set(s, [c])) : o >= a.length ? (c = new $M(n,e),
        a.push(c)) : c = a[o],
        c
    }
    function r() {
        t = new WeakMap
    }
    return {
        get: i,
        dispose: r
    }
}
class K_ extends Gn {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = q2,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class Q_ extends Gn {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const QO = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , $O = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function eF(n, e, t) {
    let i = new _f;
    const r = new he
      , s = new he
      , o = new Ct
      , a = new K_({
        depthPacking: Z2
    })
      , c = new Q_
      , f = {}
      , h = t.maxTextureSize
      , d = {
        [Zr]: ti,
        [ti]: Zr,
        [Vr]: Vr
    }
      , m = new fr({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new he
            },
            radius: {
                value: 4
            }
        },
        vertexShader: QO,
        fragmentShader: $O
    })
      , v = m.clone();
    v.defines.HORIZONTAL_PASS = 1;
    const _ = new _t;
    _.setAttribute("position", new Nt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const w = new _n(_,m)
      , x = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = Zp;
    let g = this.type;
    this.render = function(R, b, N) {
        if (x.enabled === !1 || x.autoUpdate === !1 && x.needsUpdate === !1 || R.length === 0)
            return;
        const G = n.getRenderTarget()
          , C = n.getActiveCubeFace()
          , I = n.getActiveMipmapLevel()
          , K = n.state;
        K.setBlending(xs),
        K.buffers.color.setClear(1, 1, 1, 1),
        K.buffers.depth.setTest(!0),
        K.setScissorTest(!1);
        const se = g !== xr && this.type === xr
          , B = g === xr && this.type !== xr;
        for (let ie = 0, J = R.length; ie < J; ie++) {
            const ue = R[ie]
              , F = ue.shadow;
            if (F === void 0) {
                console.warn("THREE.WebGLShadowMap:", ue, "has no shadow.");
                continue
            }
            if (F.autoUpdate === !1 && F.needsUpdate === !1)
                continue;
            r.copy(F.mapSize);
            const H = F.getFrameExtents();
            if (r.multiply(H),
            s.copy(F.mapSize),
            (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / H.x),
            r.x = s.x * H.x,
            F.mapSize.x = s.x),
            r.y > h && (s.y = Math.floor(h / H.y),
            r.y = s.y * H.y,
            F.mapSize.y = s.y)),
            F.map === null || se === !0 || B === !0) {
                const q = this.type !== xr ? {
                    minFilter: hn,
                    magFilter: hn
                } : {};
                F.map !== null && F.map.dispose(),
                F.map = new cr(r.x,r.y,q),
                F.map.texture.name = ue.name + ".shadowMap",
                F.camera.updateProjectionMatrix()
            }
            n.setRenderTarget(F.map),
            n.clear();
            const V = F.getViewportCount();
            for (let q = 0; q < V; q++) {
                const ce = F.getViewport(q);
                o.set(s.x * ce.x, s.y * ce.y, s.x * ce.z, s.y * ce.w),
                K.viewport(o),
                F.updateMatrices(ue, q),
                i = F.getFrustum(),
                T(b, N, F.camera, ue, this.type)
            }
            F.isPointLightShadow !== !0 && this.type === xr && S(F, N),
            F.needsUpdate = !1
        }
        g = this.type,
        x.needsUpdate = !1,
        n.setRenderTarget(G, C, I)
    }
    ;
    function S(R, b) {
        const N = e.update(w);
        m.defines.VSM_SAMPLES !== R.blurSamples && (m.defines.VSM_SAMPLES = R.blurSamples,
        v.defines.VSM_SAMPLES = R.blurSamples,
        m.needsUpdate = !0,
        v.needsUpdate = !0),
        R.mapPass === null && (R.mapPass = new cr(r.x,r.y)),
        m.uniforms.shadow_pass.value = R.map.texture,
        m.uniforms.resolution.value = R.mapSize,
        m.uniforms.radius.value = R.radius,
        n.setRenderTarget(R.mapPass),
        n.clear(),
        n.renderBufferDirect(b, null, N, m, w, null),
        v.uniforms.shadow_pass.value = R.mapPass.texture,
        v.uniforms.resolution.value = R.mapSize,
        v.uniforms.radius.value = R.radius,
        n.setRenderTarget(R.map),
        n.clear(),
        n.renderBufferDirect(b, null, N, v, w, null)
    }
    function M(R, b, N, G) {
        let C = null;
        const I = N.isPointLight === !0 ? R.customDistanceMaterial : R.customDepthMaterial;
        if (I !== void 0)
            C = I;
        else if (C = N.isPointLight === !0 ? c : a,
        n.localClippingEnabled && b.clipShadows === !0 && Array.isArray(b.clippingPlanes) && b.clippingPlanes.length !== 0 || b.displacementMap && b.displacementScale !== 0 || b.alphaMap && b.alphaTest > 0 || b.map && b.alphaTest > 0) {
            const K = C.uuid
              , se = b.uuid;
            let B = f[K];
            B === void 0 && (B = {},
            f[K] = B);
            let ie = B[se];
            ie === void 0 && (ie = C.clone(),
            B[se] = ie,
            b.addEventListener("dispose", P)),
            C = ie
        }
        if (C.visible = b.visible,
        C.wireframe = b.wireframe,
        G === xr ? C.side = b.shadowSide !== null ? b.shadowSide : b.side : C.side = b.shadowSide !== null ? b.shadowSide : d[b.side],
        C.alphaMap = b.alphaMap,
        C.alphaTest = b.alphaTest,
        C.map = b.map,
        C.clipShadows = b.clipShadows,
        C.clippingPlanes = b.clippingPlanes,
        C.clipIntersection = b.clipIntersection,
        C.displacementMap = b.displacementMap,
        C.displacementScale = b.displacementScale,
        C.displacementBias = b.displacementBias,
        C.wireframeLinewidth = b.wireframeLinewidth,
        C.linewidth = b.linewidth,
        N.isPointLight === !0 && C.isMeshDistanceMaterial === !0) {
            const K = n.properties.get(C);
            K.light = N
        }
        return C
    }
    function T(R, b, N, G, C) {
        if (R.visible === !1)
            return;
        if (R.layers.test(b.layers) && (R.isMesh || R.isLine || R.isPoints) && (R.castShadow || R.receiveShadow && C === xr) && (!R.frustumCulled || i.intersectsObject(R))) {
            R.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse, R.matrixWorld);
            const se = e.update(R)
              , B = R.material;
            if (Array.isArray(B)) {
                const ie = se.groups;
                for (let J = 0, ue = ie.length; J < ue; J++) {
                    const F = ie[J]
                      , H = B[F.materialIndex];
                    if (H && H.visible) {
                        const V = M(R, H, G, C);
                        R.onBeforeShadow(n, R, b, N, se, V, F),
                        n.renderBufferDirect(N, null, se, V, R, F),
                        R.onAfterShadow(n, R, b, N, se, V, F)
                    }
                }
            } else if (B.visible) {
                const ie = M(R, B, G, C);
                R.onBeforeShadow(n, R, b, N, se, ie, null),
                n.renderBufferDirect(N, null, se, ie, R, null),
                R.onAfterShadow(n, R, b, N, se, ie, null)
            }
        }
        const K = R.children;
        for (let se = 0, B = K.length; se < B; se++)
            T(K[se], b, N, G, C)
    }
    function P(R) {
        R.target.removeEventListener("dispose", P);
        for (const N in f) {
            const G = f[N]
              , C = R.target.uuid;
            C in G && (G[C].dispose(),
            delete G[C])
        }
    }
}
function tF(n, e, t) {
    const i = t.isWebGL2;
    function r() {
        let X = !1;
        const be = new Ct;
        let ee = null;
        const Ee = new Ct(0,0,0,0);
        return {
            setMask: function(Pe) {
                ee !== Pe && !X && (n.colorMask(Pe, Pe, Pe, Pe),
                ee = Pe)
            },
            setLocked: function(Pe) {
                X = Pe
            },
            setClear: function(Pe, wt, Dt, pn, ri) {
                ri === !0 && (Pe *= pn,
                wt *= pn,
                Dt *= pn),
                be.set(Pe, wt, Dt, pn),
                Ee.equals(be) === !1 && (n.clearColor(Pe, wt, Dt, pn),
                Ee.copy(be))
            },
            reset: function() {
                X = !1,
                ee = null,
                Ee.set(-1, 0, 0, 0)
            }
        }
    }
    function s() {
        let X = !1
          , be = null
          , ee = null
          , Ee = null;
        return {
            setTest: function(Pe) {
                Pe ? ze(n.DEPTH_TEST) : ut(n.DEPTH_TEST)
            },
            setMask: function(Pe) {
                be !== Pe && !X && (n.depthMask(Pe),
                be = Pe)
            },
            setFunc: function(Pe) {
                if (ee !== Pe) {
                    switch (Pe) {
                    case M2:
                        n.depthFunc(n.NEVER);
                        break;
                    case w2:
                        n.depthFunc(n.ALWAYS);
                        break;
                    case E2:
                        n.depthFunc(n.LESS);
                        break;
                    case Hc:
                        n.depthFunc(n.LEQUAL);
                        break;
                    case T2:
                        n.depthFunc(n.EQUAL);
                        break;
                    case A2:
                        n.depthFunc(n.GEQUAL);
                        break;
                    case C2:
                        n.depthFunc(n.GREATER);
                        break;
                    case R2:
                        n.depthFunc(n.NOTEQUAL);
                        break;
                    default:
                        n.depthFunc(n.LEQUAL)
                    }
                    ee = Pe
                }
            },
            setLocked: function(Pe) {
                X = Pe
            },
            setClear: function(Pe) {
                Ee !== Pe && (n.clearDepth(Pe),
                Ee = Pe)
            },
            reset: function() {
                X = !1,
                be = null,
                ee = null,
                Ee = null
            }
        }
    }
    function o() {
        let X = !1
          , be = null
          , ee = null
          , Ee = null
          , Pe = null
          , wt = null
          , Dt = null
          , pn = null
          , ri = null;
        return {
            setTest: function(Ft) {
                X || (Ft ? ze(n.STENCIL_TEST) : ut(n.STENCIL_TEST))
            },
            setMask: function(Ft) {
                be !== Ft && !X && (n.stencilMask(Ft),
                be = Ft)
            },
            setFunc: function(Ft, On, Xi) {
                (ee !== Ft || Ee !== On || Pe !== Xi) && (n.stencilFunc(Ft, On, Xi),
                ee = Ft,
                Ee = On,
                Pe = Xi)
            },
            setOp: function(Ft, On, Xi) {
                (wt !== Ft || Dt !== On || pn !== Xi) && (n.stencilOp(Ft, On, Xi),
                wt = Ft,
                Dt = On,
                pn = Xi)
            },
            setLocked: function(Ft) {
                X = Ft
            },
            setClear: function(Ft) {
                ri !== Ft && (n.clearStencil(Ft),
                ri = Ft)
            },
            reset: function() {
                X = !1,
                be = null,
                ee = null,
                Ee = null,
                Pe = null,
                wt = null,
                Dt = null,
                pn = null,
                ri = null
            }
        }
    }
    const a = new r
      , c = new s
      , f = new o
      , h = new WeakMap
      , d = new WeakMap;
    let m = {}
      , v = {}
      , _ = new WeakMap
      , w = []
      , x = null
      , g = !1
      , S = null
      , M = null
      , T = null
      , P = null
      , R = null
      , b = null
      , N = null
      , G = new Ne(0,0,0)
      , C = 0
      , I = !1
      , K = null
      , se = null
      , B = null
      , ie = null
      , J = null;
    const ue = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let F = !1
      , H = 0;
    const V = n.getParameter(n.VERSION);
    V.indexOf("WebGL") !== -1 ? (H = parseFloat(/^WebGL (\d)/.exec(V)[1]),
    F = H >= 1) : V.indexOf("OpenGL ES") !== -1 && (H = parseFloat(/^OpenGL ES (\d)/.exec(V)[1]),
    F = H >= 2);
    let q = null
      , ce = {};
    const Ce = n.getParameter(n.SCISSOR_BOX)
      , Z = n.getParameter(n.VIEWPORT)
      , de = new Ct().fromArray(Ce)
      , Se = new Ct().fromArray(Z);
    function ke(X, be, ee, Ee) {
        const Pe = new Uint8Array(4)
          , wt = n.createTexture();
        n.bindTexture(X, wt),
        n.texParameteri(X, n.TEXTURE_MIN_FILTER, n.NEAREST),
        n.texParameteri(X, n.TEXTURE_MAG_FILTER, n.NEAREST);
        for (let Dt = 0; Dt < ee; Dt++)
            i && (X === n.TEXTURE_3D || X === n.TEXTURE_2D_ARRAY) ? n.texImage3D(be, 0, n.RGBA, 1, 1, Ee, 0, n.RGBA, n.UNSIGNED_BYTE, Pe) : n.texImage2D(be + Dt, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, Pe);
        return wt
    }
    const Xe = {};
    Xe[n.TEXTURE_2D] = ke(n.TEXTURE_2D, n.TEXTURE_2D, 1),
    Xe[n.TEXTURE_CUBE_MAP] = ke(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    i && (Xe[n.TEXTURE_2D_ARRAY] = ke(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1),
    Xe[n.TEXTURE_3D] = ke(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
    a.setClear(0, 0, 0, 1),
    c.setClear(1),
    f.setClear(0),
    ze(n.DEPTH_TEST),
    c.setFunc(Hc),
    De(!1),
    Ge(Wv),
    ze(n.CULL_FACE),
    pe(xs);
    function ze(X) {
        m[X] !== !0 && (n.enable(X),
        m[X] = !0)
    }
    function ut(X) {
        m[X] !== !1 && (n.disable(X),
        m[X] = !1)
    }
    function He(X, be) {
        return v[X] !== be ? (n.bindFramebuffer(X, be),
        v[X] = be,
        i && (X === n.DRAW_FRAMEBUFFER && (v[n.FRAMEBUFFER] = be),
        X === n.FRAMEBUFFER && (v[n.DRAW_FRAMEBUFFER] = be)),
        !0) : !1
    }
    function z(X, be) {
        let ee = w
          , Ee = !1;
        if (X) {
            ee = _.get(be),
            ee === void 0 && (ee = [],
            _.set(be, ee));
            const Pe = X.textures;
            if (ee.length !== Pe.length || ee[0] !== n.COLOR_ATTACHMENT0) {
                for (let wt = 0, Dt = Pe.length; wt < Dt; wt++)
                    ee[wt] = n.COLOR_ATTACHMENT0 + wt;
                ee.length = Pe.length,
                Ee = !0
            }
        } else
            ee[0] !== n.BACK && (ee[0] = n.BACK,
            Ee = !0);
        if (Ee)
            if (t.isWebGL2)
                n.drawBuffers(ee);
            else if (e.has("WEBGL_draw_buffers") === !0)
                e.get("WEBGL_draw_buffers").drawBuffersWEBGL(ee);
            else
                throw new Error("THREE.WebGLState: Usage of gl.drawBuffers() require WebGL2 or WEBGL_draw_buffers extension")
    }
    function ge(X) {
        return x !== X ? (n.useProgram(X),
        x = X,
        !0) : !1
    }
    const fe = {
        [Qs]: n.FUNC_ADD,
        [a2]: n.FUNC_SUBTRACT,
        [l2]: n.FUNC_REVERSE_SUBTRACT
    };
    if (i)
        fe[qv] = n.MIN,
        fe[Zv] = n.MAX;
    else {
        const X = e.get("EXT_blend_minmax");
        X !== null && (fe[qv] = X.MIN_EXT,
        fe[Zv] = X.MAX_EXT)
    }
    const Me = {
        [u2]: n.ZERO,
        [c2]: n.ONE,
        [f2]: n.SRC_COLOR,
        [wp]: n.SRC_ALPHA,
        [v2]: n.SRC_ALPHA_SATURATE,
        [m2]: n.DST_COLOR,
        [d2]: n.DST_ALPHA,
        [h2]: n.ONE_MINUS_SRC_COLOR,
        [Ep]: n.ONE_MINUS_SRC_ALPHA,
        [g2]: n.ONE_MINUS_DST_COLOR,
        [p2]: n.ONE_MINUS_DST_ALPHA,
        [y2]: n.CONSTANT_COLOR,
        [_2]: n.ONE_MINUS_CONSTANT_COLOR,
        [x2]: n.CONSTANT_ALPHA,
        [S2]: n.ONE_MINUS_CONSTANT_ALPHA
    };
    function pe(X, be, ee, Ee, Pe, wt, Dt, pn, ri, Ft) {
        if (X === xs) {
            g === !0 && (ut(n.BLEND),
            g = !1);
            return
        }
        if (g === !1 && (ze(n.BLEND),
        g = !0),
        X !== o2) {
            if (X !== S || Ft !== I) {
                if ((M !== Qs || R !== Qs) && (n.blendEquation(n.FUNC_ADD),
                M = Qs,
                R = Qs),
                Ft)
                    switch (X) {
                    case la:
                        n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Xv:
                        n.blendFunc(n.ONE, n.ONE);
                        break;
                    case Yv:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case jv:
                        n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", X);
                        break
                    }
                else
                    switch (X) {
                    case la:
                        n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Xv:
                        n.blendFunc(n.SRC_ALPHA, n.ONE);
                        break;
                    case Yv:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case jv:
                        n.blendFunc(n.ZERO, n.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", X);
                        break
                    }
                T = null,
                P = null,
                b = null,
                N = null,
                G.set(0, 0, 0),
                C = 0,
                S = X,
                I = Ft
            }
            return
        }
        Pe = Pe || be,
        wt = wt || ee,
        Dt = Dt || Ee,
        (be !== M || Pe !== R) && (n.blendEquationSeparate(fe[be], fe[Pe]),
        M = be,
        R = Pe),
        (ee !== T || Ee !== P || wt !== b || Dt !== N) && (n.blendFuncSeparate(Me[ee], Me[Ee], Me[wt], Me[Dt]),
        T = ee,
        P = Ee,
        b = wt,
        N = Dt),
        (pn.equals(G) === !1 || ri !== C) && (n.blendColor(pn.r, pn.g, pn.b, ri),
        G.copy(pn),
        C = ri),
        S = X,
        I = !1
    }
    function Oe(X, be) {
        X.side === Vr ? ut(n.CULL_FACE) : ze(n.CULL_FACE);
        let ee = X.side === ti;
        be && (ee = !ee),
        De(ee),
        X.blending === la && X.transparent === !1 ? pe(xs) : pe(X.blending, X.blendEquation, X.blendSrc, X.blendDst, X.blendEquationAlpha, X.blendSrcAlpha, X.blendDstAlpha, X.blendColor, X.blendAlpha, X.premultipliedAlpha),
        c.setFunc(X.depthFunc),
        c.setTest(X.depthTest),
        c.setMask(X.depthWrite),
        a.setMask(X.colorWrite);
        const Ee = X.stencilWrite;
        f.setTest(Ee),
        Ee && (f.setMask(X.stencilWriteMask),
        f.setFunc(X.stencilFunc, X.stencilRef, X.stencilFuncMask),
        f.setOp(X.stencilFail, X.stencilZFail, X.stencilZPass)),
        O(X.polygonOffset, X.polygonOffsetFactor, X.polygonOffsetUnits),
        X.alphaToCoverage === !0 ? ze(n.SAMPLE_ALPHA_TO_COVERAGE) : ut(n.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function De(X) {
        K !== X && (X ? n.frontFace(n.CW) : n.frontFace(n.CCW),
        K = X)
    }
    function Ge(X) {
        X !== i2 ? (ze(n.CULL_FACE),
        X !== se && (X === Wv ? n.cullFace(n.BACK) : X === r2 ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : ut(n.CULL_FACE),
        se = X
    }
    function ft(X) {
        X !== B && (F && n.lineWidth(X),
        B = X)
    }
    function O(X, be, ee) {
        X ? (ze(n.POLYGON_OFFSET_FILL),
        (ie !== be || J !== ee) && (n.polygonOffset(be, ee),
        ie = be,
        J = ee)) : ut(n.POLYGON_OFFSET_FILL)
    }
    function L(X) {
        X ? ze(n.SCISSOR_TEST) : ut(n.SCISSOR_TEST)
    }
    function oe(X) {
        X === void 0 && (X = n.TEXTURE0 + ue - 1),
        q !== X && (n.activeTexture(X),
        q = X)
    }
    function le(X, be, ee) {
        ee === void 0 && (q === null ? ee = n.TEXTURE0 + ue - 1 : ee = q);
        let Ee = ce[ee];
        Ee === void 0 && (Ee = {
            type: void 0,
            texture: void 0
        },
        ce[ee] = Ee),
        (Ee.type !== X || Ee.texture !== be) && (q !== ee && (n.activeTexture(ee),
        q = ee),
        n.bindTexture(X, be || Xe[X]),
        Ee.type = X,
        Ee.texture = be)
    }
    function ye() {
        const X = ce[q];
        X !== void 0 && X.type !== void 0 && (n.bindTexture(X.type, null),
        X.type = void 0,
        X.texture = void 0)
    }
    function me() {
        try {
            n.compressedTexImage2D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function st() {
        try {
            n.compressedTexImage3D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function et() {
        try {
            n.texSubImage2D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function Te() {
        try {
            n.texSubImage3D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function Re() {
        try {
            n.compressedTexSubImage2D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function ot() {
        try {
            n.compressedTexSubImage3D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function we() {
        try {
            n.texStorage2D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function nn() {
        try {
            n.texStorage3D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function St() {
        try {
            n.texImage2D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function Ke() {
        try {
            n.texImage3D.apply(n, arguments)
        } catch (X) {
            console.error("THREE.WebGLState:", X)
        }
    }
    function Ye(X) {
        de.equals(X) === !1 && (n.scissor(X.x, X.y, X.z, X.w),
        de.copy(X))
    }
    function je(X) {
        Se.equals(X) === !1 && (n.viewport(X.x, X.y, X.z, X.w),
        Se.copy(X))
    }
    function Tt(X, be) {
        let ee = d.get(be);
        ee === void 0 && (ee = new WeakMap,
        d.set(be, ee));
        let Ee = ee.get(X);
        Ee === void 0 && (Ee = n.getUniformBlockIndex(be, X.name),
        ee.set(X, Ee))
    }
    function ht(X, be) {
        const Ee = d.get(be).get(X);
        h.get(be) !== Ee && (n.uniformBlockBinding(be, Ee, X.__bindingPointIndex),
        h.set(be, Ee))
    }
    function zt() {
        n.disable(n.BLEND),
        n.disable(n.CULL_FACE),
        n.disable(n.DEPTH_TEST),
        n.disable(n.POLYGON_OFFSET_FILL),
        n.disable(n.SCISSOR_TEST),
        n.disable(n.STENCIL_TEST),
        n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
        n.blendEquation(n.FUNC_ADD),
        n.blendFunc(n.ONE, n.ZERO),
        n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
        n.blendColor(0, 0, 0, 0),
        n.colorMask(!0, !0, !0, !0),
        n.clearColor(0, 0, 0, 0),
        n.depthMask(!0),
        n.depthFunc(n.LESS),
        n.clearDepth(1),
        n.stencilMask(4294967295),
        n.stencilFunc(n.ALWAYS, 0, 4294967295),
        n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
        n.clearStencil(0),
        n.cullFace(n.BACK),
        n.frontFace(n.CCW),
        n.polygonOffset(0, 0),
        n.activeTexture(n.TEXTURE0),
        n.bindFramebuffer(n.FRAMEBUFFER, null),
        i === !0 && (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        n.bindFramebuffer(n.READ_FRAMEBUFFER, null)),
        n.useProgram(null),
        n.lineWidth(1),
        n.scissor(0, 0, n.canvas.width, n.canvas.height),
        n.viewport(0, 0, n.canvas.width, n.canvas.height),
        m = {},
        q = null,
        ce = {},
        v = {},
        _ = new WeakMap,
        w = [],
        x = null,
        g = !1,
        S = null,
        M = null,
        T = null,
        P = null,
        R = null,
        b = null,
        N = null,
        G = new Ne(0,0,0),
        C = 0,
        I = !1,
        K = null,
        se = null,
        B = null,
        ie = null,
        J = null,
        de.set(0, 0, n.canvas.width, n.canvas.height),
        Se.set(0, 0, n.canvas.width, n.canvas.height),
        a.reset(),
        c.reset(),
        f.reset()
    }
    return {
        buffers: {
            color: a,
            depth: c,
            stencil: f
        },
        enable: ze,
        disable: ut,
        bindFramebuffer: He,
        drawBuffers: z,
        useProgram: ge,
        setBlending: pe,
        setMaterial: Oe,
        setFlipSided: De,
        setCullFace: Ge,
        setLineWidth: ft,
        setPolygonOffset: O,
        setScissorTest: L,
        activeTexture: oe,
        bindTexture: le,
        unbindTexture: ye,
        compressedTexImage2D: me,
        compressedTexImage3D: st,
        texImage2D: St,
        texImage3D: Ke,
        updateUBOMapping: Tt,
        uniformBlockBinding: ht,
        texStorage2D: we,
        texStorage3D: nn,
        texSubImage2D: et,
        texSubImage3D: Te,
        compressedTexSubImage2D: Re,
        compressedTexSubImage3D: ot,
        scissor: Ye,
        viewport: je,
        reset: zt
    }
}
function nF(n, e, t, i, r, s, o) {
    const a = r.isWebGL2
      , c = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , f = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , h = new he
      , d = new WeakMap;
    let m;
    const v = new WeakMap;
    let _ = !1;
    try {
        _ = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function w(O, L) {
        return _ ? new OffscreenCanvas(O,L) : ef("canvas")
    }
    function x(O, L, oe, le) {
        let ye = 1;
        const me = ft(O);
        if ((me.width > le || me.height > le) && (ye = le / Math.max(me.width, me.height)),
        ye < 1 || L === !0)
            if (typeof HTMLImageElement < "u" && O instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && O instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && O instanceof ImageBitmap || typeof VideoFrame < "u" && O instanceof VideoFrame) {
                const st = L ? Cp : Math.floor
                  , et = st(ye * me.width)
                  , Te = st(ye * me.height);
                m === void 0 && (m = w(et, Te));
                const Re = oe ? w(et, Te) : m;
                return Re.width = et,
                Re.height = Te,
                Re.getContext("2d").drawImage(O, 0, 0, et, Te),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + me.width + "x" + me.height + ") to (" + et + "x" + Te + ")."),
                Re
            } else
                return "data"in O && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + me.width + "x" + me.height + ")."),
                O;
        return O
    }
    function g(O) {
        const L = ft(O);
        return Ey(L.width) && Ey(L.height)
    }
    function S(O) {
        return a ? !1 : O.wrapS !== ei || O.wrapT !== ei || O.minFilter !== hn && O.minFilter !== Wt
    }
    function M(O, L) {
        return O.generateMipmaps && L && O.minFilter !== hn && O.minFilter !== Wt
    }
    function T(O) {
        n.generateMipmap(O)
    }
    function P(O, L, oe, le, ye=!1) {
        if (a === !1)
            return L;
        if (O !== null) {
            if (n[O] !== void 0)
                return n[O];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + O + "'")
        }
        let me = L;
        if (L === n.RED && (oe === n.FLOAT && (me = n.R32F),
        oe === n.HALF_FLOAT && (me = n.R16F),
        oe === n.UNSIGNED_BYTE && (me = n.R8)),
        L === n.RED_INTEGER && (oe === n.UNSIGNED_BYTE && (me = n.R8UI),
        oe === n.UNSIGNED_SHORT && (me = n.R16UI),
        oe === n.UNSIGNED_INT && (me = n.R32UI),
        oe === n.BYTE && (me = n.R8I),
        oe === n.SHORT && (me = n.R16I),
        oe === n.INT && (me = n.R32I)),
        L === n.RG && (oe === n.FLOAT && (me = n.RG32F),
        oe === n.HALF_FLOAT && (me = n.RG16F),
        oe === n.UNSIGNED_BYTE && (me = n.RG8)),
        L === n.RG_INTEGER && (oe === n.UNSIGNED_BYTE && (me = n.RG8UI),
        oe === n.UNSIGNED_SHORT && (me = n.RG16UI),
        oe === n.UNSIGNED_INT && (me = n.RG32UI),
        oe === n.BYTE && (me = n.RG8I),
        oe === n.SHORT && (me = n.RG16I),
        oe === n.INT && (me = n.RG32I)),
        L === n.RGBA) {
            const st = ye ? Zc : Ut.getTransfer(le);
            oe === n.FLOAT && (me = n.RGBA32F),
            oe === n.HALF_FLOAT && (me = n.RGBA16F),
            oe === n.UNSIGNED_BYTE && (me = st === Bt ? n.SRGB8_ALPHA8 : n.RGBA8),
            oe === n.UNSIGNED_SHORT_4_4_4_4 && (me = n.RGBA4),
            oe === n.UNSIGNED_SHORT_5_5_5_1 && (me = n.RGB5_A1)
        }
        return (me === n.R16F || me === n.R32F || me === n.RG16F || me === n.RG32F || me === n.RGBA16F || me === n.RGBA32F) && e.get("EXT_color_buffer_float"),
        me
    }
    function R(O, L, oe) {
        return M(O, oe) === !0 || O.isFramebufferTexture && O.minFilter !== hn && O.minFilter !== Wt ? Math.log2(Math.max(L.width, L.height)) + 1 : O.mipmaps !== void 0 && O.mipmaps.length > 0 ? O.mipmaps.length : O.isCompressedTexture && Array.isArray(O.image) ? L.mipmaps.length : 1
    }
    function b(O) {
        return O === hn || O === Tp || O === Jo ? n.NEAREST : n.LINEAR
    }
    function N(O) {
        const L = O.target;
        L.removeEventListener("dispose", N),
        C(L),
        L.isVideoTexture && d.delete(L)
    }
    function G(O) {
        const L = O.target;
        L.removeEventListener("dispose", G),
        K(L)
    }
    function C(O) {
        const L = i.get(O);
        if (L.__webglInit === void 0)
            return;
        const oe = O.source
          , le = v.get(oe);
        if (le) {
            const ye = le[L.__cacheKey];
            ye.usedTimes--,
            ye.usedTimes === 0 && I(O),
            Object.keys(le).length === 0 && v.delete(oe)
        }
        i.remove(O)
    }
    function I(O) {
        const L = i.get(O);
        n.deleteTexture(L.__webglTexture);
        const oe = O.source
          , le = v.get(oe);
        delete le[L.__cacheKey],
        o.memory.textures--
    }
    function K(O) {
        const L = i.get(O);
        if (O.depthTexture && O.depthTexture.dispose(),
        O.isWebGLCubeRenderTarget)
            for (let le = 0; le < 6; le++) {
                if (Array.isArray(L.__webglFramebuffer[le]))
                    for (let ye = 0; ye < L.__webglFramebuffer[le].length; ye++)
                        n.deleteFramebuffer(L.__webglFramebuffer[le][ye]);
                else
                    n.deleteFramebuffer(L.__webglFramebuffer[le]);
                L.__webglDepthbuffer && n.deleteRenderbuffer(L.__webglDepthbuffer[le])
            }
        else {
            if (Array.isArray(L.__webglFramebuffer))
                for (let le = 0; le < L.__webglFramebuffer.length; le++)
                    n.deleteFramebuffer(L.__webglFramebuffer[le]);
            else
                n.deleteFramebuffer(L.__webglFramebuffer);
            if (L.__webglDepthbuffer && n.deleteRenderbuffer(L.__webglDepthbuffer),
            L.__webglMultisampledFramebuffer && n.deleteFramebuffer(L.__webglMultisampledFramebuffer),
            L.__webglColorRenderbuffer)
                for (let le = 0; le < L.__webglColorRenderbuffer.length; le++)
                    L.__webglColorRenderbuffer[le] && n.deleteRenderbuffer(L.__webglColorRenderbuffer[le]);
            L.__webglDepthRenderbuffer && n.deleteRenderbuffer(L.__webglDepthRenderbuffer)
        }
        const oe = O.textures;
        for (let le = 0, ye = oe.length; le < ye; le++) {
            const me = i.get(oe[le]);
            me.__webglTexture && (n.deleteTexture(me.__webglTexture),
            o.memory.textures--),
            i.remove(oe[le])
        }
        i.remove(O)
    }
    let se = 0;
    function B() {
        se = 0
    }
    function ie() {
        const O = se;
        return O >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + O + " texture units while this GPU supports only " + r.maxTextures),
        se += 1,
        O
    }
    function J(O) {
        const L = [];
        return L.push(O.wrapS),
        L.push(O.wrapT),
        L.push(O.wrapR || 0),
        L.push(O.magFilter),
        L.push(O.minFilter),
        L.push(O.anisotropy),
        L.push(O.internalFormat),
        L.push(O.format),
        L.push(O.type),
        L.push(O.generateMipmaps),
        L.push(O.premultiplyAlpha),
        L.push(O.flipY),
        L.push(O.unpackAlignment),
        L.push(O.colorSpace),
        L.join()
    }
    function ue(O, L) {
        const oe = i.get(O);
        if (O.isVideoTexture && De(O),
        O.isRenderTargetTexture === !1 && O.version > 0 && oe.__version !== O.version) {
            const le = O.image;
            if (le === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (le.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                Se(oe, O, L);
                return
            }
        }
        t.bindTexture(n.TEXTURE_2D, oe.__webglTexture, n.TEXTURE0 + L)
    }
    function F(O, L) {
        const oe = i.get(O);
        if (O.version > 0 && oe.__version !== O.version) {
            Se(oe, O, L);
            return
        }
        t.bindTexture(n.TEXTURE_2D_ARRAY, oe.__webglTexture, n.TEXTURE0 + L)
    }
    function H(O, L) {
        const oe = i.get(O);
        if (O.version > 0 && oe.__version !== O.version) {
            Se(oe, O, L);
            return
        }
        t.bindTexture(n.TEXTURE_3D, oe.__webglTexture, n.TEXTURE0 + L)
    }
    function V(O, L) {
        const oe = i.get(O);
        if (O.version > 0 && oe.__version !== O.version) {
            ke(oe, O, L);
            return
        }
        t.bindTexture(n.TEXTURE_CUBE_MAP, oe.__webglTexture, n.TEXTURE0 + L)
    }
    const q = {
        [Wc]: n.REPEAT,
        [ei]: n.CLAMP_TO_EDGE,
        [Xc]: n.MIRRORED_REPEAT
    }
      , ce = {
        [hn]: n.NEAREST,
        [Tp]: n.NEAREST_MIPMAP_NEAREST,
        [Jo]: n.NEAREST_MIPMAP_LINEAR,
        [Wt]: n.LINEAR,
        [_c]: n.LINEAR_MIPMAP_NEAREST,
        [Gr]: n.LINEAR_MIPMAP_LINEAR
    }
      , Ce = {
        [K2]: n.NEVER,
        [iC]: n.ALWAYS,
        [Q2]: n.LESS,
        [G_]: n.LEQUAL,
        [$2]: n.EQUAL,
        [nC]: n.GEQUAL,
        [eC]: n.GREATER,
        [tC]: n.NOTEQUAL
    };
    function Z(O, L, oe) {
        if (L.type === wi && e.has("OES_texture_float_linear") === !1 && (L.magFilter === Wt || L.magFilter === _c || L.magFilter === Jo || L.magFilter === Gr || L.minFilter === Wt || L.minFilter === _c || L.minFilter === Jo || L.minFilter === Gr) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
        oe ? (n.texParameteri(O, n.TEXTURE_WRAP_S, q[L.wrapS]),
        n.texParameteri(O, n.TEXTURE_WRAP_T, q[L.wrapT]),
        (O === n.TEXTURE_3D || O === n.TEXTURE_2D_ARRAY) && n.texParameteri(O, n.TEXTURE_WRAP_R, q[L.wrapR]),
        n.texParameteri(O, n.TEXTURE_MAG_FILTER, ce[L.magFilter]),
        n.texParameteri(O, n.TEXTURE_MIN_FILTER, ce[L.minFilter])) : (n.texParameteri(O, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE),
        n.texParameteri(O, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE),
        (O === n.TEXTURE_3D || O === n.TEXTURE_2D_ARRAY) && n.texParameteri(O, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE),
        (L.wrapS !== ei || L.wrapT !== ei) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
        n.texParameteri(O, n.TEXTURE_MAG_FILTER, b(L.magFilter)),
        n.texParameteri(O, n.TEXTURE_MIN_FILTER, b(L.minFilter)),
        L.minFilter !== hn && L.minFilter !== Wt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        L.compareFunction && (n.texParameteri(O, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(O, n.TEXTURE_COMPARE_FUNC, Ce[L.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            if (L.magFilter === hn || L.minFilter !== Jo && L.minFilter !== Gr || L.type === wi && e.has("OES_texture_float_linear") === !1 || a === !1 && L.type === va && e.has("OES_texture_half_float_linear") === !1)
                return;
            if (L.anisotropy > 1 || i.get(L).__currentAnisotropy) {
                const le = e.get("EXT_texture_filter_anisotropic");
                n.texParameterf(O, le.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(L.anisotropy, r.getMaxAnisotropy())),
                i.get(L).__currentAnisotropy = L.anisotropy
            }
        }
    }
    function de(O, L) {
        let oe = !1;
        O.__webglInit === void 0 && (O.__webglInit = !0,
        L.addEventListener("dispose", N));
        const le = L.source;
        let ye = v.get(le);
        ye === void 0 && (ye = {},
        v.set(le, ye));
        const me = J(L);
        if (me !== O.__cacheKey) {
            ye[me] === void 0 && (ye[me] = {
                texture: n.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            oe = !0),
            ye[me].usedTimes++;
            const st = ye[O.__cacheKey];
            st !== void 0 && (ye[O.__cacheKey].usedTimes--,
            st.usedTimes === 0 && I(L)),
            O.__cacheKey = me,
            O.__webglTexture = ye[me].texture
        }
        return oe
    }
    function Se(O, L, oe) {
        let le = n.TEXTURE_2D;
        (L.isDataArrayTexture || L.isCompressedArrayTexture) && (le = n.TEXTURE_2D_ARRAY),
        L.isData3DTexture && (le = n.TEXTURE_3D);
        const ye = de(O, L)
          , me = L.source;
        t.bindTexture(le, O.__webglTexture, n.TEXTURE0 + oe);
        const st = i.get(me);
        if (me.version !== st.__version || ye === !0) {
            t.activeTexture(n.TEXTURE0 + oe);
            const et = Ut.getPrimaries(Ut.workingColorSpace)
              , Te = L.colorSpace === ds ? null : Ut.getPrimaries(L.colorSpace)
              , Re = L.colorSpace === ds || et === Te ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, L.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, L.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, L.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Re);
            const ot = S(L) && g(L.image) === !1;
            let we = x(L.image, ot, !1, r.maxTextureSize);
            we = Ge(L, we);
            const nn = g(we) || a
              , St = s.convert(L.format, L.colorSpace);
            let Ke = s.convert(L.type)
              , Ye = P(L.internalFormat, St, Ke, L.colorSpace, L.isVideoTexture);
            Z(le, L, nn);
            let je;
            const Tt = L.mipmaps
              , ht = a && L.isVideoTexture !== !0 && Ye !== H_
              , zt = st.__version === void 0 || ye === !0
              , X = me.dataReady
              , be = R(L, we, nn);
            if (L.isDepthTexture)
                Ye = n.DEPTH_COMPONENT,
                a ? L.type === wi ? Ye = n.DEPTH_COMPONENT32F : L.type === vs ? Ye = n.DEPTH_COMPONENT24 : L.type === uo ? Ye = n.DEPTH24_STENCIL8 : Ye = n.DEPTH_COMPONENT16 : L.type === wi && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                L.format === co && Ye === n.DEPTH_COMPONENT && L.type !== Qp && L.type !== vs && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                L.type = vs,
                Ke = s.convert(L.type)),
                L.format === ya && Ye === n.DEPTH_COMPONENT && (Ye = n.DEPTH_STENCIL,
                L.type !== uo && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                L.type = uo,
                Ke = s.convert(L.type))),
                zt && (ht ? t.texStorage2D(n.TEXTURE_2D, 1, Ye, we.width, we.height) : t.texImage2D(n.TEXTURE_2D, 0, Ye, we.width, we.height, 0, St, Ke, null));
            else if (L.isDataTexture)
                if (Tt.length > 0 && nn) {
                    ht && zt && t.texStorage2D(n.TEXTURE_2D, be, Ye, Tt[0].width, Tt[0].height);
                    for (let ee = 0, Ee = Tt.length; ee < Ee; ee++)
                        je = Tt[ee],
                        ht ? X && t.texSubImage2D(n.TEXTURE_2D, ee, 0, 0, je.width, je.height, St, Ke, je.data) : t.texImage2D(n.TEXTURE_2D, ee, Ye, je.width, je.height, 0, St, Ke, je.data);
                    L.generateMipmaps = !1
                } else
                    ht ? (zt && t.texStorage2D(n.TEXTURE_2D, be, Ye, we.width, we.height),
                    X && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, we.width, we.height, St, Ke, we.data)) : t.texImage2D(n.TEXTURE_2D, 0, Ye, we.width, we.height, 0, St, Ke, we.data);
            else if (L.isCompressedTexture)
                if (L.isCompressedArrayTexture) {
                    ht && zt && t.texStorage3D(n.TEXTURE_2D_ARRAY, be, Ye, Tt[0].width, Tt[0].height, we.depth);
                    for (let ee = 0, Ee = Tt.length; ee < Ee; ee++)
                        je = Tt[ee],
                        L.format !== ci ? St !== null ? ht ? X && t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, ee, 0, 0, 0, je.width, je.height, we.depth, St, je.data, 0, 0) : t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, ee, Ye, je.width, je.height, we.depth, 0, je.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ht ? X && t.texSubImage3D(n.TEXTURE_2D_ARRAY, ee, 0, 0, 0, je.width, je.height, we.depth, St, Ke, je.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, ee, Ye, je.width, je.height, we.depth, 0, St, Ke, je.data)
                } else {
                    ht && zt && t.texStorage2D(n.TEXTURE_2D, be, Ye, Tt[0].width, Tt[0].height);
                    for (let ee = 0, Ee = Tt.length; ee < Ee; ee++)
                        je = Tt[ee],
                        L.format !== ci ? St !== null ? ht ? X && t.compressedTexSubImage2D(n.TEXTURE_2D, ee, 0, 0, je.width, je.height, St, je.data) : t.compressedTexImage2D(n.TEXTURE_2D, ee, Ye, je.width, je.height, 0, je.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ht ? X && t.texSubImage2D(n.TEXTURE_2D, ee, 0, 0, je.width, je.height, St, Ke, je.data) : t.texImage2D(n.TEXTURE_2D, ee, Ye, je.width, je.height, 0, St, Ke, je.data)
                }
            else if (L.isDataArrayTexture)
                ht ? (zt && t.texStorage3D(n.TEXTURE_2D_ARRAY, be, Ye, we.width, we.height, we.depth),
                X && t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, we.width, we.height, we.depth, St, Ke, we.data)) : t.texImage3D(n.TEXTURE_2D_ARRAY, 0, Ye, we.width, we.height, we.depth, 0, St, Ke, we.data);
            else if (L.isData3DTexture)
                ht ? (zt && t.texStorage3D(n.TEXTURE_3D, be, Ye, we.width, we.height, we.depth),
                X && t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, we.width, we.height, we.depth, St, Ke, we.data)) : t.texImage3D(n.TEXTURE_3D, 0, Ye, we.width, we.height, we.depth, 0, St, Ke, we.data);
            else if (L.isFramebufferTexture) {
                if (zt)
                    if (ht)
                        t.texStorage2D(n.TEXTURE_2D, be, Ye, we.width, we.height);
                    else {
                        let ee = we.width
                          , Ee = we.height;
                        for (let Pe = 0; Pe < be; Pe++)
                            t.texImage2D(n.TEXTURE_2D, Pe, Ye, ee, Ee, 0, St, Ke, null),
                            ee >>= 1,
                            Ee >>= 1
                    }
            } else if (Tt.length > 0 && nn) {
                if (ht && zt) {
                    const ee = ft(Tt[0]);
                    t.texStorage2D(n.TEXTURE_2D, be, Ye, ee.width, ee.height)
                }
                for (let ee = 0, Ee = Tt.length; ee < Ee; ee++)
                    je = Tt[ee],
                    ht ? X && t.texSubImage2D(n.TEXTURE_2D, ee, 0, 0, St, Ke, je) : t.texImage2D(n.TEXTURE_2D, ee, Ye, St, Ke, je);
                L.generateMipmaps = !1
            } else if (ht) {
                if (zt) {
                    const ee = ft(we);
                    t.texStorage2D(n.TEXTURE_2D, be, Ye, ee.width, ee.height)
                }
                X && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, St, Ke, we)
            } else
                t.texImage2D(n.TEXTURE_2D, 0, Ye, St, Ke, we);
            M(L, nn) && T(le),
            st.__version = me.version,
            L.onUpdate && L.onUpdate(L)
        }
        O.__version = L.version
    }
    function ke(O, L, oe) {
        if (L.image.length !== 6)
            return;
        const le = de(O, L)
          , ye = L.source;
        t.bindTexture(n.TEXTURE_CUBE_MAP, O.__webglTexture, n.TEXTURE0 + oe);
        const me = i.get(ye);
        if (ye.version !== me.__version || le === !0) {
            t.activeTexture(n.TEXTURE0 + oe);
            const st = Ut.getPrimaries(Ut.workingColorSpace)
              , et = L.colorSpace === ds ? null : Ut.getPrimaries(L.colorSpace)
              , Te = L.colorSpace === ds || st === et ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, L.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, L.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, L.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Te);
            const Re = L.isCompressedTexture || L.image[0].isCompressedTexture
              , ot = L.image[0] && L.image[0].isDataTexture
              , we = [];
            for (let ee = 0; ee < 6; ee++)
                !Re && !ot ? we[ee] = x(L.image[ee], !1, !0, r.maxCubemapSize) : we[ee] = ot ? L.image[ee].image : L.image[ee],
                we[ee] = Ge(L, we[ee]);
            const nn = we[0]
              , St = g(nn) || a
              , Ke = s.convert(L.format, L.colorSpace)
              , Ye = s.convert(L.type)
              , je = P(L.internalFormat, Ke, Ye, L.colorSpace)
              , Tt = a && L.isVideoTexture !== !0
              , ht = me.__version === void 0 || le === !0
              , zt = ye.dataReady;
            let X = R(L, nn, St);
            Z(n.TEXTURE_CUBE_MAP, L, St);
            let be;
            if (Re) {
                Tt && ht && t.texStorage2D(n.TEXTURE_CUBE_MAP, X, je, nn.width, nn.height);
                for (let ee = 0; ee < 6; ee++) {
                    be = we[ee].mipmaps;
                    for (let Ee = 0; Ee < be.length; Ee++) {
                        const Pe = be[Ee];
                        L.format !== ci ? Ke !== null ? Tt ? zt && t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ee, Ee, 0, 0, Pe.width, Pe.height, Ke, Pe.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ee, Ee, je, Pe.width, Pe.height, 0, Pe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Tt ? zt && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ee, Ee, 0, 0, Pe.width, Pe.height, Ke, Ye, Pe.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ee, Ee, je, Pe.width, Pe.height, 0, Ke, Ye, Pe.data)
                    }
                }
            } else {
                if (be = L.mipmaps,
                Tt && ht) {
                    be.length > 0 && X++;
                    const ee = ft(we[0]);
                    t.texStorage2D(n.TEXTURE_CUBE_MAP, X, je, ee.width, ee.height)
                }
                for (let ee = 0; ee < 6; ee++)
                    if (ot) {
                        Tt ? zt && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ee, 0, 0, 0, we[ee].width, we[ee].height, Ke, Ye, we[ee].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ee, 0, je, we[ee].width, we[ee].height, 0, Ke, Ye, we[ee].data);
                        for (let Ee = 0; Ee < be.length; Ee++) {
                            const wt = be[Ee].image[ee].image;
                            Tt ? zt && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ee, Ee + 1, 0, 0, wt.width, wt.height, Ke, Ye, wt.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ee, Ee + 1, je, wt.width, wt.height, 0, Ke, Ye, wt.data)
                        }
                    } else {
                        Tt ? zt && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ee, 0, 0, 0, Ke, Ye, we[ee]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ee, 0, je, Ke, Ye, we[ee]);
                        for (let Ee = 0; Ee < be.length; Ee++) {
                            const Pe = be[Ee];
                            Tt ? zt && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ee, Ee + 1, 0, 0, Ke, Ye, Pe.image[ee]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ee, Ee + 1, je, Ke, Ye, Pe.image[ee])
                        }
                    }
            }
            M(L, St) && T(n.TEXTURE_CUBE_MAP),
            me.__version = ye.version,
            L.onUpdate && L.onUpdate(L)
        }
        O.__version = L.version
    }
    function Xe(O, L, oe, le, ye, me) {
        const st = s.convert(oe.format, oe.colorSpace)
          , et = s.convert(oe.type)
          , Te = P(oe.internalFormat, st, et, oe.colorSpace);
        if (!i.get(L).__hasExternalTextures) {
            const ot = Math.max(1, L.width >> me)
              , we = Math.max(1, L.height >> me);
            ye === n.TEXTURE_3D || ye === n.TEXTURE_2D_ARRAY ? t.texImage3D(ye, me, Te, ot, we, L.depth, 0, st, et, null) : t.texImage2D(ye, me, Te, ot, we, 0, st, et, null)
        }
        t.bindFramebuffer(n.FRAMEBUFFER, O),
        Oe(L) ? c.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, le, ye, i.get(oe).__webglTexture, 0, pe(L)) : (ye === n.TEXTURE_2D || ye >= n.TEXTURE_CUBE_MAP_POSITIVE_X && ye <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, le, ye, i.get(oe).__webglTexture, me),
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function ze(O, L, oe) {
        if (n.bindRenderbuffer(n.RENDERBUFFER, O),
        L.depthBuffer && !L.stencilBuffer) {
            let le = a === !0 ? n.DEPTH_COMPONENT24 : n.DEPTH_COMPONENT16;
            if (oe || Oe(L)) {
                const ye = L.depthTexture;
                ye && ye.isDepthTexture && (ye.type === wi ? le = n.DEPTH_COMPONENT32F : ye.type === vs && (le = n.DEPTH_COMPONENT24));
                const me = pe(L);
                Oe(L) ? c.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, me, le, L.width, L.height) : n.renderbufferStorageMultisample(n.RENDERBUFFER, me, le, L.width, L.height)
            } else
                n.renderbufferStorage(n.RENDERBUFFER, le, L.width, L.height);
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, O)
        } else if (L.depthBuffer && L.stencilBuffer) {
            const le = pe(L);
            oe && Oe(L) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, le, n.DEPTH24_STENCIL8, L.width, L.height) : Oe(L) ? c.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, le, n.DEPTH24_STENCIL8, L.width, L.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, L.width, L.height),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, O)
        } else {
            const le = L.textures;
            for (let ye = 0; ye < le.length; ye++) {
                const me = le[ye]
                  , st = s.convert(me.format, me.colorSpace)
                  , et = s.convert(me.type)
                  , Te = P(me.internalFormat, st, et, me.colorSpace)
                  , Re = pe(L);
                oe && Oe(L) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Re, Te, L.width, L.height) : Oe(L) ? c.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Re, Te, L.width, L.height) : n.renderbufferStorage(n.RENDERBUFFER, Te, L.width, L.height)
            }
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null)
    }
    function ut(O, L) {
        if (L && L.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(n.FRAMEBUFFER, O),
        !(L.depthTexture && L.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!i.get(L.depthTexture).__webglTexture || L.depthTexture.image.width !== L.width || L.depthTexture.image.height !== L.height) && (L.depthTexture.image.width = L.width,
        L.depthTexture.image.height = L.height,
        L.depthTexture.needsUpdate = !0),
        ue(L.depthTexture, 0);
        const le = i.get(L.depthTexture).__webglTexture
          , ye = pe(L);
        if (L.depthTexture.format === co)
            Oe(L) ? c.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, le, 0, ye) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, le, 0);
        else if (L.depthTexture.format === ya)
            Oe(L) ? c.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, le, 0, ye) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, le, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function He(O) {
        const L = i.get(O)
          , oe = O.isWebGLCubeRenderTarget === !0;
        if (O.depthTexture && !L.__autoAllocateDepthBuffer) {
            if (oe)
                throw new Error("target.depthTexture not supported in Cube render targets");
            ut(L.__webglFramebuffer, O)
        } else if (oe) {
            L.__webglDepthbuffer = [];
            for (let le = 0; le < 6; le++)
                t.bindFramebuffer(n.FRAMEBUFFER, L.__webglFramebuffer[le]),
                L.__webglDepthbuffer[le] = n.createRenderbuffer(),
                ze(L.__webglDepthbuffer[le], O, !1)
        } else
            t.bindFramebuffer(n.FRAMEBUFFER, L.__webglFramebuffer),
            L.__webglDepthbuffer = n.createRenderbuffer(),
            ze(L.__webglDepthbuffer, O, !1);
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function z(O, L, oe) {
        const le = i.get(O);
        L !== void 0 && Xe(le.__webglFramebuffer, O, O.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0),
        oe !== void 0 && He(O)
    }
    function ge(O) {
        const L = O.texture
          , oe = i.get(O)
          , le = i.get(L);
        O.addEventListener("dispose", G);
        const ye = O.textures
          , me = O.isWebGLCubeRenderTarget === !0
          , st = ye.length > 1
          , et = g(O) || a;
        if (st || (le.__webglTexture === void 0 && (le.__webglTexture = n.createTexture()),
        le.__version = L.version,
        o.memory.textures++),
        me) {
            oe.__webglFramebuffer = [];
            for (let Te = 0; Te < 6; Te++)
                if (a && L.mipmaps && L.mipmaps.length > 0) {
                    oe.__webglFramebuffer[Te] = [];
                    for (let Re = 0; Re < L.mipmaps.length; Re++)
                        oe.__webglFramebuffer[Te][Re] = n.createFramebuffer()
                } else
                    oe.__webglFramebuffer[Te] = n.createFramebuffer()
        } else {
            if (a && L.mipmaps && L.mipmaps.length > 0) {
                oe.__webglFramebuffer = [];
                for (let Te = 0; Te < L.mipmaps.length; Te++)
                    oe.__webglFramebuffer[Te] = n.createFramebuffer()
            } else
                oe.__webglFramebuffer = n.createFramebuffer();
            if (st)
                if (r.drawBuffers)
                    for (let Te = 0, Re = ye.length; Te < Re; Te++) {
                        const ot = i.get(ye[Te]);
                        ot.__webglTexture === void 0 && (ot.__webglTexture = n.createTexture(),
                        o.memory.textures++)
                    }
                else
                    console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && O.samples > 0 && Oe(O) === !1) {
                oe.__webglMultisampledFramebuffer = n.createFramebuffer(),
                oe.__webglColorRenderbuffer = [],
                t.bindFramebuffer(n.FRAMEBUFFER, oe.__webglMultisampledFramebuffer);
                for (let Te = 0; Te < ye.length; Te++) {
                    const Re = ye[Te];
                    oe.__webglColorRenderbuffer[Te] = n.createRenderbuffer(),
                    n.bindRenderbuffer(n.RENDERBUFFER, oe.__webglColorRenderbuffer[Te]);
                    const ot = s.convert(Re.format, Re.colorSpace)
                      , we = s.convert(Re.type)
                      , nn = P(Re.internalFormat, ot, we, Re.colorSpace, O.isXRRenderTarget === !0)
                      , St = pe(O);
                    n.renderbufferStorageMultisample(n.RENDERBUFFER, St, nn, O.width, O.height),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Te, n.RENDERBUFFER, oe.__webglColorRenderbuffer[Te])
                }
                n.bindRenderbuffer(n.RENDERBUFFER, null),
                O.depthBuffer && (oe.__webglDepthRenderbuffer = n.createRenderbuffer(),
                ze(oe.__webglDepthRenderbuffer, O, !0)),
                t.bindFramebuffer(n.FRAMEBUFFER, null)
            }
        }
        if (me) {
            t.bindTexture(n.TEXTURE_CUBE_MAP, le.__webglTexture),
            Z(n.TEXTURE_CUBE_MAP, L, et);
            for (let Te = 0; Te < 6; Te++)
                if (a && L.mipmaps && L.mipmaps.length > 0)
                    for (let Re = 0; Re < L.mipmaps.length; Re++)
                        Xe(oe.__webglFramebuffer[Te][Re], O, L, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, Re);
                else
                    Xe(oe.__webglFramebuffer[Te], O, L, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, 0);
            M(L, et) && T(n.TEXTURE_CUBE_MAP),
            t.unbindTexture()
        } else if (st) {
            for (let Te = 0, Re = ye.length; Te < Re; Te++) {
                const ot = ye[Te]
                  , we = i.get(ot);
                t.bindTexture(n.TEXTURE_2D, we.__webglTexture),
                Z(n.TEXTURE_2D, ot, et),
                Xe(oe.__webglFramebuffer, O, ot, n.COLOR_ATTACHMENT0 + Te, n.TEXTURE_2D, 0),
                M(ot, et) && T(n.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let Te = n.TEXTURE_2D;
            if ((O.isWebGL3DRenderTarget || O.isWebGLArrayRenderTarget) && (a ? Te = O.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            t.bindTexture(Te, le.__webglTexture),
            Z(Te, L, et),
            a && L.mipmaps && L.mipmaps.length > 0)
                for (let Re = 0; Re < L.mipmaps.length; Re++)
                    Xe(oe.__webglFramebuffer[Re], O, L, n.COLOR_ATTACHMENT0, Te, Re);
            else
                Xe(oe.__webglFramebuffer, O, L, n.COLOR_ATTACHMENT0, Te, 0);
            M(L, et) && T(Te),
            t.unbindTexture()
        }
        O.depthBuffer && He(O)
    }
    function fe(O) {
        const L = g(O) || a
          , oe = O.textures;
        for (let le = 0, ye = oe.length; le < ye; le++) {
            const me = oe[le];
            if (M(me, L)) {
                const st = O.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D
                  , et = i.get(me).__webglTexture;
                t.bindTexture(st, et),
                T(st),
                t.unbindTexture()
            }
        }
    }
    function Me(O) {
        if (a && O.samples > 0 && Oe(O) === !1) {
            const L = O.textures
              , oe = O.width
              , le = O.height;
            let ye = n.COLOR_BUFFER_BIT;
            const me = []
              , st = O.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
              , et = i.get(O)
              , Te = L.length > 1;
            if (Te)
                for (let Re = 0; Re < L.length; Re++)
                    t.bindFramebuffer(n.FRAMEBUFFER, et.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Re, n.RENDERBUFFER, null),
                    t.bindFramebuffer(n.FRAMEBUFFER, et.__webglFramebuffer),
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Re, n.TEXTURE_2D, null, 0);
            t.bindFramebuffer(n.READ_FRAMEBUFFER, et.__webglMultisampledFramebuffer),
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, et.__webglFramebuffer);
            for (let Re = 0; Re < L.length; Re++) {
                me.push(n.COLOR_ATTACHMENT0 + Re),
                O.depthBuffer && me.push(st);
                const ot = et.__ignoreDepthValues !== void 0 ? et.__ignoreDepthValues : !1;
                if (ot === !1 && (O.depthBuffer && (ye |= n.DEPTH_BUFFER_BIT),
                O.stencilBuffer && (ye |= n.STENCIL_BUFFER_BIT)),
                Te && n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, et.__webglColorRenderbuffer[Re]),
                ot === !0 && (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [st]),
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [st])),
                Te) {
                    const we = i.get(L[Re]).__webglTexture;
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, we, 0)
                }
                n.blitFramebuffer(0, 0, oe, le, 0, 0, oe, le, ye, n.NEAREST),
                f && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, me)
            }
            if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
            Te)
                for (let Re = 0; Re < L.length; Re++) {
                    t.bindFramebuffer(n.FRAMEBUFFER, et.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Re, n.RENDERBUFFER, et.__webglColorRenderbuffer[Re]);
                    const ot = i.get(L[Re]).__webglTexture;
                    t.bindFramebuffer(n.FRAMEBUFFER, et.__webglFramebuffer),
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Re, n.TEXTURE_2D, ot, 0)
                }
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, et.__webglMultisampledFramebuffer)
        }
    }
    function pe(O) {
        return Math.min(r.maxSamples, O.samples)
    }
    function Oe(O) {
        const L = i.get(O);
        return a && O.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && L.__useRenderToTexture !== !1
    }
    function De(O) {
        const L = o.render.frame;
        d.get(O) !== L && (d.set(O, L),
        O.update())
    }
    function Ge(O, L) {
        const oe = O.colorSpace
          , le = O.format
          , ye = O.type;
        return O.isCompressedTexture === !0 || O.isVideoTexture === !0 || O.format === Ap || oe !== Cs && oe !== ds && (Ut.getTransfer(oe) === Bt ? a === !1 ? e.has("EXT_sRGB") === !0 && le === ci ? (O.format = Ap,
        O.minFilter = Wt,
        O.generateMipmaps = !1) : L = X_.sRGBToLinear(L) : (le !== ci || ye !== jr) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", oe)),
        L
    }
    function ft(O) {
        return typeof HTMLImageElement < "u" && O instanceof HTMLImageElement ? (h.width = O.naturalWidth || O.width,
        h.height = O.naturalHeight || O.height) : typeof VideoFrame < "u" && O instanceof VideoFrame ? (h.width = O.displayWidth,
        h.height = O.displayHeight) : (h.width = O.width,
        h.height = O.height),
        h
    }
    this.allocateTextureUnit = ie,
    this.resetTextureUnits = B,
    this.setTexture2D = ue,
    this.setTexture2DArray = F,
    this.setTexture3D = H,
    this.setTextureCube = V,
    this.rebindTextures = z,
    this.setupRenderTarget = ge,
    this.updateRenderTargetMipmap = fe,
    this.updateMultisampleRenderTarget = Me,
    this.setupDepthRenderbuffer = He,
    this.setupFrameBufferTexture = Xe,
    this.useMultisampledRTT = Oe
}
function _C(n, e, t) {
    const i = t.isWebGL2;
    function r(s, o=ds) {
        let a;
        const c = Ut.getTransfer(o);
        if (s === jr)
            return n.UNSIGNED_BYTE;
        if (s === U_)
            return n.UNSIGNED_SHORT_4_4_4_4;
        if (s === O_)
            return n.UNSIGNED_SHORT_5_5_5_1;
        if (s === k2)
            return n.BYTE;
        if (s === z2)
            return n.SHORT;
        if (s === Qp)
            return n.UNSIGNED_SHORT;
        if (s === D_)
            return n.INT;
        if (s === vs)
            return n.UNSIGNED_INT;
        if (s === wi)
            return n.FLOAT;
        if (s === va)
            return i ? n.HALF_FLOAT : (a = e.get("OES_texture_half_float"),
            a !== null ? a.HALF_FLOAT_OES : null);
        if (s === B2)
            return n.ALPHA;
        if (s === ci)
            return n.RGBA;
        if (s === H2)
            return n.LUMINANCE;
        if (s === V2)
            return n.LUMINANCE_ALPHA;
        if (s === co)
            return n.DEPTH_COMPONENT;
        if (s === ya)
            return n.DEPTH_STENCIL;
        if (s === Ap)
            return a = e.get("EXT_sRGB"),
            a !== null ? a.SRGB_ALPHA_EXT : null;
        if (s === F_)
            return n.RED;
        if (s === k_)
            return n.RED_INTEGER;
        if (s === G2)
            return n.RG;
        if (s === z_)
            return n.RG_INTEGER;
        if (s === B_)
            return n.RGBA_INTEGER;
        if (s === Xd || s === Yd || s === jd || s === qd)
            if (c === Bt)
                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                a !== null) {
                    if (s === Xd)
                        return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (s === Yd)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (s === jd)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (s === qd)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (a = e.get("WEBGL_compressed_texture_s3tc"),
            a !== null) {
                if (s === Xd)
                    return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (s === Yd)
                    return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (s === jd)
                    return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (s === qd)
                    return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (s === Kv || s === Qv || s === $v || s === ey)
            if (a = e.get("WEBGL_compressed_texture_pvrtc"),
            a !== null) {
                if (s === Kv)
                    return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (s === Qv)
                    return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (s === $v)
                    return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (s === ey)
                    return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (s === H_)
            return a = e.get("WEBGL_compressed_texture_etc1"),
            a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (s === ty || s === ny)
            if (a = e.get("WEBGL_compressed_texture_etc"),
            a !== null) {
                if (s === ty)
                    return c === Bt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (s === ny)
                    return c === Bt ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (s === iy || s === ry || s === sy || s === oy || s === ay || s === ly || s === uy || s === cy || s === fy || s === hy || s === dy || s === py || s === my || s === gy)
            if (a = e.get("WEBGL_compressed_texture_astc"),
            a !== null) {
                if (s === iy)
                    return c === Bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (s === ry)
                    return c === Bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (s === sy)
                    return c === Bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (s === oy)
                    return c === Bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (s === ay)
                    return c === Bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (s === ly)
                    return c === Bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (s === uy)
                    return c === Bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (s === cy)
                    return c === Bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (s === fy)
                    return c === Bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (s === hy)
                    return c === Bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (s === dy)
                    return c === Bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (s === py)
                    return c === Bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (s === my)
                    return c === Bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (s === gy)
                    return c === Bt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (s === Zd || s === vy || s === yy)
            if (a = e.get("EXT_texture_compression_bptc"),
            a !== null) {
                if (s === Zd)
                    return c === Bt ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (s === vy)
                    return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (s === yy)
                    return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (s === W2 || s === _y || s === xy || s === Sy)
            if (a = e.get("EXT_texture_compression_rgtc"),
            a !== null) {
                if (s === Zd)
                    return a.COMPRESSED_RED_RGTC1_EXT;
                if (s === _y)
                    return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (s === xy)
                    return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (s === Sy)
                    return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return s === uo ? i ? n.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"),
        a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null
    }
    return {
        convert: r
    }
}
class xC extends Dn {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class Il extends bt {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const iF = {
    type: "move"
};
class A0 {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new Il,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new Il,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new U,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new U),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new Il,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new U,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new U),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const i of e.hand.values())
                    this._getHandJoint(t, i)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, i) {
        let r = null
          , s = null
          , o = null;
        const a = this._targetRay
          , c = this._grip
          , f = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (f && e.hand) {
                o = !0;
                for (const w of e.hand.values()) {
                    const x = t.getJointPose(w, i)
                      , g = this._getHandJoint(f, w);
                    x !== null && (g.matrix.fromArray(x.transform.matrix),
                    g.matrix.decompose(g.position, g.rotation, g.scale),
                    g.matrixWorldNeedsUpdate = !0,
                    g.jointRadius = x.radius),
                    g.visible = x !== null
                }
                const h = f.joints["index-finger-tip"]
                  , d = f.joints["thumb-tip"]
                  , m = h.position.distanceTo(d.position)
                  , v = .02
                  , _ = .005;
                f.inputState.pinching && m > v + _ ? (f.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !f.inputState.pinching && m <= v - _ && (f.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                c !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i),
                s !== null && (c.matrix.fromArray(s.transform.matrix),
                c.matrix.decompose(c.position, c.rotation, c.scale),
                c.matrixWorldNeedsUpdate = !0,
                s.linearVelocity ? (c.hasLinearVelocity = !0,
                c.linearVelocity.copy(s.linearVelocity)) : c.hasLinearVelocity = !1,
                s.angularVelocity ? (c.hasAngularVelocity = !0,
                c.angularVelocity.copy(s.angularVelocity)) : c.hasAngularVelocity = !1));
            a !== null && (r = t.getPose(e.targetRaySpace, i),
            r === null && s !== null && (r = s),
            r !== null && (a.matrix.fromArray(r.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            a.matrixWorldNeedsUpdate = !0,
            r.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1,
            r.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(iF)))
        }
        return a !== null && (a.visible = r !== null),
        c !== null && (c.visible = s !== null),
        f !== null && (f.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const i = new Il;
            i.matrixAutoUpdate = !1,
            i.visible = !1,
            e.joints[t.jointName] = i,
            e.add(i)
        }
        return e.joints[t.jointName]
    }
}
const rF = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
  , sF = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class oF {
    constructor() {
        this.texture = null,
        this.mesh = null,
        this.depthNear = 0,
        this.depthFar = 0
    }
    init(e, t, i) {
        if (this.texture === null) {
            const r = new en
              , s = e.properties.get(r);
            s.__webglTexture = t.texture,
            (t.depthNear != i.depthNear || t.depthFar != i.depthFar) && (this.depthNear = t.depthNear,
            this.depthFar = t.depthFar),
            this.texture = r
        }
    }
    render(e, t) {
        if (this.texture !== null) {
            if (this.mesh === null) {
                const i = t.cameras[0].viewport
                  , r = new fr({
                    extensions: {
                        fragDepth: !0
                    },
                    vertexShader: rF,
                    fragmentShader: sF,
                    uniforms: {
                        depthColor: {
                            value: this.texture
                        },
                        depthWidth: {
                            value: i.z
                        },
                        depthHeight: {
                            value: i.w
                        }
                    }
                });
                this.mesh = new _n(new ou(20,20),r)
            }
            e.render(this.mesh, t)
        }
    }
    reset() {
        this.texture = null,
        this.mesh = null
    }
}
class aF extends Rs {
    constructor(e, t) {
        super();
        const i = this;
        let r = null
          , s = 1
          , o = null
          , a = "local-floor"
          , c = 1
          , f = null
          , h = null
          , d = null
          , m = null
          , v = null
          , _ = null;
        const w = new oF
          , x = t.getContextAttributes();
        let g = null
          , S = null;
        const M = []
          , T = []
          , P = new he;
        let R = null;
        const b = new Dn;
        b.layers.enable(1),
        b.viewport = new Ct;
        const N = new Dn;
        N.layers.enable(2),
        N.viewport = new Ct;
        const G = [b, N]
          , C = new xC;
        C.layers.enable(1),
        C.layers.enable(2);
        let I = null
          , K = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(Z) {
            let de = M[Z];
            return de === void 0 && (de = new A0,
            M[Z] = de),
            de.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(Z) {
            let de = M[Z];
            return de === void 0 && (de = new A0,
            M[Z] = de),
            de.getGripSpace()
        }
        ,
        this.getHand = function(Z) {
            let de = M[Z];
            return de === void 0 && (de = new A0,
            M[Z] = de),
            de.getHandSpace()
        }
        ;
        function se(Z) {
            const de = T.indexOf(Z.inputSource);
            if (de === -1)
                return;
            const Se = M[de];
            Se !== void 0 && (Se.update(Z.inputSource, Z.frame, f || o),
            Se.dispatchEvent({
                type: Z.type,
                data: Z.inputSource
            }))
        }
        function B() {
            r.removeEventListener("select", se),
            r.removeEventListener("selectstart", se),
            r.removeEventListener("selectend", se),
            r.removeEventListener("squeeze", se),
            r.removeEventListener("squeezestart", se),
            r.removeEventListener("squeezeend", se),
            r.removeEventListener("end", B),
            r.removeEventListener("inputsourceschange", ie);
            for (let Z = 0; Z < M.length; Z++) {
                const de = T[Z];
                de !== null && (T[Z] = null,
                M[Z].disconnect(de))
            }
            I = null,
            K = null,
            w.reset(),
            e.setRenderTarget(g),
            v = null,
            m = null,
            d = null,
            r = null,
            S = null,
            Ce.stop(),
            i.isPresenting = !1,
            e.setPixelRatio(R),
            e.setSize(P.width, P.height, !1),
            i.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(Z) {
            s = Z,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(Z) {
            a = Z,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return f || o
        }
        ,
        this.setReferenceSpace = function(Z) {
            f = Z
        }
        ,
        this.getBaseLayer = function() {
            return m !== null ? m : v
        }
        ,
        this.getBinding = function() {
            return d
        }
        ,
        this.getFrame = function() {
            return _
        }
        ,
        this.getSession = function() {
            return r
        }
        ,
        this.setSession = async function(Z) {
            if (r = Z,
            r !== null) {
                if (g = e.getRenderTarget(),
                r.addEventListener("select", se),
                r.addEventListener("selectstart", se),
                r.addEventListener("selectend", se),
                r.addEventListener("squeeze", se),
                r.addEventListener("squeezestart", se),
                r.addEventListener("squeezeend", se),
                r.addEventListener("end", B),
                r.addEventListener("inputsourceschange", ie),
                x.xrCompatible !== !0 && await t.makeXRCompatible(),
                R = e.getPixelRatio(),
                e.getSize(P),
                r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    const de = {
                        antialias: r.renderState.layers === void 0 ? x.antialias : !0,
                        alpha: !0,
                        depth: x.depth,
                        stencil: x.stencil,
                        framebufferScaleFactor: s
                    };
                    v = new XRWebGLLayer(r,t,de),
                    r.updateRenderState({
                        baseLayer: v
                    }),
                    e.setPixelRatio(1),
                    e.setSize(v.framebufferWidth, v.framebufferHeight, !1),
                    S = new cr(v.framebufferWidth,v.framebufferHeight,{
                        format: ci,
                        type: jr,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: x.stencil
                    })
                } else {
                    let de = null
                      , Se = null
                      , ke = null;
                    x.depth && (ke = x.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                    de = x.stencil ? ya : co,
                    Se = x.stencil ? uo : vs);
                    const Xe = {
                        colorFormat: t.RGBA8,
                        depthFormat: ke,
                        scaleFactor: s
                    };
                    d = new XRWebGLBinding(r,t),
                    m = d.createProjectionLayer(Xe),
                    r.updateRenderState({
                        layers: [m]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(m.textureWidth, m.textureHeight, !1),
                    S = new cr(m.textureWidth,m.textureHeight,{
                        format: ci,
                        type: jr,
                        depthTexture: new nm(m.textureWidth,m.textureHeight,Se,void 0,void 0,void 0,void 0,void 0,void 0,de),
                        stencilBuffer: x.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: x.antialias ? 4 : 0
                    });
                    const ze = e.properties.get(S);
                    ze.__ignoreDepthValues = m.ignoreDepthValues
                }
                S.isXRRenderTarget = !0,
                this.setFoveation(c),
                f = null,
                o = await r.requestReferenceSpace(a),
                Ce.setContext(r),
                Ce.start(),
                i.isPresenting = !0,
                i.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (r !== null)
                return r.environmentBlendMode
        }
        ;
        function ie(Z) {
            for (let de = 0; de < Z.removed.length; de++) {
                const Se = Z.removed[de]
                  , ke = T.indexOf(Se);
                ke >= 0 && (T[ke] = null,
                M[ke].disconnect(Se))
            }
            for (let de = 0; de < Z.added.length; de++) {
                const Se = Z.added[de];
                let ke = T.indexOf(Se);
                if (ke === -1) {
                    for (let ze = 0; ze < M.length; ze++)
                        if (ze >= T.length) {
                            T.push(Se),
                            ke = ze;
                            break
                        } else if (T[ze] === null) {
                            T[ze] = Se,
                            ke = ze;
                            break
                        }
                    if (ke === -1)
                        break
                }
                const Xe = M[ke];
                Xe && Xe.connect(Se)
            }
        }
        const J = new U
          , ue = new U;
        function F(Z, de, Se) {
            J.setFromMatrixPosition(de.matrixWorld),
            ue.setFromMatrixPosition(Se.matrixWorld);
            const ke = J.distanceTo(ue)
              , Xe = de.projectionMatrix.elements
              , ze = Se.projectionMatrix.elements
              , ut = Xe[14] / (Xe[10] - 1)
              , He = Xe[14] / (Xe[10] + 1)
              , z = (Xe[9] + 1) / Xe[5]
              , ge = (Xe[9] - 1) / Xe[5]
              , fe = (Xe[8] - 1) / Xe[0]
              , Me = (ze[8] + 1) / ze[0]
              , pe = ut * fe
              , Oe = ut * Me
              , De = ke / (-fe + Me)
              , Ge = De * -fe;
            de.matrixWorld.decompose(Z.position, Z.quaternion, Z.scale),
            Z.translateX(Ge),
            Z.translateZ(De),
            Z.matrixWorld.compose(Z.position, Z.quaternion, Z.scale),
            Z.matrixWorldInverse.copy(Z.matrixWorld).invert();
            const ft = ut + De
              , O = He + De
              , L = pe - Ge
              , oe = Oe + (ke - Ge)
              , le = z * He / O * ft
              , ye = ge * He / O * ft;
            Z.projectionMatrix.makePerspective(L, oe, le, ye, ft, O),
            Z.projectionMatrixInverse.copy(Z.projectionMatrix).invert()
        }
        function H(Z, de) {
            de === null ? Z.matrixWorld.copy(Z.matrix) : Z.matrixWorld.multiplyMatrices(de.matrixWorld, Z.matrix),
            Z.matrixWorldInverse.copy(Z.matrixWorld).invert()
        }
        this.updateCamera = function(Z) {
            if (r === null)
                return;
            w.texture !== null && (Z.near = w.depthNear,
            Z.far = w.depthFar),
            C.near = N.near = b.near = Z.near,
            C.far = N.far = b.far = Z.far,
            (I !== C.near || K !== C.far) && (r.updateRenderState({
                depthNear: C.near,
                depthFar: C.far
            }),
            I = C.near,
            K = C.far,
            b.near = I,
            b.far = K,
            N.near = I,
            N.far = K,
            b.updateProjectionMatrix(),
            N.updateProjectionMatrix(),
            Z.updateProjectionMatrix());
            const de = Z.parent
              , Se = C.cameras;
            H(C, de);
            for (let ke = 0; ke < Se.length; ke++)
                H(Se[ke], de);
            Se.length === 2 ? F(C, b, N) : C.projectionMatrix.copy(b.projectionMatrix),
            V(Z, C, de)
        }
        ;
        function V(Z, de, Se) {
            Se === null ? Z.matrix.copy(de.matrixWorld) : (Z.matrix.copy(Se.matrixWorld),
            Z.matrix.invert(),
            Z.matrix.multiply(de.matrixWorld)),
            Z.matrix.decompose(Z.position, Z.quaternion, Z.scale),
            Z.updateMatrixWorld(!0),
            Z.projectionMatrix.copy(de.projectionMatrix),
            Z.projectionMatrixInverse.copy(de.projectionMatrixInverse),
            Z.isPerspectiveCamera && (Z.fov = Jl * 2 * Math.atan(1 / Z.projectionMatrix.elements[5]),
            Z.zoom = 1)
        }
        this.getCamera = function() {
            return C
        }
        ,
        this.getFoveation = function() {
            if (!(m === null && v === null))
                return c
        }
        ,
        this.setFoveation = function(Z) {
            c = Z,
            m !== null && (m.fixedFoveation = Z),
            v !== null && v.fixedFoveation !== void 0 && (v.fixedFoveation = Z)
        }
        ,
        this.hasDepthSensing = function() {
            return w.texture !== null
        }
        ;
        let q = null;
        function ce(Z, de) {
            if (h = de.getViewerPose(f || o),
            _ = de,
            h !== null) {
                const Se = h.views;
                v !== null && (e.setRenderTargetFramebuffer(S, v.framebuffer),
                e.setRenderTarget(S));
                let ke = !1;
                Se.length !== C.cameras.length && (C.cameras.length = 0,
                ke = !0);
                for (let ze = 0; ze < Se.length; ze++) {
                    const ut = Se[ze];
                    let He = null;
                    if (v !== null)
                        He = v.getViewport(ut);
                    else {
                        const ge = d.getViewSubImage(m, ut);
                        He = ge.viewport,
                        ze === 0 && (e.setRenderTargetTextures(S, ge.colorTexture, m.ignoreDepthValues ? void 0 : ge.depthStencilTexture),
                        e.setRenderTarget(S))
                    }
                    let z = G[ze];
                    z === void 0 && (z = new Dn,
                    z.layers.enable(ze),
                    z.viewport = new Ct,
                    G[ze] = z),
                    z.matrix.fromArray(ut.transform.matrix),
                    z.matrix.decompose(z.position, z.quaternion, z.scale),
                    z.projectionMatrix.fromArray(ut.projectionMatrix),
                    z.projectionMatrixInverse.copy(z.projectionMatrix).invert(),
                    z.viewport.set(He.x, He.y, He.width, He.height),
                    ze === 0 && (C.matrix.copy(z.matrix),
                    C.matrix.decompose(C.position, C.quaternion, C.scale)),
                    ke === !0 && C.cameras.push(z)
                }
                const Xe = r.enabledFeatures;
                if (Xe && Xe.includes("depth-sensing")) {
                    const ze = d.getDepthInformation(Se[0]);
                    ze && ze.isValid && ze.texture && w.init(e, ze, r.renderState)
                }
            }
            for (let Se = 0; Se < M.length; Se++) {
                const ke = T[Se]
                  , Xe = M[Se];
                ke !== null && Xe !== void 0 && Xe.update(ke, de, f || o)
            }
            w.render(e, C),
            q && q(Z, de),
            de.detectedPlanes && i.dispatchEvent({
                type: "planesdetected",
                data: de
            }),
            _ = null
        }
        const Ce = new dC;
        Ce.setAnimationLoop(ce),
        this.setAnimationLoop = function(Z) {
            q = Z
        }
        ,
        this.dispose = function() {}
    }
}
const ko = new Ri
  , lF = new $e;
function uF(n, e) {
    function t(x, g) {
        x.matrixAutoUpdate === !0 && x.updateMatrix(),
        g.value.copy(x.matrix)
    }
    function i(x, g) {
        g.color.getRGB(x.fogColor.value, cC(n)),
        g.isFog ? (x.fogNear.value = g.near,
        x.fogFar.value = g.far) : g.isFogExp2 && (x.fogDensity.value = g.density)
    }
    function r(x, g, S, M, T) {
        g.isMeshBasicMaterial || g.isMeshLambertMaterial ? s(x, g) : g.isMeshToonMaterial ? (s(x, g),
        d(x, g)) : g.isMeshPhongMaterial ? (s(x, g),
        h(x, g)) : g.isMeshStandardMaterial ? (s(x, g),
        m(x, g),
        g.isMeshPhysicalMaterial && v(x, g, T)) : g.isMeshMatcapMaterial ? (s(x, g),
        _(x, g)) : g.isMeshDepthMaterial ? s(x, g) : g.isMeshDistanceMaterial ? (s(x, g),
        w(x, g)) : g.isMeshNormalMaterial ? s(x, g) : g.isLineBasicMaterial ? (o(x, g),
        g.isLineDashedMaterial && a(x, g)) : g.isPointsMaterial ? c(x, g, S, M) : g.isSpriteMaterial ? f(x, g) : g.isShadowMaterial ? (x.color.value.copy(g.color),
        x.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1)
    }
    function s(x, g) {
        x.opacity.value = g.opacity,
        g.color && x.diffuse.value.copy(g.color),
        g.emissive && x.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
        g.map && (x.map.value = g.map,
        t(g.map, x.mapTransform)),
        g.alphaMap && (x.alphaMap.value = g.alphaMap,
        t(g.alphaMap, x.alphaMapTransform)),
        g.bumpMap && (x.bumpMap.value = g.bumpMap,
        t(g.bumpMap, x.bumpMapTransform),
        x.bumpScale.value = g.bumpScale,
        g.side === ti && (x.bumpScale.value *= -1)),
        g.normalMap && (x.normalMap.value = g.normalMap,
        t(g.normalMap, x.normalMapTransform),
        x.normalScale.value.copy(g.normalScale),
        g.side === ti && x.normalScale.value.negate()),
        g.displacementMap && (x.displacementMap.value = g.displacementMap,
        t(g.displacementMap, x.displacementMapTransform),
        x.displacementScale.value = g.displacementScale,
        x.displacementBias.value = g.displacementBias),
        g.emissiveMap && (x.emissiveMap.value = g.emissiveMap,
        t(g.emissiveMap, x.emissiveMapTransform)),
        g.specularMap && (x.specularMap.value = g.specularMap,
        t(g.specularMap, x.specularMapTransform)),
        g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
        const S = e.get(g)
          , M = S.envMap
          , T = S.envMapRotation;
        if (M && (x.envMap.value = M,
        ko.copy(T),
        ko.x *= -1,
        ko.y *= -1,
        ko.z *= -1,
        M.isCubeTexture && M.isRenderTargetTexture === !1 && (ko.y *= -1,
        ko.z *= -1),
        x.envMapRotation.value.setFromMatrix4(lF.makeRotationFromEuler(ko)),
        x.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1,
        x.reflectivity.value = g.reflectivity,
        x.ior.value = g.ior,
        x.refractionRatio.value = g.refractionRatio),
        g.lightMap) {
            x.lightMap.value = g.lightMap;
            const P = n._useLegacyLights === !0 ? Math.PI : 1;
            x.lightMapIntensity.value = g.lightMapIntensity * P,
            t(g.lightMap, x.lightMapTransform)
        }
        g.aoMap && (x.aoMap.value = g.aoMap,
        x.aoMapIntensity.value = g.aoMapIntensity,
        t(g.aoMap, x.aoMapTransform))
    }
    function o(x, g) {
        x.diffuse.value.copy(g.color),
        x.opacity.value = g.opacity,
        g.map && (x.map.value = g.map,
        t(g.map, x.mapTransform))
    }
    function a(x, g) {
        x.dashSize.value = g.dashSize,
        x.totalSize.value = g.dashSize + g.gapSize,
        x.scale.value = g.scale
    }
    function c(x, g, S, M) {
        x.diffuse.value.copy(g.color),
        x.opacity.value = g.opacity,
        x.size.value = g.size * S,
        x.scale.value = M * .5,
        g.map && (x.map.value = g.map,
        t(g.map, x.uvTransform)),
        g.alphaMap && (x.alphaMap.value = g.alphaMap,
        t(g.alphaMap, x.alphaMapTransform)),
        g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest)
    }
    function f(x, g) {
        x.diffuse.value.copy(g.color),
        x.opacity.value = g.opacity,
        x.rotation.value = g.rotation,
        g.map && (x.map.value = g.map,
        t(g.map, x.mapTransform)),
        g.alphaMap && (x.alphaMap.value = g.alphaMap,
        t(g.alphaMap, x.alphaMapTransform)),
        g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest)
    }
    function h(x, g) {
        x.specular.value.copy(g.specular),
        x.shininess.value = Math.max(g.shininess, 1e-4)
    }
    function d(x, g) {
        g.gradientMap && (x.gradientMap.value = g.gradientMap)
    }
    function m(x, g) {
        x.metalness.value = g.metalness,
        g.metalnessMap && (x.metalnessMap.value = g.metalnessMap,
        t(g.metalnessMap, x.metalnessMapTransform)),
        x.roughness.value = g.roughness,
        g.roughnessMap && (x.roughnessMap.value = g.roughnessMap,
        t(g.roughnessMap, x.roughnessMapTransform)),
        e.get(g).envMap && (x.envMapIntensity.value = g.envMapIntensity)
    }
    function v(x, g, S) {
        x.ior.value = g.ior,
        g.sheen > 0 && (x.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
        x.sheenRoughness.value = g.sheenRoughness,
        g.sheenColorMap && (x.sheenColorMap.value = g.sheenColorMap,
        t(g.sheenColorMap, x.sheenColorMapTransform)),
        g.sheenRoughnessMap && (x.sheenRoughnessMap.value = g.sheenRoughnessMap,
        t(g.sheenRoughnessMap, x.sheenRoughnessMapTransform))),
        g.clearcoat > 0 && (x.clearcoat.value = g.clearcoat,
        x.clearcoatRoughness.value = g.clearcoatRoughness,
        g.clearcoatMap && (x.clearcoatMap.value = g.clearcoatMap,
        t(g.clearcoatMap, x.clearcoatMapTransform)),
        g.clearcoatRoughnessMap && (x.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap,
        t(g.clearcoatRoughnessMap, x.clearcoatRoughnessMapTransform)),
        g.clearcoatNormalMap && (x.clearcoatNormalMap.value = g.clearcoatNormalMap,
        t(g.clearcoatNormalMap, x.clearcoatNormalMapTransform),
        x.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
        g.side === ti && x.clearcoatNormalScale.value.negate())),
        g.iridescence > 0 && (x.iridescence.value = g.iridescence,
        x.iridescenceIOR.value = g.iridescenceIOR,
        x.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0],
        x.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1],
        g.iridescenceMap && (x.iridescenceMap.value = g.iridescenceMap,
        t(g.iridescenceMap, x.iridescenceMapTransform)),
        g.iridescenceThicknessMap && (x.iridescenceThicknessMap.value = g.iridescenceThicknessMap,
        t(g.iridescenceThicknessMap, x.iridescenceThicknessMapTransform))),
        g.transmission > 0 && (x.transmission.value = g.transmission,
        x.transmissionSamplerMap.value = S.texture,
        x.transmissionSamplerSize.value.set(S.width, S.height),
        g.transmissionMap && (x.transmissionMap.value = g.transmissionMap,
        t(g.transmissionMap, x.transmissionMapTransform)),
        x.thickness.value = g.thickness,
        g.thicknessMap && (x.thicknessMap.value = g.thicknessMap,
        t(g.thicknessMap, x.thicknessMapTransform)),
        x.attenuationDistance.value = g.attenuationDistance,
        x.attenuationColor.value.copy(g.attenuationColor)),
        g.anisotropy > 0 && (x.anisotropyVector.value.set(g.anisotropy * Math.cos(g.anisotropyRotation), g.anisotropy * Math.sin(g.anisotropyRotation)),
        g.anisotropyMap && (x.anisotropyMap.value = g.anisotropyMap,
        t(g.anisotropyMap, x.anisotropyMapTransform))),
        x.specularIntensity.value = g.specularIntensity,
        x.specularColor.value.copy(g.specularColor),
        g.specularColorMap && (x.specularColorMap.value = g.specularColorMap,
        t(g.specularColorMap, x.specularColorMapTransform)),
        g.specularIntensityMap && (x.specularIntensityMap.value = g.specularIntensityMap,
        t(g.specularIntensityMap, x.specularIntensityMapTransform))
    }
    function _(x, g) {
        g.matcap && (x.matcap.value = g.matcap)
    }
    function w(x, g) {
        const S = e.get(g).light;
        x.referencePosition.value.setFromMatrixPosition(S.matrixWorld),
        x.nearDistance.value = S.shadow.camera.near,
        x.farDistance.value = S.shadow.camera.far
    }
    return {
        refreshFogUniforms: i,
        refreshMaterialUniforms: r
    }
}
function cF(n, e, t, i) {
    let r = {}
      , s = {}
      , o = [];
    const a = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
    function c(S, M) {
        const T = M.program;
        i.uniformBlockBinding(S, T)
    }
    function f(S, M) {
        let T = r[S.id];
        T === void 0 && (_(S),
        T = h(S),
        r[S.id] = T,
        S.addEventListener("dispose", x));
        const P = M.program;
        i.updateUBOMapping(S, P);
        const R = e.render.frame;
        s[S.id] !== R && (m(S),
        s[S.id] = R)
    }
    function h(S) {
        const M = d();
        S.__bindingPointIndex = M;
        const T = n.createBuffer()
          , P = S.__size
          , R = S.usage;
        return n.bindBuffer(n.UNIFORM_BUFFER, T),
        n.bufferData(n.UNIFORM_BUFFER, P, R),
        n.bindBuffer(n.UNIFORM_BUFFER, null),
        n.bindBufferBase(n.UNIFORM_BUFFER, M, T),
        T
    }
    function d() {
        for (let S = 0; S < a; S++)
            if (o.indexOf(S) === -1)
                return o.push(S),
                S;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function m(S) {
        const M = r[S.id]
          , T = S.uniforms
          , P = S.__cache;
        n.bindBuffer(n.UNIFORM_BUFFER, M);
        for (let R = 0, b = T.length; R < b; R++) {
            const N = Array.isArray(T[R]) ? T[R] : [T[R]];
            for (let G = 0, C = N.length; G < C; G++) {
                const I = N[G];
                if (v(I, R, G, P) === !0) {
                    const K = I.__offset
                      , se = Array.isArray(I.value) ? I.value : [I.value];
                    let B = 0;
                    for (let ie = 0; ie < se.length; ie++) {
                        const J = se[ie]
                          , ue = w(J);
                        typeof J == "number" || typeof J == "boolean" ? (I.__data[0] = J,
                        n.bufferSubData(n.UNIFORM_BUFFER, K + B, I.__data)) : J.isMatrix3 ? (I.__data[0] = J.elements[0],
                        I.__data[1] = J.elements[1],
                        I.__data[2] = J.elements[2],
                        I.__data[3] = 0,
                        I.__data[4] = J.elements[3],
                        I.__data[5] = J.elements[4],
                        I.__data[6] = J.elements[5],
                        I.__data[7] = 0,
                        I.__data[8] = J.elements[6],
                        I.__data[9] = J.elements[7],
                        I.__data[10] = J.elements[8],
                        I.__data[11] = 0) : (J.toArray(I.__data, B),
                        B += ue.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    n.bufferSubData(n.UNIFORM_BUFFER, K, I.__data)
                }
            }
        }
        n.bindBuffer(n.UNIFORM_BUFFER, null)
    }
    function v(S, M, T, P) {
        const R = S.value
          , b = M + "_" + T;
        if (P[b] === void 0)
            return typeof R == "number" || typeof R == "boolean" ? P[b] = R : P[b] = R.clone(),
            !0;
        {
            const N = P[b];
            if (typeof R == "number" || typeof R == "boolean") {
                if (N !== R)
                    return P[b] = R,
                    !0
            } else if (N.equals(R) === !1)
                return N.copy(R),
                !0
        }
        return !1
    }
    function _(S) {
        const M = S.uniforms;
        let T = 0;
        const P = 16;
        for (let b = 0, N = M.length; b < N; b++) {
            const G = Array.isArray(M[b]) ? M[b] : [M[b]];
            for (let C = 0, I = G.length; C < I; C++) {
                const K = G[C]
                  , se = Array.isArray(K.value) ? K.value : [K.value];
                for (let B = 0, ie = se.length; B < ie; B++) {
                    const J = se[B]
                      , ue = w(J)
                      , F = T % P;
                    F !== 0 && P - F < ue.boundary && (T += P - F),
                    K.__data = new Float32Array(ue.storage / Float32Array.BYTES_PER_ELEMENT),
                    K.__offset = T,
                    T += ue.storage
                }
            }
        }
        const R = T % P;
        return R > 0 && (T += P - R),
        S.__size = T,
        S.__cache = {},
        this
    }
    function w(S) {
        const M = {
            boundary: 0,
            storage: 0
        };
        return typeof S == "number" || typeof S == "boolean" ? (M.boundary = 4,
        M.storage = 4) : S.isVector2 ? (M.boundary = 8,
        M.storage = 8) : S.isVector3 || S.isColor ? (M.boundary = 16,
        M.storage = 12) : S.isVector4 ? (M.boundary = 16,
        M.storage = 16) : S.isMatrix3 ? (M.boundary = 48,
        M.storage = 48) : S.isMatrix4 ? (M.boundary = 64,
        M.storage = 64) : S.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", S),
        M
    }
    function x(S) {
        const M = S.target;
        M.removeEventListener("dispose", x);
        const T = o.indexOf(M.__bindingPointIndex);
        o.splice(T, 1),
        n.deleteBuffer(r[M.id]),
        delete r[M.id],
        delete s[M.id]
    }
    function g() {
        for (const S in r)
            n.deleteBuffer(r[S]);
        o = [],
        r = {},
        s = {}
    }
    return {
        bind: c,
        update: f,
        dispose: g
    }
}
class $_ {
    constructor(e={}) {
        const {canvas: t=oC(), context: i=null, depth: r=!0, stencil: s=!0, alpha: o=!1, antialias: a=!1, premultipliedAlpha: c=!0, preserveDrawingBuffer: f=!1, powerPreference: h="default", failIfMajorPerformanceCaveat: d=!1} = e;
        this.isWebGLRenderer = !0;
        let m;
        i !== null ? m = i.getContextAttributes().alpha : m = o;
        const v = new Uint32Array(4)
          , _ = new Int32Array(4);
        let w = null
          , x = null;
        const g = []
          , S = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this._outputColorSpace = Fi,
        this._useLegacyLights = !1,
        this.toneMapping = Ar,
        this.toneMappingExposure = 1;
        const M = this;
        let T = !1
          , P = 0
          , R = 0
          , b = null
          , N = -1
          , G = null;
        const C = new Ct
          , I = new Ct;
        let K = null;
        const se = new Ne(0);
        let B = 0
          , ie = t.width
          , J = t.height
          , ue = 1
          , F = null
          , H = null;
        const V = new Ct(0,0,ie,J)
          , q = new Ct(0,0,ie,J);
        let ce = !1;
        const Ce = new _f;
        let Z = !1
          , de = !1
          , Se = null;
        const ke = new $e
          , Xe = new he
          , ze = new U
          , ut = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        function He() {
            return b === null ? ue : 1
        }
        let z = i;
        function ge(D, j) {
            for (let te = 0; te < D.length; te++) {
                const ne = D[te]
                  , $ = t.getContext(ne, j);
                if ($ !== null)
                    return $
            }
            return null
        }
        try {
            const D = {
                alpha: !0,
                depth: r,
                stencil: s,
                antialias: a,
                premultipliedAlpha: c,
                preserveDrawingBuffer: f,
                powerPreference: h,
                failIfMajorPerformanceCaveat: d
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${qp}`),
            t.addEventListener("webglcontextlost", zt, !1),
            t.addEventListener("webglcontextrestored", X, !1),
            t.addEventListener("webglcontextcreationerror", be, !1),
            z === null) {
                const j = ["webgl2", "webgl", "experimental-webgl"];
                if (M.isWebGL1Renderer === !0 && j.shift(),
                z = ge(j, D),
                z === null)
                    throw ge(j) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            typeof WebGLRenderingContext < "u" && z instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),
            z.getShaderPrecisionFormat === void 0 && (z.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (D) {
            throw console.error("THREE.WebGLRenderer: " + D.message),
            D
        }
        let fe, Me, pe, Oe, De, Ge, ft, O, L, oe, le, ye, me, st, et, Te, Re, ot, we, nn, St, Ke, Ye, je;
        function Tt() {
            fe = new xU(z),
            Me = new pU(z,fe,e),
            fe.init(Me),
            Ke = new _C(z,fe,Me),
            pe = new tF(z,fe,Me),
            Oe = new wU(z),
            De = new GO,
            Ge = new nF(z,fe,pe,De,Me,Ke,Oe),
            ft = new gU(M),
            O = new _U(M),
            L = new bI(z,Me),
            Ye = new hU(z,fe,L,Me),
            oe = new SU(z,L,Oe,Ye),
            le = new CU(z,oe,L,Oe),
            we = new AU(z,Me,Ge),
            Te = new mU(De),
            ye = new VO(M,ft,O,fe,Me,Ye,Te),
            me = new uF(M,De),
            st = new XO,
            et = new KO(fe,Me),
            ot = new fU(M,ft,O,pe,le,m,c),
            Re = new eF(M,le,Me),
            je = new cF(z,Oe,Me,pe),
            nn = new dU(z,fe,Oe,Me),
            St = new MU(z,fe,Oe,Me),
            Oe.programs = ye.programs,
            M.capabilities = Me,
            M.extensions = fe,
            M.properties = De,
            M.renderLists = st,
            M.shadowMap = Re,
            M.state = pe,
            M.info = Oe
        }
        Tt();
        const ht = new aF(M,z);
        this.xr = ht,
        this.getContext = function() {
            return z
        }
        ,
        this.getContextAttributes = function() {
            return z.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const D = fe.get("WEBGL_lose_context");
            D && D.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const D = fe.get("WEBGL_lose_context");
            D && D.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return ue
        }
        ,
        this.setPixelRatio = function(D) {
            D !== void 0 && (ue = D,
            this.setSize(ie, J, !1))
        }
        ,
        this.getSize = function(D) {
            return D.set(ie, J)
        }
        ,
        this.setSize = function(D, j, te=!0) {
            if (ht.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            ie = D,
            J = j,
            t.width = Math.floor(D * ue),
            t.height = Math.floor(j * ue),
            te === !0 && (t.style.width = D + "px",
            t.style.height = j + "px"),
            this.setViewport(0, 0, D, j)
        }
        ,
        this.getDrawingBufferSize = function(D) {
            return D.set(ie * ue, J * ue).floor()
        }
        ,
        this.setDrawingBufferSize = function(D, j, te) {
            ie = D,
            J = j,
            ue = te,
            t.width = Math.floor(D * te),
            t.height = Math.floor(j * te),
            this.setViewport(0, 0, D, j)
        }
        ,
        this.getCurrentViewport = function(D) {
            return D.copy(C)
        }
        ,
        this.getViewport = function(D) {
            return D.copy(V)
        }
        ,
        this.setViewport = function(D, j, te, ne) {
            D.isVector4 ? V.set(D.x, D.y, D.z, D.w) : V.set(D, j, te, ne),
            pe.viewport(C.copy(V).multiplyScalar(ue).round())
        }
        ,
        this.getScissor = function(D) {
            return D.copy(q)
        }
        ,
        this.setScissor = function(D, j, te, ne) {
            D.isVector4 ? q.set(D.x, D.y, D.z, D.w) : q.set(D, j, te, ne),
            pe.scissor(I.copy(q).multiplyScalar(ue).round())
        }
        ,
        this.getScissorTest = function() {
            return ce
        }
        ,
        this.setScissorTest = function(D) {
            pe.setScissorTest(ce = D)
        }
        ,
        this.setOpaqueSort = function(D) {
            F = D
        }
        ,
        this.setTransparentSort = function(D) {
            H = D
        }
        ,
        this.getClearColor = function(D) {
            return D.copy(ot.getClearColor())
        }
        ,
        this.setClearColor = function() {
            ot.setClearColor.apply(ot, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return ot.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            ot.setClearAlpha.apply(ot, arguments)
        }
        ,
        this.clear = function(D=!0, j=!0, te=!0) {
            let ne = 0;
            if (D) {
                let $ = !1;
                if (b !== null) {
                    const Ue = b.texture.format;
                    $ = Ue === B_ || Ue === z_ || Ue === k_
                }
                if ($) {
                    const Ue = b.texture.type
                      , Ze = Ue === jr || Ue === vs || Ue === Qp || Ue === uo || Ue === U_ || Ue === O_
                      , tt = ot.getClearColor()
                      , nt = ot.getClearAlpha()
                      , at = tt.r
                      , rt = tt.g
                      , lt = tt.b;
                    Ze ? (v[0] = at,
                    v[1] = rt,
                    v[2] = lt,
                    v[3] = nt,
                    z.clearBufferuiv(z.COLOR, 0, v)) : (_[0] = at,
                    _[1] = rt,
                    _[2] = lt,
                    _[3] = nt,
                    z.clearBufferiv(z.COLOR, 0, _))
                } else
                    ne |= z.COLOR_BUFFER_BIT
            }
            j && (ne |= z.DEPTH_BUFFER_BIT),
            te && (ne |= z.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            z.clear(ne)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", zt, !1),
            t.removeEventListener("webglcontextrestored", X, !1),
            t.removeEventListener("webglcontextcreationerror", be, !1),
            st.dispose(),
            et.dispose(),
            De.dispose(),
            ft.dispose(),
            O.dispose(),
            le.dispose(),
            Ye.dispose(),
            je.dispose(),
            ye.dispose(),
            ht.dispose(),
            ht.removeEventListener("sessionstart", ri),
            ht.removeEventListener("sessionend", Ft),
            Se && (Se.dispose(),
            Se = null),
            On.stop()
        }
        ;
        function zt(D) {
            D.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            T = !0
        }
        function X() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            T = !1;
            const D = Oe.autoReset
              , j = Re.enabled
              , te = Re.autoUpdate
              , ne = Re.needsUpdate
              , $ = Re.type;
            Tt(),
            Oe.autoReset = D,
            Re.enabled = j,
            Re.autoUpdate = te,
            Re.needsUpdate = ne,
            Re.type = $
        }
        function be(D) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", D.statusMessage)
        }
        function ee(D) {
            const j = D.target;
            j.removeEventListener("dispose", ee),
            Ee(j)
        }
        function Ee(D) {
            Pe(D),
            De.remove(D)
        }
        function Pe(D) {
            const j = De.get(D).programs;
            j !== void 0 && (j.forEach(function(te) {
                ye.releaseProgram(te)
            }),
            D.isShaderMaterial && ye.releaseShaderCache(D))
        }
        this.renderBufferDirect = function(D, j, te, ne, $, Ue) {
            j === null && (j = ut);
            const Ze = $.isMesh && $.matrixWorld.determinant() < 0
              , tt = wm(D, j, te, ne, $);
            pe.setMaterial(ne, Ze);
            let nt = te.index
              , at = 1;
            if (ne.wireframe === !0) {
                if (nt = oe.getWireframeAttribute(te),
                nt === void 0)
                    return;
                at = 2
            }
            const rt = te.drawRange
              , lt = te.attributes.position;
            let Zt = rt.start * at
              , Fn = (rt.start + rt.count) * at;
            Ue !== null && (Zt = Math.max(Zt, Ue.start * at),
            Fn = Math.min(Fn, (Ue.start + Ue.count) * at)),
            nt !== null ? (Zt = Math.max(Zt, 0),
            Fn = Math.min(Fn, nt.count)) : lt != null && (Zt = Math.max(Zt, 0),
            Fn = Math.min(Fn, lt.count));
            const Vt = Fn - Zt;
            if (Vt < 0 || Vt === 1 / 0)
                return;
            Ye.setup($, ne, tt, te, nt);
            let Cn, it = nn;
            if (nt !== null && (Cn = L.get(nt),
            it = St,
            it.setIndex(Cn)),
            $.isMesh)
                ne.wireframe === !0 ? (pe.setLineWidth(ne.wireframeLinewidth * He()),
                it.setMode(z.LINES)) : it.setMode(z.TRIANGLES);
            else if ($.isLine) {
                let Fe = ne.linewidth;
                Fe === void 0 && (Fe = 1),
                pe.setLineWidth(Fe * He()),
                $.isLineSegments ? it.setMode(z.LINES) : $.isLineLoop ? it.setMode(z.LINE_LOOP) : it.setMode(z.LINE_STRIP)
            } else
                $.isPoints ? it.setMode(z.POINTS) : $.isSprite && it.setMode(z.TRIANGLES);
            if ($.isBatchedMesh)
                it.renderMultiDraw($._multiDrawStarts, $._multiDrawCounts, $._multiDrawCount);
            else if ($.isInstancedMesh)
                it.renderInstances(Zt, Vt, $.count);
            else if (te.isInstancedBufferGeometry) {
                const Fe = te._maxInstanceCount !== void 0 ? te._maxInstanceCount : 1 / 0
                  , Yi = Math.min(te.instanceCount, Fe);
                it.renderInstances(Zt, Vt, Yi)
            } else
                it.render(Zt, Vt)
        }
        ;
        function wt(D, j, te) {
            D.transparent === !0 && D.side === Vr && D.forceSinglePass === !1 ? (D.side = ti,
            D.needsUpdate = !0,
            Ra(D, j, te),
            D.side = Zr,
            D.needsUpdate = !0,
            Ra(D, j, te),
            D.side = Vr) : Ra(D, j, te)
        }
        this.compile = function(D, j, te=null) {
            te === null && (te = D),
            x = et.get(te),
            x.init(),
            S.push(x),
            te.traverseVisible(function($) {
                $.isLight && $.layers.test(j.layers) && (x.pushLight($),
                $.castShadow && x.pushShadow($))
            }),
            D !== te && D.traverseVisible(function($) {
                $.isLight && $.layers.test(j.layers) && (x.pushLight($),
                $.castShadow && x.pushShadow($))
            }),
            x.setupLights(M._useLegacyLights);
            const ne = new Set;
            return D.traverse(function($) {
                const Ue = $.material;
                if (Ue)
                    if (Array.isArray(Ue))
                        for (let Ze = 0; Ze < Ue.length; Ze++) {
                            const tt = Ue[Ze];
                            wt(tt, te, $),
                            ne.add(tt)
                        }
                    else
                        wt(Ue, te, $),
                        ne.add(Ue)
            }),
            S.pop(),
            x = null,
            ne
        }
        ,
        this.compileAsync = function(D, j, te=null) {
            const ne = this.compile(D, j, te);
            return new Promise($=>{
                function Ue() {
                    if (ne.forEach(function(Ze) {
                        De.get(Ze).currentProgram.isReady() && ne.delete(Ze)
                    }),
                    ne.size === 0) {
                        $(D);
                        return
                    }
                    setTimeout(Ue, 10)
                }
                fe.get("KHR_parallel_shader_compile") !== null ? Ue() : setTimeout(Ue, 10)
            }
            )
        }
        ;
        let Dt = null;
        function pn(D) {
            Dt && Dt(D)
        }
        function ri() {
            On.stop()
        }
        function Ft() {
            On.start()
        }
        const On = new dC;
        On.setAnimationLoop(pn),
        typeof self < "u" && On.setContext(self),
        this.setAnimationLoop = function(D) {
            Dt = D,
            ht.setAnimationLoop(D),
            D === null ? On.stop() : On.start()
        }
        ,
        ht.addEventListener("sessionstart", ri),
        ht.addEventListener("sessionend", Ft),
        this.render = function(D, j) {
            if (j !== void 0 && j.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (T === !0)
                return;
            D.matrixWorldAutoUpdate === !0 && D.updateMatrixWorld(),
            j.parent === null && j.matrixWorldAutoUpdate === !0 && j.updateMatrixWorld(),
            ht.enabled === !0 && ht.isPresenting === !0 && (ht.cameraAutoUpdate === !0 && ht.updateCamera(j),
            j = ht.getCamera()),
            D.isScene === !0 && D.onBeforeRender(M, D, j, b),
            x = et.get(D, S.length),
            x.init(),
            S.push(x),
            ke.multiplyMatrices(j.projectionMatrix, j.matrixWorldInverse),
            Ce.setFromProjectionMatrix(ke),
            de = this.localClippingEnabled,
            Z = Te.init(this.clippingPlanes, de),
            w = st.get(D, g.length),
            w.init(),
            g.push(w),
            Xi(D, j, 0, M.sortObjects),
            w.finish(),
            M.sortObjects === !0 && w.sort(F, H),
            this.info.render.frame++,
            Z === !0 && Te.beginShadows();
            const te = x.state.shadowsArray;
            if (Re.render(te, D, j),
            Z === !0 && Te.endShadows(),
            this.info.autoReset === !0 && this.info.reset(),
            (ht.enabled === !1 || ht.isPresenting === !1 || ht.hasDepthSensing() === !1) && ot.render(w, D),
            x.setupLights(M._useLegacyLights),
            j.isArrayCamera) {
                const ne = j.cameras;
                for (let $ = 0, Ue = ne.length; $ < Ue; $++) {
                    const Ze = ne[$];
                    cu(w, D, Ze, Ze.viewport)
                }
            } else
                cu(w, D, j);
            b !== null && (Ge.updateMultisampleRenderTarget(b),
            Ge.updateRenderTargetMipmap(b)),
            D.isScene === !0 && D.onAfterRender(M, D, j),
            Ye.resetDefaultState(),
            N = -1,
            G = null,
            S.pop(),
            S.length > 0 ? x = S[S.length - 1] : x = null,
            g.pop(),
            g.length > 0 ? w = g[g.length - 1] : w = null
        }
        ;
        function Xi(D, j, te, ne) {
            if (D.visible === !1)
                return;
            if (D.layers.test(j.layers)) {
                if (D.isGroup)
                    te = D.renderOrder;
                else if (D.isLOD)
                    D.autoUpdate === !0 && D.update(j);
                else if (D.isLight)
                    x.pushLight(D),
                    D.castShadow && x.pushShadow(D);
                else if (D.isSprite) {
                    if (!D.frustumCulled || Ce.intersectsSprite(D)) {
                        ne && ze.setFromMatrixPosition(D.matrixWorld).applyMatrix4(ke);
                        const Ze = le.update(D)
                          , tt = D.material;
                        tt.visible && w.push(D, Ze, tt, te, ze.z, null)
                    }
                } else if ((D.isMesh || D.isLine || D.isPoints) && (!D.frustumCulled || Ce.intersectsObject(D))) {
                    const Ze = le.update(D)
                      , tt = D.material;
                    if (ne && (D.boundingSphere !== void 0 ? (D.boundingSphere === null && D.computeBoundingSphere(),
                    ze.copy(D.boundingSphere.center)) : (Ze.boundingSphere === null && Ze.computeBoundingSphere(),
                    ze.copy(Ze.boundingSphere.center)),
                    ze.applyMatrix4(D.matrixWorld).applyMatrix4(ke)),
                    Array.isArray(tt)) {
                        const nt = Ze.groups;
                        for (let at = 0, rt = nt.length; at < rt; at++) {
                            const lt = nt[at]
                              , Zt = tt[lt.materialIndex];
                            Zt && Zt.visible && w.push(D, Ze, Zt, te, ze.z, lt)
                        }
                    } else
                        tt.visible && w.push(D, Ze, tt, te, ze.z, null)
                }
            }
            const Ue = D.children;
            for (let Ze = 0, tt = Ue.length; Ze < tt; Ze++)
                Xi(Ue[Ze], j, te, ne)
        }
        function cu(D, j, te, ne) {
            const $ = D.opaque
              , Ue = D.transmissive
              , Ze = D.transparent;
            x.setupLightsView(te),
            Z === !0 && Te.setGlobalState(M.clippingPlanes, te),
            Ue.length > 0 && fu($, Ue, j, te),
            ne && pe.viewport(C.copy(ne)),
            $.length > 0 && Ca($, j, te),
            Ue.length > 0 && Ca(Ue, j, te),
            Ze.length > 0 && Ca(Ze, j, te),
            pe.buffers.depth.setTest(!0),
            pe.buffers.depth.setMask(!0),
            pe.buffers.color.setMask(!0),
            pe.setPolygonOffset(!1)
        }
        function fu(D, j, te, ne) {
            if ((te.isScene === !0 ? te.overrideMaterial : null) !== null)
                return;
            const Ue = Me.isWebGL2;
            Se === null && (Se = new cr(1,1,{
                generateMipmaps: !0,
                type: fe.has("EXT_color_buffer_half_float") ? va : jr,
                minFilter: Gr,
                samples: Ue ? 4 : 0
            })),
            M.getDrawingBufferSize(Xe),
            Ue ? Se.setSize(Xe.x, Xe.y) : Se.setSize(Cp(Xe.x), Cp(Xe.y));
            const Ze = M.getRenderTarget();
            M.setRenderTarget(Se),
            M.getClearColor(se),
            B = M.getClearAlpha(),
            B < 1 && M.setClearColor(16777215, .5),
            M.clear();
            const tt = M.toneMapping;
            M.toneMapping = Ar,
            Ca(D, te, ne),
            Ge.updateMultisampleRenderTarget(Se),
            Ge.updateRenderTargetMipmap(Se);
            let nt = !1;
            for (let at = 0, rt = j.length; at < rt; at++) {
                const lt = j[at]
                  , Zt = lt.object
                  , Fn = lt.geometry
                  , Vt = lt.material
                  , Cn = lt.group;
                if (Vt.side === Vr && Zt.layers.test(ne.layers)) {
                    const it = Vt.side;
                    Vt.side = ti,
                    Vt.needsUpdate = !0,
                    bs(Zt, te, ne, Fn, Vt, Cn),
                    Vt.side = it,
                    Vt.needsUpdate = !0,
                    nt = !0
                }
            }
            nt === !0 && (Ge.updateMultisampleRenderTarget(Se),
            Ge.updateRenderTargetMipmap(Se)),
            M.setRenderTarget(Ze),
            M.setClearColor(se, B),
            M.toneMapping = tt
        }
        function Ca(D, j, te) {
            const ne = j.isScene === !0 ? j.overrideMaterial : null;
            for (let $ = 0, Ue = D.length; $ < Ue; $++) {
                const Ze = D[$]
                  , tt = Ze.object
                  , nt = Ze.geometry
                  , at = ne === null ? Ze.material : ne
                  , rt = Ze.group;
                tt.layers.test(te.layers) && bs(tt, j, te, nt, at, rt)
            }
        }
        function bs(D, j, te, ne, $, Ue) {
            D.onBeforeRender(M, j, te, ne, $, Ue),
            D.modelViewMatrix.multiplyMatrices(te.matrixWorldInverse, D.matrixWorld),
            D.normalMatrix.getNormalMatrix(D.modelViewMatrix),
            $.onBeforeRender(M, j, te, ne, D, Ue),
            $.transparent === !0 && $.side === Vr && $.forceSinglePass === !1 ? ($.side = ti,
            $.needsUpdate = !0,
            M.renderBufferDirect(te, j, ne, $, D, Ue),
            $.side = Zr,
            $.needsUpdate = !0,
            M.renderBufferDirect(te, j, ne, $, D, Ue),
            $.side = Vr) : M.renderBufferDirect(te, j, ne, $, D, Ue),
            D.onAfterRender(M, j, te, ne, $, Ue)
        }
        function Ra(D, j, te) {
            j.isScene !== !0 && (j = ut);
            const ne = De.get(D)
              , $ = x.state.lights
              , Ue = x.state.shadowsArray
              , Ze = $.state.version
              , tt = ye.getParameters(D, $.state, Ue, j, te)
              , nt = ye.getProgramCacheKey(tt);
            let at = ne.programs;
            ne.environment = D.isMeshStandardMaterial ? j.environment : null,
            ne.fog = j.fog,
            ne.envMap = (D.isMeshStandardMaterial ? O : ft).get(D.envMap || ne.environment),
            ne.envMapRotation = ne.environment !== null && D.envMap === null ? j.environmentRotation : D.envMapRotation,
            at === void 0 && (D.addEventListener("dispose", ee),
            at = new Map,
            ne.programs = at);
            let rt = at.get(nt);
            if (rt !== void 0) {
                if (ne.currentProgram === rt && ne.lightsStateVersion === Ze)
                    return Rf(D, tt),
                    rt
            } else
                tt.uniforms = ye.getUniforms(D),
                D.onBuild(te, tt, M),
                D.onBeforeCompile(tt, M),
                rt = ye.acquireProgram(tt, nt),
                at.set(nt, rt),
                ne.uniforms = tt.uniforms;
            const lt = ne.uniforms;
            return (!D.isShaderMaterial && !D.isRawShaderMaterial || D.clipping === !0) && (lt.clippingPlanes = Te.uniform),
            Rf(D, tt),
            ne.needsLights = Tm(D),
            ne.lightsStateVersion = Ze,
            ne.needsLights && (lt.ambientLightColor.value = $.state.ambient,
            lt.lightProbe.value = $.state.probe,
            lt.directionalLights.value = $.state.directional,
            lt.directionalLightShadows.value = $.state.directionalShadow,
            lt.spotLights.value = $.state.spot,
            lt.spotLightShadows.value = $.state.spotShadow,
            lt.rectAreaLights.value = $.state.rectArea,
            lt.ltc_1.value = $.state.rectAreaLTC1,
            lt.ltc_2.value = $.state.rectAreaLTC2,
            lt.pointLights.value = $.state.point,
            lt.pointLightShadows.value = $.state.pointShadow,
            lt.hemisphereLights.value = $.state.hemi,
            lt.directionalShadowMap.value = $.state.directionalShadowMap,
            lt.directionalShadowMatrix.value = $.state.directionalShadowMatrix,
            lt.spotShadowMap.value = $.state.spotShadowMap,
            lt.spotLightMatrix.value = $.state.spotLightMatrix,
            lt.spotLightMap.value = $.state.spotLightMap,
            lt.pointShadowMap.value = $.state.pointShadowMap,
            lt.pointShadowMatrix.value = $.state.pointShadowMatrix),
            ne.currentProgram = rt,
            ne.uniformsList = null,
            rt
        }
        function Cf(D) {
            if (D.uniformsList === null) {
                const j = D.currentProgram.getUniforms();
                D.uniformsList = Kd.seqWithValue(j.seq, D.uniforms)
            }
            return D.uniformsList
        }
        function Rf(D, j) {
            const te = De.get(D);
            te.outputColorSpace = j.outputColorSpace,
            te.batching = j.batching,
            te.instancing = j.instancing,
            te.instancingColor = j.instancingColor,
            te.instancingMorph = j.instancingMorph,
            te.skinning = j.skinning,
            te.morphTargets = j.morphTargets,
            te.morphNormals = j.morphNormals,
            te.morphColors = j.morphColors,
            te.morphTargetsCount = j.morphTargetsCount,
            te.numClippingPlanes = j.numClippingPlanes,
            te.numIntersection = j.numClipIntersection,
            te.vertexAlphas = j.vertexAlphas,
            te.vertexTangents = j.vertexTangents,
            te.toneMapping = j.toneMapping
        }
        function wm(D, j, te, ne, $) {
            j.isScene !== !0 && (j = ut),
            Ge.resetTextureUnits();
            const Ue = j.fog
              , Ze = ne.isMeshStandardMaterial ? j.environment : null
              , tt = b === null ? M.outputColorSpace : b.isXRRenderTarget === !0 ? b.texture.colorSpace : Cs
              , nt = (ne.isMeshStandardMaterial ? O : ft).get(ne.envMap || Ze)
              , at = ne.vertexColors === !0 && !!te.attributes.color && te.attributes.color.itemSize === 4
              , rt = !!te.attributes.tangent && (!!ne.normalMap || ne.anisotropy > 0)
              , lt = !!te.morphAttributes.position
              , Zt = !!te.morphAttributes.normal
              , Fn = !!te.morphAttributes.color;
            let Vt = Ar;
            ne.toneMapped && (b === null || b.isXRRenderTarget === !0) && (Vt = M.toneMapping);
            const Cn = te.morphAttributes.position || te.morphAttributes.normal || te.morphAttributes.color
              , it = Cn !== void 0 ? Cn.length : 0
              , Fe = De.get(ne)
              , Yi = x.state.lights;
            if (Z === !0 && (de === !0 || D !== G)) {
                const kn = D === G && ne.id === N;
                Te.setState(ne, D, kn)
            }
            let vt = !1;
            ne.version === Fe.__version ? (Fe.needsLights && Fe.lightsStateVersion !== Yi.state.version || Fe.outputColorSpace !== tt || $.isBatchedMesh && Fe.batching === !1 || !$.isBatchedMesh && Fe.batching === !0 || $.isInstancedMesh && Fe.instancing === !1 || !$.isInstancedMesh && Fe.instancing === !0 || $.isSkinnedMesh && Fe.skinning === !1 || !$.isSkinnedMesh && Fe.skinning === !0 || $.isInstancedMesh && Fe.instancingColor === !0 && $.instanceColor === null || $.isInstancedMesh && Fe.instancingColor === !1 && $.instanceColor !== null || $.isInstancedMesh && Fe.instancingMorph === !0 && $.morphTexture === null || $.isInstancedMesh && Fe.instancingMorph === !1 && $.morphTexture !== null || Fe.envMap !== nt || ne.fog === !0 && Fe.fog !== Ue || Fe.numClippingPlanes !== void 0 && (Fe.numClippingPlanes !== Te.numPlanes || Fe.numIntersection !== Te.numIntersection) || Fe.vertexAlphas !== at || Fe.vertexTangents !== rt || Fe.morphTargets !== lt || Fe.morphNormals !== Zt || Fe.morphColors !== Fn || Fe.toneMapping !== Vt || Me.isWebGL2 === !0 && Fe.morphTargetsCount !== it) && (vt = !0) : (vt = !0,
            Fe.__version = ne.version);
            let rn = Fe.currentProgram;
            vt === !0 && (rn = Ra(ne, j, $));
            let Pr = !1
              , ji = !1
              , Rn = !1;
            const un = rn.getUniforms()
              , Lr = Fe.uniforms;
            if (pe.useProgram(rn.program) && (Pr = !0,
            ji = !0,
            Rn = !0),
            ne.id !== N && (N = ne.id,
            ji = !0),
            Pr || G !== D) {
                un.setValue(z, "projectionMatrix", D.projectionMatrix),
                un.setValue(z, "viewMatrix", D.matrixWorldInverse);
                const kn = un.map.cameraPosition;
                kn !== void 0 && kn.setValue(z, ze.setFromMatrixPosition(D.matrixWorld)),
                Me.logarithmicDepthBuffer && un.setValue(z, "logDepthBufFC", 2 / (Math.log(D.far + 1) / Math.LN2)),
                (ne.isMeshPhongMaterial || ne.isMeshToonMaterial || ne.isMeshLambertMaterial || ne.isMeshBasicMaterial || ne.isMeshStandardMaterial || ne.isShaderMaterial) && un.setValue(z, "isOrthographic", D.isOrthographicCamera === !0),
                G !== D && (G = D,
                ji = !0,
                Rn = !0)
            }
            if ($.isSkinnedMesh) {
                un.setOptional(z, $, "bindMatrix"),
                un.setOptional(z, $, "bindMatrixInverse");
                const kn = $.skeleton;
                kn && (Me.floatVertexTextures ? (kn.boneTexture === null && kn.computeBoneTexture(),
                un.setValue(z, "boneTexture", kn.boneTexture, Ge)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
            }
            $.isBatchedMesh && (un.setOptional(z, $, "batchingTexture"),
            un.setValue(z, "batchingTexture", $._matricesTexture, Ge));
            const ba = te.morphAttributes;
            if ((ba.position !== void 0 || ba.normal !== void 0 || ba.color !== void 0 && Me.isWebGL2 === !0) && we.update($, te, rn),
            (ji || Fe.receiveShadow !== $.receiveShadow) && (Fe.receiveShadow = $.receiveShadow,
            un.setValue(z, "receiveShadow", $.receiveShadow)),
            ne.isMeshGouraudMaterial && ne.envMap !== null && (Lr.envMap.value = nt,
            Lr.flipEnvMap.value = nt.isCubeTexture && nt.isRenderTargetTexture === !1 ? -1 : 1),
            ji && (un.setValue(z, "toneMappingExposure", M.toneMappingExposure),
            Fe.needsLights && Em(Lr, Rn),
            Ue && ne.fog === !0 && me.refreshFogUniforms(Lr, Ue),
            me.refreshMaterialUniforms(Lr, ne, ue, J, Se),
            Kd.upload(z, Cf(Fe), Lr, Ge)),
            ne.isShaderMaterial && ne.uniformsNeedUpdate === !0 && (Kd.upload(z, Cf(Fe), Lr, Ge),
            ne.uniformsNeedUpdate = !1),
            ne.isSpriteMaterial && un.setValue(z, "center", $.center),
            un.setValue(z, "modelViewMatrix", $.modelViewMatrix),
            un.setValue(z, "normalMatrix", $.normalMatrix),
            un.setValue(z, "modelMatrix", $.matrixWorld),
            ne.isShaderMaterial || ne.isRawShaderMaterial) {
                const kn = ne.uniformsGroups;
                for (let Pa = 0, bi = kn.length; Pa < bi; Pa++)
                    if (Me.isWebGL2) {
                        const bf = kn[Pa];
                        je.update(bf, rn),
                        je.bind(bf, rn)
                    } else
                        console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
            }
            return rn
        }
        function Em(D, j) {
            D.ambientLightColor.needsUpdate = j,
            D.lightProbe.needsUpdate = j,
            D.directionalLights.needsUpdate = j,
            D.directionalLightShadows.needsUpdate = j,
            D.pointLights.needsUpdate = j,
            D.pointLightShadows.needsUpdate = j,
            D.spotLights.needsUpdate = j,
            D.spotLightShadows.needsUpdate = j,
            D.rectAreaLights.needsUpdate = j,
            D.hemisphereLights.needsUpdate = j
        }
        function Tm(D) {
            return D.isMeshLambertMaterial || D.isMeshToonMaterial || D.isMeshPhongMaterial || D.isMeshStandardMaterial || D.isShadowMaterial || D.isShaderMaterial && D.lights === !0
        }
        this.getActiveCubeFace = function() {
            return P
        }
        ,
        this.getActiveMipmapLevel = function() {
            return R
        }
        ,
        this.getRenderTarget = function() {
            return b
        }
        ,
        this.setRenderTargetTextures = function(D, j, te) {
            De.get(D.texture).__webglTexture = j,
            De.get(D.depthTexture).__webglTexture = te;
            const ne = De.get(D);
            ne.__hasExternalTextures = !0,
            ne.__autoAllocateDepthBuffer = te === void 0,
            ne.__autoAllocateDepthBuffer || fe.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
            ne.__useRenderToTexture = !1)
        }
        ,
        this.setRenderTargetFramebuffer = function(D, j) {
            const te = De.get(D);
            te.__webglFramebuffer = j,
            te.__useDefaultFramebuffer = j === void 0
        }
        ,
        this.setRenderTarget = function(D, j=0, te=0) {
            b = D,
            P = j,
            R = te;
            let ne = !0
              , $ = null
              , Ue = !1
              , Ze = !1;
            if (D) {
                const nt = De.get(D);
                nt.__useDefaultFramebuffer !== void 0 ? (pe.bindFramebuffer(z.FRAMEBUFFER, null),
                ne = !1) : nt.__webglFramebuffer === void 0 ? Ge.setupRenderTarget(D) : nt.__hasExternalTextures && Ge.rebindTextures(D, De.get(D.texture).__webglTexture, De.get(D.depthTexture).__webglTexture);
                const at = D.texture;
                (at.isData3DTexture || at.isDataArrayTexture || at.isCompressedArrayTexture) && (Ze = !0);
                const rt = De.get(D).__webglFramebuffer;
                D.isWebGLCubeRenderTarget ? (Array.isArray(rt[j]) ? $ = rt[j][te] : $ = rt[j],
                Ue = !0) : Me.isWebGL2 && D.samples > 0 && Ge.useMultisampledRTT(D) === !1 ? $ = De.get(D).__webglMultisampledFramebuffer : Array.isArray(rt) ? $ = rt[te] : $ = rt,
                C.copy(D.viewport),
                I.copy(D.scissor),
                K = D.scissorTest
            } else
                C.copy(V).multiplyScalar(ue).floor(),
                I.copy(q).multiplyScalar(ue).floor(),
                K = ce;
            if (pe.bindFramebuffer(z.FRAMEBUFFER, $) && Me.drawBuffers && ne && pe.drawBuffers(D, $),
            pe.viewport(C),
            pe.scissor(I),
            pe.setScissorTest(K),
            Ue) {
                const nt = De.get(D.texture);
                z.framebufferTexture2D(z.FRAMEBUFFER, z.COLOR_ATTACHMENT0, z.TEXTURE_CUBE_MAP_POSITIVE_X + j, nt.__webglTexture, te)
            } else if (Ze) {
                const nt = De.get(D.texture)
                  , at = j || 0;
                z.framebufferTextureLayer(z.FRAMEBUFFER, z.COLOR_ATTACHMENT0, nt.__webglTexture, te || 0, at)
            }
            N = -1
        }
        ,
        this.readRenderTargetPixels = function(D, j, te, ne, $, Ue, Ze) {
            if (!(D && D.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let tt = De.get(D).__webglFramebuffer;
            if (D.isWebGLCubeRenderTarget && Ze !== void 0 && (tt = tt[Ze]),
            tt) {
                pe.bindFramebuffer(z.FRAMEBUFFER, tt);
                try {
                    const nt = D.texture
                      , at = nt.format
                      , rt = nt.type;
                    if (at !== ci && Ke.convert(at) !== z.getParameter(z.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    const lt = rt === va && (fe.has("EXT_color_buffer_half_float") || Me.isWebGL2 && fe.has("EXT_color_buffer_float"));
                    if (rt !== jr && Ke.convert(rt) !== z.getParameter(z.IMPLEMENTATION_COLOR_READ_TYPE) && !(rt === wi && (Me.isWebGL2 || fe.has("OES_texture_float") || fe.has("WEBGL_color_buffer_float"))) && !lt) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    j >= 0 && j <= D.width - ne && te >= 0 && te <= D.height - $ && z.readPixels(j, te, ne, $, Ke.convert(at), Ke.convert(rt), Ue)
                } finally {
                    const nt = b !== null ? De.get(b).__webglFramebuffer : null;
                    pe.bindFramebuffer(z.FRAMEBUFFER, nt)
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(D, j, te=0) {
            const ne = Math.pow(2, -te)
              , $ = Math.floor(j.image.width * ne)
              , Ue = Math.floor(j.image.height * ne);
            Ge.setTexture2D(j, 0),
            z.copyTexSubImage2D(z.TEXTURE_2D, te, 0, 0, D.x, D.y, $, Ue),
            pe.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(D, j, te, ne=0) {
            const $ = j.image.width
              , Ue = j.image.height
              , Ze = Ke.convert(te.format)
              , tt = Ke.convert(te.type);
            Ge.setTexture2D(te, 0),
            z.pixelStorei(z.UNPACK_FLIP_Y_WEBGL, te.flipY),
            z.pixelStorei(z.UNPACK_PREMULTIPLY_ALPHA_WEBGL, te.premultiplyAlpha),
            z.pixelStorei(z.UNPACK_ALIGNMENT, te.unpackAlignment),
            j.isDataTexture ? z.texSubImage2D(z.TEXTURE_2D, ne, D.x, D.y, $, Ue, Ze, tt, j.image.data) : j.isCompressedTexture ? z.compressedTexSubImage2D(z.TEXTURE_2D, ne, D.x, D.y, j.mipmaps[0].width, j.mipmaps[0].height, Ze, j.mipmaps[0].data) : z.texSubImage2D(z.TEXTURE_2D, ne, D.x, D.y, Ze, tt, j.image),
            ne === 0 && te.generateMipmaps && z.generateMipmap(z.TEXTURE_2D),
            pe.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(D, j, te, ne, $=0) {
            if (M.isWebGL1Renderer) {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                return
            }
            const Ue = Math.round(D.max.x - D.min.x)
              , Ze = Math.round(D.max.y - D.min.y)
              , tt = D.max.z - D.min.z + 1
              , nt = Ke.convert(ne.format)
              , at = Ke.convert(ne.type);
            let rt;
            if (ne.isData3DTexture)
                Ge.setTexture3D(ne, 0),
                rt = z.TEXTURE_3D;
            else if (ne.isDataArrayTexture || ne.isCompressedArrayTexture)
                Ge.setTexture2DArray(ne, 0),
                rt = z.TEXTURE_2D_ARRAY;
            else {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                return
            }
            z.pixelStorei(z.UNPACK_FLIP_Y_WEBGL, ne.flipY),
            z.pixelStorei(z.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ne.premultiplyAlpha),
            z.pixelStorei(z.UNPACK_ALIGNMENT, ne.unpackAlignment);
            const lt = z.getParameter(z.UNPACK_ROW_LENGTH)
              , Zt = z.getParameter(z.UNPACK_IMAGE_HEIGHT)
              , Fn = z.getParameter(z.UNPACK_SKIP_PIXELS)
              , Vt = z.getParameter(z.UNPACK_SKIP_ROWS)
              , Cn = z.getParameter(z.UNPACK_SKIP_IMAGES)
              , it = te.isCompressedTexture ? te.mipmaps[$] : te.image;
            z.pixelStorei(z.UNPACK_ROW_LENGTH, it.width),
            z.pixelStorei(z.UNPACK_IMAGE_HEIGHT, it.height),
            z.pixelStorei(z.UNPACK_SKIP_PIXELS, D.min.x),
            z.pixelStorei(z.UNPACK_SKIP_ROWS, D.min.y),
            z.pixelStorei(z.UNPACK_SKIP_IMAGES, D.min.z),
            te.isDataTexture || te.isData3DTexture ? z.texSubImage3D(rt, $, j.x, j.y, j.z, Ue, Ze, tt, nt, at, it.data) : ne.isCompressedArrayTexture ? z.compressedTexSubImage3D(rt, $, j.x, j.y, j.z, Ue, Ze, tt, nt, it.data) : z.texSubImage3D(rt, $, j.x, j.y, j.z, Ue, Ze, tt, nt, at, it),
            z.pixelStorei(z.UNPACK_ROW_LENGTH, lt),
            z.pixelStorei(z.UNPACK_IMAGE_HEIGHT, Zt),
            z.pixelStorei(z.UNPACK_SKIP_PIXELS, Fn),
            z.pixelStorei(z.UNPACK_SKIP_ROWS, Vt),
            z.pixelStorei(z.UNPACK_SKIP_IMAGES, Cn),
            $ === 0 && ne.generateMipmaps && z.generateMipmap(rt),
            pe.unbindTexture()
        }
        ,
        this.initTexture = function(D) {
            D.isCubeTexture ? Ge.setTextureCube(D, 0) : D.isData3DTexture ? Ge.setTexture3D(D, 0) : D.isDataArrayTexture || D.isCompressedArrayTexture ? Ge.setTexture2DArray(D, 0) : Ge.setTexture2D(D, 0),
            pe.unbindTexture()
        }
        ,
        this.resetState = function() {
            P = 0,
            R = 0,
            b = null,
            pe.reset(),
            Ye.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return Wr
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = e === em ? "display-p3" : "srgb",
        t.unpackColorSpace = Ut.workingColorSpace === gf ? "display-p3" : "srgb"
    }
    get useLegacyLights() {
        return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
        this._useLegacyLights
    }
    set useLegacyLights(e) {
        console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
        this._useLegacyLights = e
    }
}
class SC extends $_ {
}
SC.prototype.isWebGL1Renderer = !0;
class rm {
    constructor(e, t=25e-5) {
        this.isFogExp2 = !0,
        this.name = "",
        this.color = new Ne(e),
        this.density = t
    }
    clone() {
        return new rm(this.color,this.density)
    }
    toJSON() {
        return {
            type: "FogExp2",
            name: this.name,
            color: this.color.getHex(),
            density: this.density
        }
    }
}
class sm {
    constructor(e, t=1, i=1e3) {
        this.isFog = !0,
        this.name = "",
        this.color = new Ne(e),
        this.near = t,
        this.far = i
    }
    clone() {
        return new sm(this.color,this.near,this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            name: this.name,
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
let Rp = class extends bt {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.backgroundRotation = new Ri,
        this.environmentRotation = new Ri,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        this.backgroundRotation.copy(e.backgroundRotation),
        this.environmentRotation.copy(e.environmentRotation),
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t.object.backgroundRotation = this.backgroundRotation.toArray(),
        t.object.environmentRotation = this.environmentRotation.toArray(),
        t
    }
}
;
class om {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = Qc,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.version = 0,
        this.uuid = Hi()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return aC("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, i) {
        e *= this.stride,
        i *= t.stride;
        for (let r = 0, s = this.stride; r < s; r++)
            this.array[e + r] = t.array[i + r];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Hi()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , i = new this.constructor(t,this.stride);
        return i.setUsage(this.usage),
        i
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Hi()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const ai = new U;
class _a {
    constructor(e, t, i, r=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = i,
        this.normalized = r
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.data.count; t < i; t++)
            ai.fromBufferAttribute(this, t),
            ai.applyMatrix4(e),
            this.setXYZ(t, ai.x, ai.y, ai.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            ai.fromBufferAttribute(this, t),
            ai.applyNormalMatrix(e),
            this.setXYZ(t, ai.x, ai.y, ai.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            ai.fromBufferAttribute(this, t),
            ai.transformDirection(e),
            this.setXYZ(t, ai.x, ai.y, ai.z);
        return this
    }
    getComponent(e, t) {
        let i = this.array[e * this.data.stride + this.offset + t];
        return this.normalized && (i = fi(i, this.array)),
        i
    }
    setComponent(e, t, i) {
        return this.normalized && (i = gt(i, this.array)),
        this.data.array[e * this.data.stride + this.offset + t] = i,
        this
    }
    setX(e, t) {
        return this.normalized && (t = gt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = gt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = gt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = gt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = fi(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = fi(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = fi(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = fi(t, this.array)),
        t
    }
    setXY(e, t, i) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = gt(t, this.array),
        i = gt(i, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, r) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = gt(t, this.array),
        i = gt(i, this.array),
        r = gt(r, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this.data.array[e + 2] = r,
        this
    }
    setXYZW(e, t, i, r, s) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = gt(t, this.array),
        i = gt(i, this.array),
        r = gt(r, this.array),
        s = gt(s, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this.data.array[e + 2] = r,
        this.data.array[e + 3] = s,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[r + s])
            }
            return new Nt(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new _a(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[r + s])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
class ex extends Gn {
    constructor(e) {
        super(),
        this.isSpriteMaterial = !0,
        this.type = "SpriteMaterial",
        this.color = new Ne(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
let sl;
const Gu = new U
  , ol = new U
  , al = new U
  , ll = new he
  , Wu = new he
  , MC = new $e
  , od = new U
  , Xu = new U
  , ad = new U
  , ew = new he
  , C0 = new he
  , tw = new he;
class wC extends bt {
    constructor(e=new ex) {
        if (super(),
        this.isSprite = !0,
        this.type = "Sprite",
        sl === void 0) {
            sl = new _t;
            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
              , i = new om(t,5);
            sl.setIndex([0, 1, 2, 0, 2, 3]),
            sl.setAttribute("position", new _a(i,3,0,!1)),
            sl.setAttribute("uv", new _a(i,2,3,!1))
        }
        this.geometry = sl,
        this.material = e,
        this.center = new he(.5,.5)
    }
    raycast(e, t) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
        ol.setFromMatrixScale(this.matrixWorld),
        MC.copy(e.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
        al.setFromMatrixPosition(this.modelViewMatrix),
        e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && ol.multiplyScalar(-al.z);
        const i = this.material.rotation;
        let r, s;
        i !== 0 && (s = Math.cos(i),
        r = Math.sin(i));
        const o = this.center;
        ld(od.set(-.5, -.5, 0), al, o, ol, r, s),
        ld(Xu.set(.5, -.5, 0), al, o, ol, r, s),
        ld(ad.set(.5, .5, 0), al, o, ol, r, s),
        ew.set(0, 0),
        C0.set(1, 0),
        tw.set(1, 1);
        let a = e.ray.intersectTriangle(od, Xu, ad, !1, Gu);
        if (a === null && (ld(Xu.set(-.5, .5, 0), al, o, ol, r, s),
        C0.set(0, 1),
        a = e.ray.intersectTriangle(od, ad, Xu, !1, Gu),
        a === null))
            return;
        const c = e.ray.origin.distanceTo(Gu);
        c < e.near || c > e.far || t.push({
            distance: c,
            point: Gu.clone(),
            uv: ki.getInterpolation(Gu, od, Xu, ad, ew, C0, tw, new he),
            face: null,
            object: this
        })
    }
    copy(e, t) {
        return super.copy(e, t),
        e.center !== void 0 && this.center.copy(e.center),
        this.material = e.material,
        this
    }
}
function ld(n, e, t, i, r, s) {
    ll.subVectors(n, t).addScalar(.5).multiply(i),
    r !== void 0 ? (Wu.x = s * ll.x - r * ll.y,
    Wu.y = r * ll.x + s * ll.y) : Wu.copy(ll),
    n.copy(e),
    n.x += Wu.x,
    n.y += Wu.y,
    n.applyMatrix4(MC)
}
const ud = new U
  , nw = new U;
class EC extends bt {
    constructor() {
        super(),
        this._currentLevel = 0,
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            },
            isLOD: {
                value: !0
            }
        }),
        this.autoUpdate = !0
    }
    copy(e) {
        super.copy(e, !1);
        const t = e.levels;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            this.addLevel(s.object.clone(), s.distance, s.hysteresis)
        }
        return this.autoUpdate = e.autoUpdate,
        this
    }
    addLevel(e, t=0, i=0) {
        t = Math.abs(t);
        const r = this.levels;
        let s;
        for (s = 0; s < r.length && !(t < r[s].distance); s++)
            ;
        return r.splice(s, 0, {
            distance: t,
            hysteresis: i,
            object: e
        }),
        this.add(e),
        this
    }
    getCurrentLevel() {
        return this._currentLevel
    }
    getObjectForDistance(e) {
        const t = this.levels;
        if (t.length > 0) {
            let i, r;
            for (i = 1,
            r = t.length; i < r; i++) {
                let s = t[i].distance;
                if (t[i].object.visible && (s -= s * t[i].hysteresis),
                e < s)
                    break
            }
            return t[i - 1].object
        }
        return null
    }
    raycast(e, t) {
        if (this.levels.length > 0) {
            ud.setFromMatrixPosition(this.matrixWorld);
            const r = e.ray.origin.distanceTo(ud);
            this.getObjectForDistance(r).raycast(e, t)
        }
    }
    update(e) {
        const t = this.levels;
        if (t.length > 1) {
            ud.setFromMatrixPosition(e.matrixWorld),
            nw.setFromMatrixPosition(this.matrixWorld);
            const i = ud.distanceTo(nw) / e.zoom;
            t[0].object.visible = !0;
            let r, s;
            for (r = 1,
            s = t.length; r < s; r++) {
                let o = t[r].distance;
                if (t[r].object.visible && (o -= o * t[r].hysteresis),
                i >= o)
                    t[r - 1].object.visible = !1,
                    t[r].object.visible = !0;
                else
                    break
            }
            for (this._currentLevel = r - 1; r < s; r++)
                t[r].object.visible = !1
        }
    }
    toJSON(e) {
        const t = super.toJSON(e);
        this.autoUpdate === !1 && (t.object.autoUpdate = !1),
        t.object.levels = [];
        const i = this.levels;
        for (let r = 0, s = i.length; r < s; r++) {
            const o = i[r];
            t.object.levels.push({
                object: o.object.uuid,
                distance: o.distance,
                hysteresis: o.hysteresis
            })
        }
        return t
    }
}
const iw = new U
  , rw = new Ct
  , sw = new Ct
  , fF = new U
  , ow = new $e
  , cd = new U
  , R0 = new ni
  , aw = new $e
  , b0 = new su;
class TC extends _n {
    constructor(e, t) {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = Jv,
        this.bindMatrix = new $e,
        this.bindMatrixInverse = new $e,
        this.boundingBox = null,
        this.boundingSphere = null
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new di),
        this.boundingBox.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++)
            this.getVertexPosition(i, cd),
            this.boundingBox.expandByPoint(cd)
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new ni),
        this.boundingSphere.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++)
            this.getVertexPosition(i, cd),
            this.boundingSphere.expandByPoint(cd)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    raycast(e, t) {
        const i = this.material
          , r = this.matrixWorld;
        i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        R0.copy(this.boundingSphere),
        R0.applyMatrix4(r),
        e.ray.intersectsSphere(R0) !== !1 && (aw.copy(r).invert(),
        b0.copy(e.ray).applyMatrix4(aw),
        !(this.boundingBox !== null && b0.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, b0)))
    }
    getVertexPosition(e, t) {
        return super.getVertexPosition(e, t),
        this.applyBoneTransform(e, t),
        t
    }
    bind(e, t) {
        this.skeleton = e,
        t === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new Ct
          , t = this.geometry.attributes.skinWeight;
        for (let i = 0, r = t.count; i < r; i++) {
            e.fromBufferAttribute(t, i);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
            t.setXYZW(i, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === Jv ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === F2 ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(e, t) {
        const i = this.skeleton
          , r = this.geometry;
        rw.fromBufferAttribute(r.attributes.skinIndex, e),
        sw.fromBufferAttribute(r.attributes.skinWeight, e),
        iw.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = sw.getComponent(s);
            if (o !== 0) {
                const a = rw.getComponent(s);
                ow.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
                t.addScaledVector(fF.copy(iw).applyMatrix4(ow), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class tx extends bt {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class fo extends en {
    constructor(e=null, t=1, i=1, r, s, o, a, c, f=hn, h=hn, d, m) {
        super(null, o, a, c, f, h, r, s, d, m),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const lw = new $e
  , hF = new $e;
class am {
    constructor(e=[], t=[]) {
        this.uuid = Hi(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.init()
    }
    init() {
        const e = this.bones
          , t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16),
        t.length === 0)
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let i = 0, r = this.bones.length; i < r; i++)
                this.boneInverses.push(new $e)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = new $e;
            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(i)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && i.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld),
            i.matrix.decompose(i.position, i.quaternion, i.scale))
        }
    }
    update() {
        const e = this.bones
          , t = this.boneInverses
          , i = this.boneMatrices
          , r = this.boneTexture;
        for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : hF;
            lw.multiplyMatrices(a, t[s]),
            lw.toArray(i, s * 16)
        }
        r !== null && (r.needsUpdate = !0)
    }
    clone() {
        return new am(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const i = new fo(t,e,e,ci,wi);
        return i.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = i,
        this
    }
    getBoneByName(e) {
        for (let t = 0, i = this.bones.length; t < i; t++) {
            const r = this.bones[t];
            if (r.name === e)
                return r
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let i = 0, r = e.bones.length; i < r; i++) {
            const s = e.bones[i];
            let o = t[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s),
            o = new tx),
            this.bones.push(o),
            this.boneInverses.push(new $e().fromArray(e.boneInverses[i]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones
          , i = this.boneInverses;
        for (let r = 0, s = t.length; r < s; r++) {
            const o = t[r];
            e.bones.push(o.uuid);
            const a = i[r];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class Ql extends Nt {
    constructor(e, t, i, r=1) {
        super(e, t, i),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = r
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const ul = new $e
  , uw = new $e
  , fd = []
  , cw = new di
  , dF = new $e
  , Yu = new _n
  , ju = new ni;
class AC extends _n {
    constructor(e, t, i) {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new Ql(new Float32Array(i * 16),16),
        this.instanceColor = null,
        this.morphTexture = null,
        this.count = i,
        this.boundingBox = null,
        this.boundingSphere = null;
        for (let r = 0; r < i; r++)
            this.setMatrixAt(r, dF)
    }
    computeBoundingBox() {
        const e = this.geometry
          , t = this.count;
        this.boundingBox === null && (this.boundingBox = new di),
        e.boundingBox === null && e.computeBoundingBox(),
        this.boundingBox.makeEmpty();
        for (let i = 0; i < t; i++)
            this.getMatrixAt(i, ul),
            cw.copy(e.boundingBox).applyMatrix4(ul),
            this.boundingBox.union(cw)
    }
    computeBoundingSphere() {
        const e = this.geometry
          , t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new ni),
        e.boundingSphere === null && e.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
        for (let i = 0; i < t; i++)
            this.getMatrixAt(i, ul),
            ju.copy(e.boundingSphere).applyMatrix4(ul),
            this.boundingSphere.union(ju)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    getMorphAt(e, t) {
        const i = t.morphTargetInfluences
          , r = this.morphTexture.source.data.data
          , s = i.length + 1
          , o = e * s + 1;
        for (let a = 0; a < i.length; a++)
            i[a] = r[o + a]
    }
    raycast(e, t) {
        const i = this.matrixWorld
          , r = this.count;
        if (Yu.geometry = this.geometry,
        Yu.material = this.material,
        Yu.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        ju.copy(this.boundingSphere),
        ju.applyMatrix4(i),
        e.ray.intersectsSphere(ju) !== !1))
            for (let s = 0; s < r; s++) {
                this.getMatrixAt(s, ul),
                uw.multiplyMatrices(i, ul),
                Yu.matrixWorld = uw,
                Yu.raycast(e, fd);
                for (let o = 0, a = fd.length; o < a; o++) {
                    const c = fd[o];
                    c.instanceId = s,
                    c.object = this,
                    t.push(c)
                }
                fd.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new Ql(new Float32Array(this.instanceMatrix.count * 3),3)),
        t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    setMorphAt(e, t) {
        const i = t.morphTargetInfluences
          , r = i.length + 1;
        this.morphTexture === null && (this.morphTexture = new fo(new Float32Array(r * this.count),r,this.count,F_,wi));
        const s = this.morphTexture.source.data.data;
        let o = 0;
        for (let f = 0; f < i.length; f++)
            o += i[f];
        const a = this.geometry.morphTargetsRelative ? 1 : 1 - o
          , c = r * e;
        s[c] = a,
        s.set(i, c + 1)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
function pF(n, e) {
    return n.z - e.z
}
function mF(n, e) {
    return e.z - n.z
}
class gF {
    constructor() {
        this.index = 0,
        this.pool = [],
        this.list = []
    }
    push(e, t) {
        const i = this.pool
          , r = this.list;
        this.index >= i.length && i.push({
            start: -1,
            count: -1,
            z: -1
        });
        const s = i[this.index];
        r.push(s),
        this.index++,
        s.start = e.start,
        s.count = e.count,
        s.z = t
    }
    reset() {
        this.list.length = 0,
        this.index = 0
    }
}
const cl = "batchId"
  , Xs = new $e
  , fw = new $e
  , vF = new $e
  , hw = new $e
  , P0 = new _f
  , hd = new di
  , zo = new ni
  , qu = new U
  , L0 = new gF
  , Qn = new _n
  , dd = [];
function yF(n, e, t=0) {
    const i = e.itemSize;
    if (n.isInterleavedBufferAttribute || n.array.constructor !== e.array.constructor) {
        const r = n.count;
        for (let s = 0; s < r; s++)
            for (let o = 0; o < i; o++)
                e.setComponent(s + t, o, n.getComponent(s, o))
    } else
        e.array.set(n.array, t * i);
    e.needsUpdate = !0
}
class CC extends _n {
    get maxGeometryCount() {
        return this._maxGeometryCount
    }
    constructor(e, t, i=t * 2, r) {
        super(new _t, r),
        this.isBatchedMesh = !0,
        this.perObjectFrustumCulled = !0,
        this.sortObjects = !0,
        this.boundingBox = null,
        this.boundingSphere = null,
        this.customSort = null,
        this._drawRanges = [],
        this._reservedRanges = [],
        this._visibility = [],
        this._active = [],
        this._bounds = [],
        this._maxGeometryCount = e,
        this._maxVertexCount = t,
        this._maxIndexCount = i,
        this._geometryInitialized = !1,
        this._geometryCount = 0,
        this._multiDrawCounts = new Int32Array(e),
        this._multiDrawStarts = new Int32Array(e),
        this._multiDrawCount = 0,
        this._visibilityChanged = !0,
        this._matricesTexture = null,
        this._initMatricesTexture()
    }
    _initMatricesTexture() {
        let e = Math.sqrt(this._maxGeometryCount * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4)
          , i = new fo(t,e,e,ci,wi);
        this._matricesTexture = i
    }
    _initializeGeometry(e) {
        const t = this.geometry
          , i = this._maxVertexCount
          , r = this._maxGeometryCount
          , s = this._maxIndexCount;
        if (this._geometryInitialized === !1) {
            for (const a in e.attributes) {
                const c = e.getAttribute(a)
                  , {array: f, itemSize: h, normalized: d} = c
                  , m = new f.constructor(i * h)
                  , v = new c.constructor(m,h,d);
                v.setUsage(c.usage),
                t.setAttribute(a, v)
            }
            if (e.getIndex() !== null) {
                const a = i > 65536 ? new Uint32Array(s) : new Uint16Array(s);
                t.setIndex(new Nt(a,1))
            }
            const o = r > 65536 ? new Uint32Array(i) : new Uint16Array(i);
            t.setAttribute(cl, new Nt(o,1)),
            this._geometryInitialized = !0
        }
    }
    _validateGeometry(e) {
        if (e.getAttribute(cl))
            throw new Error(`BatchedMesh: Geometry cannot use attribute "${cl}"`);
        const t = this.geometry;
        if (!!e.getIndex() != !!t.getIndex())
            throw new Error('BatchedMesh: All geometries must consistently have "index".');
        for (const i in t.attributes) {
            if (i === cl)
                continue;
            if (!e.hasAttribute(i))
                throw new Error(`BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`);
            const r = e.getAttribute(i)
              , s = t.getAttribute(i);
            if (r.itemSize !== s.itemSize || r.normalized !== s.normalized)
                throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
        }
    }
    setCustomSort(e) {
        return this.customSort = e,
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new di);
        const e = this._geometryCount
          , t = this.boundingBox
          , i = this._active;
        t.makeEmpty();
        for (let r = 0; r < e; r++)
            i[r] !== !1 && (this.getMatrixAt(r, Xs),
            this.getBoundingBoxAt(r, hd).applyMatrix4(Xs),
            t.union(hd))
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new ni);
        const e = this._geometryCount
          , t = this.boundingSphere
          , i = this._active;
        t.makeEmpty();
        for (let r = 0; r < e; r++)
            i[r] !== !1 && (this.getMatrixAt(r, Xs),
            this.getBoundingSphereAt(r, zo).applyMatrix4(Xs),
            t.union(zo))
    }
    addGeometry(e, t=-1, i=-1) {
        if (this._initializeGeometry(e),
        this._validateGeometry(e),
        this._geometryCount >= this._maxGeometryCount)
            throw new Error("BatchedMesh: Maximum geometry count reached.");
        const r = {
            vertexStart: -1,
            vertexCount: -1,
            indexStart: -1,
            indexCount: -1
        };
        let s = null;
        const o = this._reservedRanges
          , a = this._drawRanges
          , c = this._bounds;
        this._geometryCount !== 0 && (s = o[o.length - 1]),
        t === -1 ? r.vertexCount = e.getAttribute("position").count : r.vertexCount = t,
        s === null ? r.vertexStart = 0 : r.vertexStart = s.vertexStart + s.vertexCount;
        const f = e.getIndex()
          , h = f !== null;
        if (h && (i === -1 ? r.indexCount = f.count : r.indexCount = i,
        s === null ? r.indexStart = 0 : r.indexStart = s.indexStart + s.indexCount),
        r.indexStart !== -1 && r.indexStart + r.indexCount > this._maxIndexCount || r.vertexStart + r.vertexCount > this._maxVertexCount)
            throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
        const d = this._visibility
          , m = this._active
          , v = this._matricesTexture
          , _ = this._matricesTexture.image.data;
        d.push(!0),
        m.push(!0);
        const w = this._geometryCount;
        this._geometryCount++,
        vF.toArray(_, w * 16),
        v.needsUpdate = !0,
        o.push(r),
        a.push({
            start: h ? r.indexStart : r.vertexStart,
            count: -1
        }),
        c.push({
            boxInitialized: !1,
            box: new di,
            sphereInitialized: !1,
            sphere: new ni
        });
        const x = this.geometry.getAttribute(cl);
        for (let g = 0; g < r.vertexCount; g++)
            x.setX(r.vertexStart + g, w);
        return x.needsUpdate = !0,
        this.setGeometryAt(w, e),
        w
    }
    setGeometryAt(e, t) {
        if (e >= this._geometryCount)
            throw new Error("BatchedMesh: Maximum geometry count reached.");
        this._validateGeometry(t);
        const i = this.geometry
          , r = i.getIndex() !== null
          , s = i.getIndex()
          , o = t.getIndex()
          , a = this._reservedRanges[e];
        if (r && o.count > a.indexCount || t.attributes.position.count > a.vertexCount)
            throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
        const c = a.vertexStart
          , f = a.vertexCount;
        for (const v in i.attributes) {
            if (v === cl)
                continue;
            const _ = t.getAttribute(v)
              , w = i.getAttribute(v);
            yF(_, w, c);
            const x = _.itemSize;
            for (let g = _.count, S = f; g < S; g++) {
                const M = c + g;
                for (let T = 0; T < x; T++)
                    w.setComponent(M, T, 0)
            }
            w.needsUpdate = !0
        }
        if (r) {
            const v = a.indexStart;
            for (let _ = 0; _ < o.count; _++)
                s.setX(v + _, c + o.getX(_));
            for (let _ = o.count, w = a.indexCount; _ < w; _++)
                s.setX(v + _, c);
            s.needsUpdate = !0
        }
        const h = this._bounds[e];
        t.boundingBox !== null ? (h.box.copy(t.boundingBox),
        h.boxInitialized = !0) : h.boxInitialized = !1,
        t.boundingSphere !== null ? (h.sphere.copy(t.boundingSphere),
        h.sphereInitialized = !0) : h.sphereInitialized = !1;
        const d = this._drawRanges[e]
          , m = t.getAttribute("position");
        return d.count = r ? o.count : m.count,
        this._visibilityChanged = !0,
        e
    }
    deleteGeometry(e) {
        const t = this._active;
        return e >= t.length || t[e] === !1 ? this : (t[e] = !1,
        this._visibilityChanged = !0,
        this)
    }
    getBoundingBoxAt(e, t) {
        if (this._active[e] === !1)
            return null;
        const r = this._bounds[e]
          , s = r.box
          , o = this.geometry;
        if (r.boxInitialized === !1) {
            s.makeEmpty();
            const a = o.index
              , c = o.attributes.position
              , f = this._drawRanges[e];
            for (let h = f.start, d = f.start + f.count; h < d; h++) {
                let m = h;
                a && (m = a.getX(m)),
                s.expandByPoint(qu.fromBufferAttribute(c, m))
            }
            r.boxInitialized = !0
        }
        return t.copy(s),
        t
    }
    getBoundingSphereAt(e, t) {
        if (this._active[e] === !1)
            return null;
        const r = this._bounds[e]
          , s = r.sphere
          , o = this.geometry;
        if (r.sphereInitialized === !1) {
            s.makeEmpty(),
            this.getBoundingBoxAt(e, hd),
            hd.getCenter(s.center);
            const a = o.index
              , c = o.attributes.position
              , f = this._drawRanges[e];
            let h = 0;
            for (let d = f.start, m = f.start + f.count; d < m; d++) {
                let v = d;
                a && (v = a.getX(v)),
                qu.fromBufferAttribute(c, v),
                h = Math.max(h, s.center.distanceToSquared(qu))
            }
            s.radius = Math.sqrt(h),
            r.sphereInitialized = !0
        }
        return t.copy(s),
        t
    }
    setMatrixAt(e, t) {
        const i = this._active
          , r = this._matricesTexture
          , s = this._matricesTexture.image.data
          , o = this._geometryCount;
        return e >= o || i[e] === !1 ? this : (t.toArray(s, e * 16),
        r.needsUpdate = !0,
        this)
    }
    getMatrixAt(e, t) {
        const i = this._active
          , r = this._matricesTexture.image.data
          , s = this._geometryCount;
        return e >= s || i[e] === !1 ? null : t.fromArray(r, e * 16)
    }
    setVisibleAt(e, t) {
        const i = this._visibility
          , r = this._active
          , s = this._geometryCount;
        return e >= s || r[e] === !1 || i[e] === t ? this : (i[e] = t,
        this._visibilityChanged = !0,
        this)
    }
    getVisibleAt(e) {
        const t = this._visibility
          , i = this._active
          , r = this._geometryCount;
        return e >= r || i[e] === !1 ? !1 : t[e]
    }
    raycast(e, t) {
        const i = this._visibility
          , r = this._active
          , s = this._drawRanges
          , o = this._geometryCount
          , a = this.matrixWorld
          , c = this.geometry;
        Qn.material = this.material,
        Qn.geometry.index = c.index,
        Qn.geometry.attributes = c.attributes,
        Qn.geometry.boundingBox === null && (Qn.geometry.boundingBox = new di),
        Qn.geometry.boundingSphere === null && (Qn.geometry.boundingSphere = new ni);
        for (let f = 0; f < o; f++) {
            if (!i[f] || !r[f])
                continue;
            const h = s[f];
            Qn.geometry.setDrawRange(h.start, h.count),
            this.getMatrixAt(f, Qn.matrixWorld).premultiply(a),
            this.getBoundingBoxAt(f, Qn.geometry.boundingBox),
            this.getBoundingSphereAt(f, Qn.geometry.boundingSphere),
            Qn.raycast(e, dd);
            for (let d = 0, m = dd.length; d < m; d++) {
                const v = dd[d];
                v.object = this,
                v.batchId = f,
                t.push(v)
            }
            dd.length = 0
        }
        Qn.material = null,
        Qn.geometry.index = null,
        Qn.geometry.attributes = {},
        Qn.geometry.setDrawRange(0, 1 / 0)
    }
    copy(e) {
        return super.copy(e),
        this.geometry = e.geometry.clone(),
        this.perObjectFrustumCulled = e.perObjectFrustumCulled,
        this.sortObjects = e.sortObjects,
        this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null,
        this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null,
        this._drawRanges = e._drawRanges.map(t=>({
            ...t
        })),
        this._reservedRanges = e._reservedRanges.map(t=>({
            ...t
        })),
        this._visibility = e._visibility.slice(),
        this._active = e._active.slice(),
        this._bounds = e._bounds.map(t=>({
            boxInitialized: t.boxInitialized,
            box: t.box.clone(),
            sphereInitialized: t.sphereInitialized,
            sphere: t.sphere.clone()
        })),
        this._maxGeometryCount = e._maxGeometryCount,
        this._maxVertexCount = e._maxVertexCount,
        this._maxIndexCount = e._maxIndexCount,
        this._geometryInitialized = e._geometryInitialized,
        this._geometryCount = e._geometryCount,
        this._multiDrawCounts = e._multiDrawCounts.slice(),
        this._multiDrawStarts = e._multiDrawStarts.slice(),
        this._matricesTexture = e._matricesTexture.clone(),
        this._matricesTexture.image.data = this._matricesTexture.image.slice(),
        this
    }
    dispose() {
        return this.geometry.dispose(),
        this._matricesTexture.dispose(),
        this._matricesTexture = null,
        this
    }
    onBeforeRender(e, t, i, r, s) {
        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
            return;
        const o = r.getIndex()
          , a = o === null ? 1 : o.array.BYTES_PER_ELEMENT
          , c = this._active
          , f = this._visibility
          , h = this._multiDrawStarts
          , d = this._multiDrawCounts
          , m = this._drawRanges
          , v = this.perObjectFrustumCulled;
        v && (hw.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse).multiply(this.matrixWorld),
        P0.setFromProjectionMatrix(hw, e.coordinateSystem));
        let _ = 0;
        if (this.sortObjects) {
            fw.copy(this.matrixWorld).invert(),
            qu.setFromMatrixPosition(i.matrixWorld).applyMatrix4(fw);
            for (let g = 0, S = f.length; g < S; g++)
                if (f[g] && c[g]) {
                    this.getMatrixAt(g, Xs),
                    this.getBoundingSphereAt(g, zo).applyMatrix4(Xs);
                    let M = !1;
                    if (v && (M = !P0.intersectsSphere(zo)),
                    !M) {
                        const T = qu.distanceTo(zo.center);
                        L0.push(m[g], T)
                    }
                }
            const w = L0.list
              , x = this.customSort;
            x === null ? w.sort(s.transparent ? mF : pF) : x.call(this, w, i);
            for (let g = 0, S = w.length; g < S; g++) {
                const M = w[g];
                h[_] = M.start * a,
                d[_] = M.count,
                _++
            }
            L0.reset()
        } else
            for (let w = 0, x = f.length; w < x; w++)
                if (f[w] && c[w]) {
                    let g = !1;
                    if (v && (this.getMatrixAt(w, Xs),
                    this.getBoundingSphereAt(w, zo).applyMatrix4(Xs),
                    g = !P0.intersectsSphere(zo)),
                    !g) {
                        const S = m[w];
                        h[_] = S.start * a,
                        d[_] = S.count,
                        _++
                    }
                }
        this._multiDrawCount = _,
        this._visibilityChanged = !1
    }
    onBeforeShadow(e, t, i, r, s, o) {
        this.onBeforeRender(e, null, r, s, o)
    }
}
class gi extends Gn {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new Ne(16777215),
        this.map = null,
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const dw = new U
  , pw = new U
  , mw = new $e
  , I0 = new su
  , pd = new ni;
class go extends bt {
    constructor(e=new _t, t=new gi) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , i = [0];
            for (let r = 1, s = t.count; r < s; r++)
                dw.fromBufferAttribute(t, r - 1),
                pw.fromBufferAttribute(t, r),
                i[r] = i[r - 1],
                i[r] += dw.distanceTo(pw);
            e.setAttribute("lineDistance", new We(i,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.matrixWorld
          , s = e.params.Line.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        pd.copy(i.boundingSphere),
        pd.applyMatrix4(r),
        pd.radius += s,
        e.ray.intersectsSphere(pd) === !1)
            return;
        mw.copy(r).invert(),
        I0.copy(e.ray).applyMatrix4(mw);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , c = a * a
          , f = new U
          , h = new U
          , d = new U
          , m = new U
          , v = this.isLineSegments ? 2 : 1
          , _ = i.index
          , x = i.attributes.position;
        if (_ !== null) {
            const g = Math.max(0, o.start)
              , S = Math.min(_.count, o.start + o.count);
            for (let M = g, T = S - 1; M < T; M += v) {
                const P = _.getX(M)
                  , R = _.getX(M + 1);
                if (f.fromBufferAttribute(x, P),
                h.fromBufferAttribute(x, R),
                I0.distanceSqToSegment(f, h, m, d) > c)
                    continue;
                m.applyMatrix4(this.matrixWorld);
                const N = e.ray.origin.distanceTo(m);
                N < e.near || N > e.far || t.push({
                    distance: N,
                    point: d.clone().applyMatrix4(this.matrixWorld),
                    index: M,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        } else {
            const g = Math.max(0, o.start)
              , S = Math.min(x.count, o.start + o.count);
            for (let M = g, T = S - 1; M < T; M += v) {
                if (f.fromBufferAttribute(x, M),
                h.fromBufferAttribute(x, M + 1),
                I0.distanceSqToSegment(f, h, m, d) > c)
                    continue;
                m.applyMatrix4(this.matrixWorld);
                const R = e.ray.origin.distanceTo(m);
                R < e.near || R > e.far || t.push({
                    distance: R,
                    point: d.clone().applyMatrix4(this.matrixWorld),
                    index: M,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
const gw = new U
  , vw = new U;
class Kr extends go {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , i = [];
            for (let r = 0, s = t.count; r < s; r += 2)
                gw.fromBufferAttribute(t, r),
                vw.fromBufferAttribute(t, r + 1),
                i[r] = r === 0 ? 0 : i[r - 1],
                i[r + 1] = i[r] + gw.distanceTo(vw);
            e.setAttribute("lineDistance", new We(i,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class RC extends go {
    constructor(e, t) {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class nx extends Gn {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new Ne(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const yw = new $e
  , Cy = new su
  , md = new ni
  , gd = new U;
class bC extends bt {
    constructor(e=new _t, t=new nx) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.matrixWorld
          , s = e.params.Points.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        md.copy(i.boundingSphere),
        md.applyMatrix4(r),
        md.radius += s,
        e.ray.intersectsSphere(md) === !1)
            return;
        yw.copy(r).invert(),
        Cy.copy(e.ray).applyMatrix4(yw);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , c = a * a
          , f = i.index
          , d = i.attributes.position;
        if (f !== null) {
            const m = Math.max(0, o.start)
              , v = Math.min(f.count, o.start + o.count);
            for (let _ = m, w = v; _ < w; _++) {
                const x = f.getX(_);
                gd.fromBufferAttribute(d, x),
                _w(gd, x, c, r, e, t, this)
            }
        } else {
            const m = Math.max(0, o.start)
              , v = Math.min(d.count, o.start + o.count);
            for (let _ = m, w = v; _ < w; _++)
                gd.fromBufferAttribute(d, _),
                _w(gd, _, c, r, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
function _w(n, e, t, i, r, s, o) {
    const a = Cy.distanceSqToPoint(n);
    if (a < t) {
        const c = new U;
        Cy.closestPointToPoint(n, c),
        c.applyMatrix4(i);
        const f = r.ray.origin.distanceTo(c);
        if (f < r.near || f > r.far)
            return;
        s.push({
            distance: f,
            distanceToRay: Math.sqrt(a),
            point: c,
            index: e,
            face: null,
            object: o
        })
    }
}
class _F extends en {
    constructor(e, t, i, r, s, o, a, c, f) {
        super(e, t, i, r, s, o, a, c, f),
        this.isVideoTexture = !0,
        this.minFilter = o !== void 0 ? o : Wt,
        this.magFilter = s !== void 0 ? s : Wt,
        this.generateMipmaps = !1;
        const h = this;
        function d() {
            h.needsUpdate = !0,
            e.requestVideoFrameCallback(d)
        }
        "requestVideoFrameCallback"in e && e.requestVideoFrameCallback(d)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback"in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class xF extends en {
    constructor(e, t) {
        super({
            width: e,
            height: t
        }),
        this.isFramebufferTexture = !0,
        this.magFilter = hn,
        this.minFilter = hn,
        this.generateMipmaps = !1,
        this.needsUpdate = !0
    }
}
class lm extends en {
    constructor(e, t, i, r, s, o, a, c, f, h, d, m) {
        super(null, o, a, c, f, h, r, s, d, m),
        this.isCompressedTexture = !0,
        this.image = {
            width: t,
            height: i
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class SF extends lm {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, s, o),
        this.isCompressedArrayTexture = !0,
        this.image.depth = r,
        this.wrapR = ei
    }
}
class MF extends lm {
    constructor(e, t, i) {
        super(void 0, e[0].width, e[0].height, t, i, Ts),
        this.isCompressedCubeTexture = !0,
        this.isCubeTexture = !0,
        this.image = e
    }
}
class wF extends en {
    constructor(e, t, i, r, s, o, a, c, f) {
        super(e, t, i, r, s, o, a, c, f),
        this.isCanvasTexture = !0,
        this.needsUpdate = !0
    }
}
class Rr {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getPoint(i, t)
    }
    getPoints(e=5) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPoint(i / e));
        return t
    }
    getSpacedPoints(e=5) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPointAt(i / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let i, r = this.getPoint(0), s = 0;
        t.push(0);
        for (let o = 1; o <= e; o++)
            i = this.getPoint(o / e),
            s += i.distanceTo(r),
            t.push(s),
            r = i;
        return this.cacheArcLengths = t,
        t
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, t) {
        const i = this.getLengths();
        let r = 0;
        const s = i.length;
        let o;
        t ? o = t : o = e * i[s - 1];
        let a = 0, c = s - 1, f;
        for (; a <= c; )
            if (r = Math.floor(a + (c - a) / 2),
            f = i[r] - o,
            f < 0)
                a = r + 1;
            else if (f > 0)
                c = r - 1;
            else {
                c = r;
                break
            }
        if (r = c,
        i[r] === o)
            return r / (s - 1);
        const h = i[r]
          , m = i[r + 1] - h
          , v = (o - h) / m;
        return (r + v) / (s - 1)
    }
    getTangent(e, t) {
        let r = e - 1e-4
          , s = e + 1e-4;
        r < 0 && (r = 0),
        s > 1 && (s = 1);
        const o = this.getPoint(r)
          , a = this.getPoint(s)
          , c = t || (o.isVector2 ? new he : new U);
        return c.copy(a).sub(o).normalize(),
        c
    }
    getTangentAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getTangent(i, t)
    }
    computeFrenetFrames(e, t) {
        const i = new U
          , r = []
          , s = []
          , o = []
          , a = new U
          , c = new $e;
        for (let v = 0; v <= e; v++) {
            const _ = v / e;
            r[v] = this.getTangentAt(_, new U)
        }
        s[0] = new U,
        o[0] = new U;
        let f = Number.MAX_VALUE;
        const h = Math.abs(r[0].x)
          , d = Math.abs(r[0].y)
          , m = Math.abs(r[0].z);
        h <= f && (f = h,
        i.set(1, 0, 0)),
        d <= f && (f = d,
        i.set(0, 1, 0)),
        m <= f && i.set(0, 0, 1),
        a.crossVectors(r[0], i).normalize(),
        s[0].crossVectors(r[0], a),
        o[0].crossVectors(r[0], s[0]);
        for (let v = 1; v <= e; v++) {
            if (s[v] = s[v - 1].clone(),
            o[v] = o[v - 1].clone(),
            a.crossVectors(r[v - 1], r[v]),
            a.length() > Number.EPSILON) {
                a.normalize();
                const _ = Math.acos(ln(r[v - 1].dot(r[v]), -1, 1));
                s[v].applyMatrix4(c.makeRotationAxis(a, _))
            }
            o[v].crossVectors(r[v], s[v])
        }
        if (t === !0) {
            let v = Math.acos(ln(s[0].dot(s[e]), -1, 1));
            v /= e,
            r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (v = -v);
            for (let _ = 1; _ <= e; _++)
                s[_].applyMatrix4(c.makeRotationAxis(r[_], v * _)),
                o[_].crossVectors(r[_], s[_])
        }
        return {
            tangents: r,
            normals: s,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
class um extends Rr {
    constructor(e=0, t=0, i=1, r=1, s=0, o=Math.PI * 2, a=!1, c=0) {
        super(),
        this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = t,
        this.xRadius = i,
        this.yRadius = r,
        this.aStartAngle = s,
        this.aEndAngle = o,
        this.aClockwise = a,
        this.aRotation = c
    }
    getPoint(e, t=new he) {
        const i = t
          , r = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(s) < Number.EPSILON;
        for (; s < 0; )
            s += r;
        for (; s > r; )
            s -= r;
        s < Number.EPSILON && (o ? s = 0 : s = r),
        this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r);
        const a = this.aStartAngle + e * s;
        let c = this.aX + this.xRadius * Math.cos(a)
          , f = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const h = Math.cos(this.aRotation)
              , d = Math.sin(this.aRotation)
              , m = c - this.aX
              , v = f - this.aY;
            c = m * h - v * d + this.aX,
            f = m * d + v * h + this.aY
        }
        return i.set(c, f)
    }
    copy(e) {
        return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
}
class PC extends um {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, i, r, s, o),
        this.isArcCurve = !0,
        this.type = "ArcCurve"
    }
}
function ix() {
    let n = 0
      , e = 0
      , t = 0
      , i = 0;
    function r(s, o, a, c) {
        n = s,
        e = a,
        t = -3 * s + 3 * o - 2 * a - c,
        i = 2 * s - 2 * o + a + c
    }
    return {
        initCatmullRom: function(s, o, a, c, f) {
            r(o, a, f * (a - s), f * (c - o))
        },
        initNonuniformCatmullRom: function(s, o, a, c, f, h, d) {
            let m = (o - s) / f - (a - s) / (f + h) + (a - o) / h
              , v = (a - o) / h - (c - o) / (h + d) + (c - a) / d;
            m *= h,
            v *= h,
            r(o, a, m, v)
        },
        calc: function(s) {
            const o = s * s
              , a = o * s;
            return n + e * s + t * o + i * a
        }
    }
}
const vd = new U
  , N0 = new ix
  , D0 = new ix
  , U0 = new ix;
class LC extends Rr {
    constructor(e=[], t=!1, i="centripetal", r=.5) {
        super(),
        this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = t,
        this.curveType = i,
        this.tension = r
    }
    getPoint(e, t=new U) {
        const i = t
          , r = this.points
          , s = r.length
          , o = (s - (this.closed ? 0 : 1)) * e;
        let a = Math.floor(o)
          , c = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : c === 0 && a === s - 1 && (a = s - 2,
        c = 1);
        let f, h;
        this.closed || a > 0 ? f = r[(a - 1) % s] : (vd.subVectors(r[0], r[1]).add(r[0]),
        f = vd);
        const d = r[a % s]
          , m = r[(a + 1) % s];
        if (this.closed || a + 2 < s ? h = r[(a + 2) % s] : (vd.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]),
        h = vd),
        this.curveType === "centripetal" || this.curveType === "chordal") {
            const v = this.curveType === "chordal" ? .5 : .25;
            let _ = Math.pow(f.distanceToSquared(d), v)
              , w = Math.pow(d.distanceToSquared(m), v)
              , x = Math.pow(m.distanceToSquared(h), v);
            w < 1e-4 && (w = 1),
            _ < 1e-4 && (_ = w),
            x < 1e-4 && (x = w),
            N0.initNonuniformCatmullRom(f.x, d.x, m.x, h.x, _, w, x),
            D0.initNonuniformCatmullRom(f.y, d.y, m.y, h.y, _, w, x),
            U0.initNonuniformCatmullRom(f.z, d.z, m.z, h.z, _, w, x)
        } else
            this.curveType === "catmullrom" && (N0.initCatmullRom(f.x, d.x, m.x, h.x, this.tension),
            D0.initCatmullRom(f.y, d.y, m.y, h.y, this.tension),
            U0.initCatmullRom(f.z, d.z, m.z, h.z, this.tension));
        return i.set(N0.calc(c), D0.calc(c), U0.calc(c)),
        i
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new U().fromArray(r))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
}
function xw(n, e, t, i, r) {
    const s = (i - e) * .5
      , o = (r - t) * .5
      , a = n * n
      , c = n * a;
    return (2 * t - 2 * i + s + o) * c + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
}
function EF(n, e) {
    const t = 1 - n;
    return t * t * e
}
function TF(n, e) {
    return 2 * (1 - n) * n * e
}
function AF(n, e) {
    return n * n * e
}
function Sc(n, e, t, i) {
    return EF(n, e) + TF(n, t) + AF(n, i)
}
function CF(n, e) {
    const t = 1 - n;
    return t * t * t * e
}
function RF(n, e) {
    const t = 1 - n;
    return 3 * t * t * n * e
}
function bF(n, e) {
    return 3 * (1 - n) * n * n * e
}
function PF(n, e) {
    return n * n * n * e
}
function Mc(n, e, t, i, r) {
    return CF(n, e) + RF(n, t) + bF(n, i) + PF(n, r)
}
class rx extends Rr {
    constructor(e=new he, t=new he, i=new he, r=new he) {
        super(),
        this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i,
        this.v3 = r
    }
    getPoint(e, t=new he) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return i.set(Mc(e, r.x, s.x, o.x, a.x), Mc(e, r.y, s.y, o.y, a.y)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class IC extends Rr {
    constructor(e=new U, t=new U, i=new U, r=new U) {
        super(),
        this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i,
        this.v3 = r
    }
    getPoint(e, t=new U) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return i.set(Mc(e, r.x, s.x, o.x, a.x), Mc(e, r.y, s.y, o.y, a.y), Mc(e, r.z, s.z, o.z, a.z)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class sx extends Rr {
    constructor(e=new he, t=new he) {
        super(),
        this.isLineCurve = !0,
        this.type = "LineCurve",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new he) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new he) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class NC extends Rr {
    constructor(e=new U, t=new U) {
        super(),
        this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new U) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new U) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class ox extends Rr {
    constructor(e=new he, t=new he, i=new he) {
        super(),
        this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i
    }
    getPoint(e, t=new he) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2;
        return i.set(Sc(e, r.x, s.x, o.x), Sc(e, r.y, s.y, o.y)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class ax extends Rr {
    constructor(e=new U, t=new U, i=new U) {
        super(),
        this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i
    }
    getPoint(e, t=new U) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2;
        return i.set(Sc(e, r.x, s.x, o.x), Sc(e, r.y, s.y, o.y), Sc(e, r.z, s.z, o.z)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class lx extends Rr {
    constructor(e=[]) {
        super(),
        this.isSplineCurve = !0,
        this.type = "SplineCurve",
        this.points = e
    }
    getPoint(e, t=new he) {
        const i = t
          , r = this.points
          , s = (r.length - 1) * e
          , o = Math.floor(s)
          , a = s - o
          , c = r[o === 0 ? o : o - 1]
          , f = r[o]
          , h = r[o > r.length - 2 ? r.length - 1 : o + 1]
          , d = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return i.set(xw(a, c.x, f.x, h.x, d.x), xw(a, c.y, f.y, h.y, d.y)),
        i
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new he().fromArray(r))
        }
        return this
    }
}
var bp = Object.freeze({
    __proto__: null,
    ArcCurve: PC,
    CatmullRomCurve3: LC,
    CubicBezierCurve: rx,
    CubicBezierCurve3: IC,
    EllipseCurve: um,
    LineCurve: sx,
    LineCurve3: NC,
    QuadraticBezierCurve: ox,
    QuadraticBezierCurve3: ax,
    SplineCurve: lx
});
class DC extends Rr {
    constructor() {
        super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0)
          , t = this.curves[this.curves.length - 1].getPoint(1);
        if (!e.equals(t)) {
            const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
            this.curves.push(new bp[i](t,e))
        }
        return this
    }
    getPoint(e, t) {
        const i = e * this.getLength()
          , r = this.getCurveLengths();
        let s = 0;
        for (; s < r.length; ) {
            if (r[s] >= i) {
                const o = r[s] - i
                  , a = this.curves[s]
                  , c = a.getLength()
                  , f = c === 0 ? 0 : 1 - o / c;
                return a.getPointAt(f, t)
            }
            s++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let i = 0, r = this.curves.length; i < r; i++)
            t += this.curves[i].getLength(),
            e.push(t);
        return this.cacheLengths = e,
        e
    }
    getSpacedPoints(e=40) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPoint(i / e));
        return this.autoClose && t.push(t[0]),
        t
    }
    getPoints(e=12) {
        const t = [];
        let i;
        for (let r = 0, s = this.curves; r < s.length; r++) {
            const o = s[r]
              , a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e
              , c = o.getPoints(a);
            for (let f = 0; f < c.length; f++) {
                const h = c[f];
                i && i.equals(h) || (t.push(h),
                i = h)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
        t
    }
    copy(e) {
        super.copy(e),
        this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(r.clone())
        }
        return this.autoClose = e.autoClose,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose,
        e.curves = [];
        for (let t = 0, i = this.curves.length; t < i; t++) {
            const r = this.curves[t];
            e.curves.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.autoClose = e.autoClose,
        this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(new bp[r.type]().fromJSON(r))
        }
        return this
    }
}
class tf extends DC {
    constructor(e) {
        super(),
        this.type = "Path",
        this.currentPoint = new he,
        e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, i = e.length; t < i; t++)
            this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t),
        this
    }
    lineTo(e, t) {
        const i = new sx(this.currentPoint.clone(),new he(e,t));
        return this.curves.push(i),
        this.currentPoint.set(e, t),
        this
    }
    quadraticCurveTo(e, t, i, r) {
        const s = new ox(this.currentPoint.clone(),new he(e,t),new he(i,r));
        return this.curves.push(s),
        this.currentPoint.set(i, r),
        this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        const a = new rx(this.currentPoint.clone(),new he(e,t),new he(i,r),new he(s,o));
        return this.curves.push(a),
        this.currentPoint.set(s, o),
        this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e)
          , i = new lx(t);
        return this.curves.push(i),
        this.currentPoint.copy(e[e.length - 1]),
        this
    }
    arc(e, t, i, r, s, o) {
        const a = this.currentPoint.x
          , c = this.currentPoint.y;
        return this.absarc(e + a, t + c, i, r, s, o),
        this
    }
    absarc(e, t, i, r, s, o) {
        return this.absellipse(e, t, i, i, r, s, o),
        this
    }
    ellipse(e, t, i, r, s, o, a, c) {
        const f = this.currentPoint.x
          , h = this.currentPoint.y;
        return this.absellipse(e + f, t + h, i, r, s, o, a, c),
        this
    }
    absellipse(e, t, i, r, s, o, a, c) {
        const f = new um(e,t,i,r,s,o,a,c);
        if (this.curves.length > 0) {
            const d = f.getPoint(0);
            d.equals(this.currentPoint) || this.lineTo(d.x, d.y)
        }
        this.curves.push(f);
        const h = f.getPoint(1);
        return this.currentPoint.copy(h),
        this
    }
    copy(e) {
        return super.copy(e),
        this.currentPoint.copy(e.currentPoint),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this
    }
}
class Sf extends _t {
    constructor(e=[new he(0,-.5), new he(.5,0), new he(0,.5)], t=12, i=0, r=Math.PI * 2) {
        super(),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: r
        },
        t = Math.floor(t),
        r = ln(r, 0, Math.PI * 2);
        const s = []
          , o = []
          , a = []
          , c = []
          , f = []
          , h = 1 / t
          , d = new U
          , m = new he
          , v = new U
          , _ = new U
          , w = new U;
        let x = 0
          , g = 0;
        for (let S = 0; S <= e.length - 1; S++)
            switch (S) {
            case 0:
                x = e[S + 1].x - e[S].x,
                g = e[S + 1].y - e[S].y,
                v.x = g * 1,
                v.y = -x,
                v.z = g * 0,
                w.copy(v),
                v.normalize(),
                c.push(v.x, v.y, v.z);
                break;
            case e.length - 1:
                c.push(w.x, w.y, w.z);
                break;
            default:
                x = e[S + 1].x - e[S].x,
                g = e[S + 1].y - e[S].y,
                v.x = g * 1,
                v.y = -x,
                v.z = g * 0,
                _.copy(v),
                v.x += w.x,
                v.y += w.y,
                v.z += w.z,
                v.normalize(),
                c.push(v.x, v.y, v.z),
                w.copy(_)
            }
        for (let S = 0; S <= t; S++) {
            const M = i + S * h * r
              , T = Math.sin(M)
              , P = Math.cos(M);
            for (let R = 0; R <= e.length - 1; R++) {
                d.x = e[R].x * T,
                d.y = e[R].y,
                d.z = e[R].x * P,
                o.push(d.x, d.y, d.z),
                m.x = S / t,
                m.y = R / (e.length - 1),
                a.push(m.x, m.y);
                const b = c[3 * R + 0] * T
                  , N = c[3 * R + 1]
                  , G = c[3 * R + 0] * P;
                f.push(b, N, G)
            }
        }
        for (let S = 0; S < t; S++)
            for (let M = 0; M < e.length - 1; M++) {
                const T = M + S * e.length
                  , P = T
                  , R = T + e.length
                  , b = T + e.length + 1
                  , N = T + 1;
                s.push(P, R, N),
                s.push(b, N, R)
            }
        this.setIndex(s),
        this.setAttribute("position", new We(o,3)),
        this.setAttribute("uv", new We(a,2)),
        this.setAttribute("normal", new We(f,3))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Sf(e.points,e.segments,e.phiStart,e.phiLength)
    }
}
class cm extends Sf {
    constructor(e=1, t=1, i=4, r=8) {
        const s = new tf;
        s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
        s.absarc(0, t / 2, e, 0, Math.PI * .5),
        super(s.getPoints(i), r),
        this.type = "CapsuleGeometry",
        this.parameters = {
            radius: e,
            length: t,
            capSegments: i,
            radialSegments: r
        }
    }
    static fromJSON(e) {
        return new cm(e.radius,e.length,e.capSegments,e.radialSegments)
    }
}
class fm extends _t {
    constructor(e=1, t=32, i=0, r=Math.PI * 2) {
        super(),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: r
        },
        t = Math.max(3, t);
        const s = []
          , o = []
          , a = []
          , c = []
          , f = new U
          , h = new he;
        o.push(0, 0, 0),
        a.push(0, 0, 1),
        c.push(.5, .5);
        for (let d = 0, m = 3; d <= t; d++,
        m += 3) {
            const v = i + d / t * r;
            f.x = e * Math.cos(v),
            f.y = e * Math.sin(v),
            o.push(f.x, f.y, f.z),
            a.push(0, 0, 1),
            h.x = (o[m] / e + 1) / 2,
            h.y = (o[m + 1] / e + 1) / 2,
            c.push(h.x, h.y)
        }
        for (let d = 1; d <= t; d++)
            s.push(d, d + 1, 0);
        this.setIndex(s),
        this.setAttribute("position", new We(o,3)),
        this.setAttribute("normal", new We(a,3)),
        this.setAttribute("uv", new We(c,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new fm(e.radius,e.segments,e.thetaStart,e.thetaLength)
    }
}
class lu extends _t {
    constructor(e=1, t=1, i=1, r=32, s=1, o=!1, a=0, c=Math.PI * 2) {
        super(),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: r,
            heightSegments: s,
            openEnded: o,
            thetaStart: a,
            thetaLength: c
        };
        const f = this;
        r = Math.floor(r),
        s = Math.floor(s);
        const h = []
          , d = []
          , m = []
          , v = [];
        let _ = 0;
        const w = []
          , x = i / 2;
        let g = 0;
        S(),
        o === !1 && (e > 0 && M(!0),
        t > 0 && M(!1)),
        this.setIndex(h),
        this.setAttribute("position", new We(d,3)),
        this.setAttribute("normal", new We(m,3)),
        this.setAttribute("uv", new We(v,2));
        function S() {
            const T = new U
              , P = new U;
            let R = 0;
            const b = (t - e) / i;
            for (let N = 0; N <= s; N++) {
                const G = []
                  , C = N / s
                  , I = C * (t - e) + e;
                for (let K = 0; K <= r; K++) {
                    const se = K / r
                      , B = se * c + a
                      , ie = Math.sin(B)
                      , J = Math.cos(B);
                    P.x = I * ie,
                    P.y = -C * i + x,
                    P.z = I * J,
                    d.push(P.x, P.y, P.z),
                    T.set(ie, b, J).normalize(),
                    m.push(T.x, T.y, T.z),
                    v.push(se, 1 - C),
                    G.push(_++)
                }
                w.push(G)
            }
            for (let N = 0; N < r; N++)
                for (let G = 0; G < s; G++) {
                    const C = w[G][N]
                      , I = w[G + 1][N]
                      , K = w[G + 1][N + 1]
                      , se = w[G][N + 1];
                    h.push(C, I, se),
                    h.push(I, K, se),
                    R += 6
                }
            f.addGroup(g, R, 0),
            g += R
        }
        function M(T) {
            const P = _
              , R = new he
              , b = new U;
            let N = 0;
            const G = T === !0 ? e : t
              , C = T === !0 ? 1 : -1;
            for (let K = 1; K <= r; K++)
                d.push(0, x * C, 0),
                m.push(0, C, 0),
                v.push(.5, .5),
                _++;
            const I = _;
            for (let K = 0; K <= r; K++) {
                const B = K / r * c + a
                  , ie = Math.cos(B)
                  , J = Math.sin(B);
                b.x = G * J,
                b.y = x * C,
                b.z = G * ie,
                d.push(b.x, b.y, b.z),
                m.push(0, C, 0),
                R.x = ie * .5 + .5,
                R.y = J * .5 * C + .5,
                v.push(R.x, R.y),
                _++
            }
            for (let K = 0; K < r; K++) {
                const se = P + K
                  , B = I + K;
                T === !0 ? h.push(B, B + 1, se) : h.push(B + 1, B, se),
                N += 3
            }
            f.addGroup(g, N, T === !0 ? 1 : 2),
            g += N
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new lu(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class hm extends lu {
    constructor(e=1, t=1, i=32, r=1, s=!1, o=0, a=Math.PI * 2) {
        super(0, e, t, i, r, s, o, a),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: r,
            openEnded: s,
            thetaStart: o,
            thetaLength: a
        }
    }
    static fromJSON(e) {
        return new hm(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class Mo extends _t {
    constructor(e=[], t=[], i=1, r=0) {
        super(),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: r
        };
        const s = []
          , o = [];
        a(r),
        f(i),
        h(),
        this.setAttribute("position", new We(s,3)),
        this.setAttribute("normal", new We(s.slice(),3)),
        this.setAttribute("uv", new We(o,2)),
        r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
        function a(S) {
            const M = new U
              , T = new U
              , P = new U;
            for (let R = 0; R < t.length; R += 3)
                v(t[R + 0], M),
                v(t[R + 1], T),
                v(t[R + 2], P),
                c(M, T, P, S)
        }
        function c(S, M, T, P) {
            const R = P + 1
              , b = [];
            for (let N = 0; N <= R; N++) {
                b[N] = [];
                const G = S.clone().lerp(T, N / R)
                  , C = M.clone().lerp(T, N / R)
                  , I = R - N;
                for (let K = 0; K <= I; K++)
                    K === 0 && N === R ? b[N][K] = G : b[N][K] = G.clone().lerp(C, K / I)
            }
            for (let N = 0; N < R; N++)
                for (let G = 0; G < 2 * (R - N) - 1; G++) {
                    const C = Math.floor(G / 2);
                    G % 2 === 0 ? (m(b[N][C + 1]),
                    m(b[N + 1][C]),
                    m(b[N][C])) : (m(b[N][C + 1]),
                    m(b[N + 1][C + 1]),
                    m(b[N + 1][C]))
                }
        }
        function f(S) {
            const M = new U;
            for (let T = 0; T < s.length; T += 3)
                M.x = s[T + 0],
                M.y = s[T + 1],
                M.z = s[T + 2],
                M.normalize().multiplyScalar(S),
                s[T + 0] = M.x,
                s[T + 1] = M.y,
                s[T + 2] = M.z
        }
        function h() {
            const S = new U;
            for (let M = 0; M < s.length; M += 3) {
                S.x = s[M + 0],
                S.y = s[M + 1],
                S.z = s[M + 2];
                const T = x(S) / 2 / Math.PI + .5
                  , P = g(S) / Math.PI + .5;
                o.push(T, 1 - P)
            }
            _(),
            d()
        }
        function d() {
            for (let S = 0; S < o.length; S += 6) {
                const M = o[S + 0]
                  , T = o[S + 2]
                  , P = o[S + 4]
                  , R = Math.max(M, T, P)
                  , b = Math.min(M, T, P);
                R > .9 && b < .1 && (M < .2 && (o[S + 0] += 1),
                T < .2 && (o[S + 2] += 1),
                P < .2 && (o[S + 4] += 1))
            }
        }
        function m(S) {
            s.push(S.x, S.y, S.z)
        }
        function v(S, M) {
            const T = S * 3;
            M.x = e[T + 0],
            M.y = e[T + 1],
            M.z = e[T + 2]
        }
        function _() {
            const S = new U
              , M = new U
              , T = new U
              , P = new U
              , R = new he
              , b = new he
              , N = new he;
            for (let G = 0, C = 0; G < s.length; G += 9,
            C += 6) {
                S.set(s[G + 0], s[G + 1], s[G + 2]),
                M.set(s[G + 3], s[G + 4], s[G + 5]),
                T.set(s[G + 6], s[G + 7], s[G + 8]),
                R.set(o[C + 0], o[C + 1]),
                b.set(o[C + 2], o[C + 3]),
                N.set(o[C + 4], o[C + 5]),
                P.copy(S).add(M).add(T).divideScalar(3);
                const I = x(P);
                w(R, C + 0, S, I),
                w(b, C + 2, M, I),
                w(N, C + 4, T, I)
            }
        }
        function w(S, M, T, P) {
            P < 0 && S.x === 1 && (o[M] = S.x - 1),
            T.x === 0 && T.z === 0 && (o[M] = P / 2 / Math.PI + .5)
        }
        function x(S) {
            return Math.atan2(S.z, -S.x)
        }
        function g(S) {
            return Math.atan2(-S.y, Math.sqrt(S.x * S.x + S.z * S.z))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Mo(e.vertices,e.indices,e.radius,e.details)
    }
}
class dm extends Mo {
    constructor(e=1, t=0) {
        const i = (1 + Math.sqrt(5)) / 2
          , r = 1 / i
          , s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r]
          , o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        super(s, o, e, t),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new dm(e.radius,e.detail)
    }
}
const yd = new U
  , _d = new U
  , O0 = new U
  , xd = new ki;
class UC extends _t {
    constructor(e=null, t=1) {
        if (super(),
        this.type = "EdgesGeometry",
        this.parameters = {
            geometry: e,
            thresholdAngle: t
        },
        e !== null) {
            const r = Math.pow(10, 4)
              , s = Math.cos(ua * t)
              , o = e.getIndex()
              , a = e.getAttribute("position")
              , c = o ? o.count : a.count
              , f = [0, 0, 0]
              , h = ["a", "b", "c"]
              , d = new Array(3)
              , m = {}
              , v = [];
            for (let _ = 0; _ < c; _ += 3) {
                o ? (f[0] = o.getX(_),
                f[1] = o.getX(_ + 1),
                f[2] = o.getX(_ + 2)) : (f[0] = _,
                f[1] = _ + 1,
                f[2] = _ + 2);
                const {a: w, b: x, c: g} = xd;
                if (w.fromBufferAttribute(a, f[0]),
                x.fromBufferAttribute(a, f[1]),
                g.fromBufferAttribute(a, f[2]),
                xd.getNormal(O0),
                d[0] = `${Math.round(w.x * r)},${Math.round(w.y * r)},${Math.round(w.z * r)}`,
                d[1] = `${Math.round(x.x * r)},${Math.round(x.y * r)},${Math.round(x.z * r)}`,
                d[2] = `${Math.round(g.x * r)},${Math.round(g.y * r)},${Math.round(g.z * r)}`,
                !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0]))
                    for (let S = 0; S < 3; S++) {
                        const M = (S + 1) % 3
                          , T = d[S]
                          , P = d[M]
                          , R = xd[h[S]]
                          , b = xd[h[M]]
                          , N = `${T}_${P}`
                          , G = `${P}_${T}`;
                        G in m && m[G] ? (O0.dot(m[G].normal) <= s && (v.push(R.x, R.y, R.z),
                        v.push(b.x, b.y, b.z)),
                        m[G] = null) : N in m || (m[N] = {
                            index0: f[S],
                            index1: f[M],
                            normal: O0.clone()
                        })
                    }
            }
            for (const _ in m)
                if (m[_]) {
                    const {index0: w, index1: x} = m[_];
                    yd.fromBufferAttribute(a, w),
                    _d.fromBufferAttribute(a, x),
                    v.push(yd.x, yd.y, yd.z),
                    v.push(_d.x, _d.y, _d.z)
                }
            this.setAttribute("position", new We(v,3))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
}
class fa extends tf {
    constructor(e) {
        super(e),
        this.uuid = Hi(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let i = 0, r = this.holes.length; i < r; i++)
            t[i] = this.holes[i].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e),
        this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid,
        e.holes = [];
        for (let t = 0, i = this.holes.length; t < i; t++) {
            const r = this.holes[t];
            e.holes.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.uuid = e.uuid,
        this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(new tf().fromJSON(r))
        }
        return this
    }
}
const LF = {
    triangulate: function(n, e, t=2) {
        const i = e && e.length
          , r = i ? e[0] * t : n.length;
        let s = OC(n, 0, r, t, !0);
        const o = [];
        if (!s || s.next === s.prev)
            return o;
        let a, c, f, h, d, m, v;
        if (i && (s = OF(n, e, s, t)),
        n.length > 80 * t) {
            a = f = n[0],
            c = h = n[1];
            for (let _ = t; _ < r; _ += t)
                d = n[_],
                m = n[_ + 1],
                d < a && (a = d),
                m < c && (c = m),
                d > f && (f = d),
                m > h && (h = m);
            v = Math.max(f - a, h - c),
            v = v !== 0 ? 32767 / v : 0
        }
        return nf(s, o, t, a, c, v, 0),
        o
    }
};
function OC(n, e, t, i, r) {
    let s, o;
    if (r === jF(n, e, t, i) > 0)
        for (s = e; s < t; s += i)
            o = Sw(s, n[s], n[s + 1], o);
    else
        for (s = t - i; s >= e; s -= i)
            o = Sw(s, n[s], n[s + 1], o);
    return o && pm(o, o.next) && (sf(o),
    o = o.next),
    o
}
function xa(n, e) {
    if (!n)
        return n;
    e || (e = n);
    let t = n, i;
    do
        if (i = !1,
        !t.steiner && (pm(t, t.next) || Qt(t.prev, t, t.next) === 0)) {
            if (sf(t),
            t = e = t.prev,
            t === t.next)
                break;
            i = !0
        } else
            t = t.next;
    while (i || t !== e);
    return e
}
function nf(n, e, t, i, r, s, o) {
    if (!n)
        return;
    !o && s && HF(n, i, r, s);
    let a = n, c, f;
    for (; n.prev !== n.next; ) {
        if (c = n.prev,
        f = n.next,
        s ? NF(n, i, r, s) : IF(n)) {
            e.push(c.i / t | 0),
            e.push(n.i / t | 0),
            e.push(f.i / t | 0),
            sf(n),
            n = f.next,
            a = f.next;
            continue
        }
        if (n = f,
        n === a) {
            o ? o === 1 ? (n = DF(xa(n), e, t),
            nf(n, e, t, i, r, s, 2)) : o === 2 && UF(n, e, t, i, r, s) : nf(xa(n), e, t, i, r, s, 1);
            break
        }
    }
}
function IF(n) {
    const e = n.prev
      , t = n
      , i = n.next;
    if (Qt(e, t, i) >= 0)
        return !1;
    const r = e.x
      , s = t.x
      , o = i.x
      , a = e.y
      , c = t.y
      , f = i.y
      , h = r < s ? r < o ? r : o : s < o ? s : o
      , d = a < c ? a < f ? a : f : c < f ? c : f
      , m = r > s ? r > o ? r : o : s > o ? s : o
      , v = a > c ? a > f ? a : f : c > f ? c : f;
    let _ = i.next;
    for (; _ !== e; ) {
        if (_.x >= h && _.x <= m && _.y >= d && _.y <= v && Nl(r, a, s, c, o, f, _.x, _.y) && Qt(_.prev, _, _.next) >= 0)
            return !1;
        _ = _.next
    }
    return !0
}
function NF(n, e, t, i) {
    const r = n.prev
      , s = n
      , o = n.next;
    if (Qt(r, s, o) >= 0)
        return !1;
    const a = r.x
      , c = s.x
      , f = o.x
      , h = r.y
      , d = s.y
      , m = o.y
      , v = a < c ? a < f ? a : f : c < f ? c : f
      , _ = h < d ? h < m ? h : m : d < m ? d : m
      , w = a > c ? a > f ? a : f : c > f ? c : f
      , x = h > d ? h > m ? h : m : d > m ? d : m
      , g = Ry(v, _, e, t, i)
      , S = Ry(w, x, e, t, i);
    let M = n.prevZ
      , T = n.nextZ;
    for (; M && M.z >= g && T && T.z <= S; ) {
        if (M.x >= v && M.x <= w && M.y >= _ && M.y <= x && M !== r && M !== o && Nl(a, h, c, d, f, m, M.x, M.y) && Qt(M.prev, M, M.next) >= 0 || (M = M.prevZ,
        T.x >= v && T.x <= w && T.y >= _ && T.y <= x && T !== r && T !== o && Nl(a, h, c, d, f, m, T.x, T.y) && Qt(T.prev, T, T.next) >= 0))
            return !1;
        T = T.nextZ
    }
    for (; M && M.z >= g; ) {
        if (M.x >= v && M.x <= w && M.y >= _ && M.y <= x && M !== r && M !== o && Nl(a, h, c, d, f, m, M.x, M.y) && Qt(M.prev, M, M.next) >= 0)
            return !1;
        M = M.prevZ
    }
    for (; T && T.z <= S; ) {
        if (T.x >= v && T.x <= w && T.y >= _ && T.y <= x && T !== r && T !== o && Nl(a, h, c, d, f, m, T.x, T.y) && Qt(T.prev, T, T.next) >= 0)
            return !1;
        T = T.nextZ
    }
    return !0
}
function DF(n, e, t) {
    let i = n;
    do {
        const r = i.prev
          , s = i.next.next;
        !pm(r, s) && FC(r, i, i.next, s) && rf(r, s) && rf(s, r) && (e.push(r.i / t | 0),
        e.push(i.i / t | 0),
        e.push(s.i / t | 0),
        sf(i),
        sf(i.next),
        i = n = s),
        i = i.next
    } while (i !== n);
    return xa(i)
}
function UF(n, e, t, i, r, s) {
    let o = n;
    do {
        let a = o.next.next;
        for (; a !== o.prev; ) {
            if (o.i !== a.i && WF(o, a)) {
                let c = kC(o, a);
                o = xa(o, o.next),
                c = xa(c, c.next),
                nf(o, e, t, i, r, s, 0),
                nf(c, e, t, i, r, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== n)
}
function OF(n, e, t, i) {
    const r = [];
    let s, o, a, c, f;
    for (s = 0,
    o = e.length; s < o; s++)
        a = e[s] * i,
        c = s < o - 1 ? e[s + 1] * i : n.length,
        f = OC(n, a, c, i, !1),
        f === f.next && (f.steiner = !0),
        r.push(GF(f));
    for (r.sort(FF),
    s = 0; s < r.length; s++)
        t = kF(r[s], t);
    return t
}
function FF(n, e) {
    return n.x - e.x
}
function kF(n, e) {
    const t = zF(n, e);
    if (!t)
        return e;
    const i = kC(t, n);
    return xa(i, i.next),
    xa(t, t.next)
}
function zF(n, e) {
    let t = e, i = -1 / 0, r;
    const s = n.x
      , o = n.y;
    do {
        if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
            const m = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (m <= s && m > i && (i = m,
            r = t.x < t.next.x ? t : t.next,
            m === s))
                return r
        }
        t = t.next
    } while (t !== e);
    if (!r)
        return null;
    const a = r
      , c = r.x
      , f = r.y;
    let h = 1 / 0, d;
    t = r;
    do
        s >= t.x && t.x >= c && s !== t.x && Nl(o < f ? s : i, o, c, f, o < f ? i : s, o, t.x, t.y) && (d = Math.abs(o - t.y) / (s - t.x),
        rf(t, n) && (d < h || d === h && (t.x > r.x || t.x === r.x && BF(r, t))) && (r = t,
        h = d)),
        t = t.next;
    while (t !== a);
    return r
}
function BF(n, e) {
    return Qt(n.prev, n, e.prev) < 0 && Qt(e.next, n, n.next) < 0
}
function HF(n, e, t, i) {
    let r = n;
    do
        r.z === 0 && (r.z = Ry(r.x, r.y, e, t, i)),
        r.prevZ = r.prev,
        r.nextZ = r.next,
        r = r.next;
    while (r !== n);
    r.prevZ.nextZ = null,
    r.prevZ = null,
    VF(r)
}
function VF(n) {
    let e, t, i, r, s, o, a, c, f = 1;
    do {
        for (t = n,
        n = null,
        s = null,
        o = 0; t; ) {
            for (o++,
            i = t,
            a = 0,
            e = 0; e < f && (a++,
            i = i.nextZ,
            !!i); e++)
                ;
            for (c = f; a > 0 || c > 0 && i; )
                a !== 0 && (c === 0 || !i || t.z <= i.z) ? (r = t,
                t = t.nextZ,
                a--) : (r = i,
                i = i.nextZ,
                c--),
                s ? s.nextZ = r : n = r,
                r.prevZ = s,
                s = r;
            t = i
        }
        s.nextZ = null,
        f *= 2
    } while (o > 1);
    return n
}
function Ry(n, e, t, i, r) {
    return n = (n - t) * r | 0,
    e = (e - i) * r | 0,
    n = (n | n << 8) & 16711935,
    n = (n | n << 4) & 252645135,
    n = (n | n << 2) & 858993459,
    n = (n | n << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    n | e << 1
}
function GF(n) {
    let e = n
      , t = n;
    do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
        e = e.next;
    while (e !== n);
    return t
}
function Nl(n, e, t, i, r, s, o, a) {
    return (r - o) * (e - a) >= (n - o) * (s - a) && (n - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (r - o) * (i - a)
}
function WF(n, e) {
    return n.next.i !== e.i && n.prev.i !== e.i && !XF(n, e) && (rf(n, e) && rf(e, n) && YF(n, e) && (Qt(n.prev, n, e.prev) || Qt(n, e.prev, e)) || pm(n, e) && Qt(n.prev, n, n.next) > 0 && Qt(e.prev, e, e.next) > 0)
}
function Qt(n, e, t) {
    return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}
function pm(n, e) {
    return n.x === e.x && n.y === e.y
}
function FC(n, e, t, i) {
    const r = Md(Qt(n, e, t))
      , s = Md(Qt(n, e, i))
      , o = Md(Qt(t, i, n))
      , a = Md(Qt(t, i, e));
    return !!(r !== s && o !== a || r === 0 && Sd(n, t, e) || s === 0 && Sd(n, i, e) || o === 0 && Sd(t, n, i) || a === 0 && Sd(t, e, i))
}
function Sd(n, e, t) {
    return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y)
}
function Md(n) {
    return n > 0 ? 1 : n < 0 ? -1 : 0
}
function XF(n, e) {
    let t = n;
    do {
        if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && FC(t, t.next, n, e))
            return !0;
        t = t.next
    } while (t !== n);
    return !1
}
function rf(n, e) {
    return Qt(n.prev, n, n.next) < 0 ? Qt(n, e, n.next) >= 0 && Qt(n, n.prev, e) >= 0 : Qt(n, e, n.prev) < 0 || Qt(n, n.next, e) < 0
}
function YF(n, e) {
    let t = n
      , i = !1;
    const r = (n.x + e.x) / 2
      , s = (n.y + e.y) / 2;
    do
        t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i),
        t = t.next;
    while (t !== n);
    return i
}
function kC(n, e) {
    const t = new by(n.i,n.x,n.y)
      , i = new by(e.i,e.x,e.y)
      , r = n.next
      , s = e.prev;
    return n.next = e,
    e.prev = n,
    t.next = r,
    r.prev = t,
    i.next = t,
    t.prev = i,
    s.next = i,
    i.prev = s,
    i
}
function Sw(n, e, t, i) {
    const r = new by(n,e,t);
    return i ? (r.next = i.next,
    r.prev = i,
    i.next.prev = r,
    i.next = r) : (r.prev = r,
    r.next = r),
    r
}
function sf(n) {
    n.next.prev = n.prev,
    n.prev.next = n.next,
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ)
}
function by(n, e, t) {
    this.i = n,
    this.x = e,
    this.y = t,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function jF(n, e, t, i) {
    let r = 0;
    for (let s = e, o = t - i; s < t; s += i)
        r += (n[o] - n[s]) * (n[s + 1] + n[o + 1]),
        o = s;
    return r
}
class qr {
    static area(e) {
        const t = e.length;
        let i = 0;
        for (let r = t - 1, s = 0; s < t; r = s++)
            i += e[r].x * e[s].y - e[s].x * e[r].y;
        return i * .5
    }
    static isClockWise(e) {
        return qr.area(e) < 0
    }
    static triangulateShape(e, t) {
        const i = []
          , r = []
          , s = [];
        Mw(e),
        ww(i, e);
        let o = e.length;
        t.forEach(Mw);
        for (let c = 0; c < t.length; c++)
            r.push(o),
            o += t[c].length,
            ww(i, t[c]);
        const a = LF.triangulate(i, r);
        for (let c = 0; c < a.length; c += 3)
            s.push(a.slice(c, c + 3));
        return s
    }
}
function Mw(n) {
    const e = n.length;
    e > 2 && n[e - 1].equals(n[0]) && n.pop()
}
function ww(n, e) {
    for (let t = 0; t < e.length; t++)
        n.push(e[t].x),
        n.push(e[t].y)
}
class Mf extends _t {
    constructor(e=new fa([new he(.5,.5), new he(-.5,.5), new he(-.5,-.5), new he(.5,-.5)]), t={}) {
        super(),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        const i = this
          , r = []
          , s = [];
        for (let a = 0, c = e.length; a < c; a++) {
            const f = e[a];
            o(f)
        }
        this.setAttribute("position", new We(r,3)),
        this.setAttribute("uv", new We(s,2)),
        this.computeVertexNormals();
        function o(a) {
            const c = []
              , f = t.curveSegments !== void 0 ? t.curveSegments : 12
              , h = t.steps !== void 0 ? t.steps : 1
              , d = t.depth !== void 0 ? t.depth : 1;
            let m = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0
              , v = t.bevelThickness !== void 0 ? t.bevelThickness : .2
              , _ = t.bevelSize !== void 0 ? t.bevelSize : v - .1
              , w = t.bevelOffset !== void 0 ? t.bevelOffset : 0
              , x = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const g = t.extrudePath
              , S = t.UVGenerator !== void 0 ? t.UVGenerator : qF;
            let M, T = !1, P, R, b, N;
            g && (M = g.getSpacedPoints(h),
            T = !0,
            m = !1,
            P = g.computeFrenetFrames(h, !1),
            R = new U,
            b = new U,
            N = new U),
            m || (x = 0,
            v = 0,
            _ = 0,
            w = 0);
            const G = a.extractPoints(f);
            let C = G.shape;
            const I = G.holes;
            if (!qr.isClockWise(C)) {
                C = C.reverse();
                for (let z = 0, ge = I.length; z < ge; z++) {
                    const fe = I[z];
                    qr.isClockWise(fe) && (I[z] = fe.reverse())
                }
            }
            const se = qr.triangulateShape(C, I)
              , B = C;
            for (let z = 0, ge = I.length; z < ge; z++) {
                const fe = I[z];
                C = C.concat(fe)
            }
            function ie(z, ge, fe) {
                return ge || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                z.clone().addScaledVector(ge, fe)
            }
            const J = C.length
              , ue = se.length;
            function F(z, ge, fe) {
                let Me, pe, Oe;
                const De = z.x - ge.x
                  , Ge = z.y - ge.y
                  , ft = fe.x - z.x
                  , O = fe.y - z.y
                  , L = De * De + Ge * Ge
                  , oe = De * O - Ge * ft;
                if (Math.abs(oe) > Number.EPSILON) {
                    const le = Math.sqrt(L)
                      , ye = Math.sqrt(ft * ft + O * O)
                      , me = ge.x - Ge / le
                      , st = ge.y + De / le
                      , et = fe.x - O / ye
                      , Te = fe.y + ft / ye
                      , Re = ((et - me) * O - (Te - st) * ft) / (De * O - Ge * ft);
                    Me = me + De * Re - z.x,
                    pe = st + Ge * Re - z.y;
                    const ot = Me * Me + pe * pe;
                    if (ot <= 2)
                        return new he(Me,pe);
                    Oe = Math.sqrt(ot / 2)
                } else {
                    let le = !1;
                    De > Number.EPSILON ? ft > Number.EPSILON && (le = !0) : De < -Number.EPSILON ? ft < -Number.EPSILON && (le = !0) : Math.sign(Ge) === Math.sign(O) && (le = !0),
                    le ? (Me = -Ge,
                    pe = De,
                    Oe = Math.sqrt(L)) : (Me = De,
                    pe = Ge,
                    Oe = Math.sqrt(L / 2))
                }
                return new he(Me / Oe,pe / Oe)
            }
            const H = [];
            for (let z = 0, ge = B.length, fe = ge - 1, Me = z + 1; z < ge; z++,
            fe++,
            Me++)
                fe === ge && (fe = 0),
                Me === ge && (Me = 0),
                H[z] = F(B[z], B[fe], B[Me]);
            const V = [];
            let q, ce = H.concat();
            for (let z = 0, ge = I.length; z < ge; z++) {
                const fe = I[z];
                q = [];
                for (let Me = 0, pe = fe.length, Oe = pe - 1, De = Me + 1; Me < pe; Me++,
                Oe++,
                De++)
                    Oe === pe && (Oe = 0),
                    De === pe && (De = 0),
                    q[Me] = F(fe[Me], fe[Oe], fe[De]);
                V.push(q),
                ce = ce.concat(q)
            }
            for (let z = 0; z < x; z++) {
                const ge = z / x
                  , fe = v * Math.cos(ge * Math.PI / 2)
                  , Me = _ * Math.sin(ge * Math.PI / 2) + w;
                for (let pe = 0, Oe = B.length; pe < Oe; pe++) {
                    const De = ie(B[pe], H[pe], Me);
                    ke(De.x, De.y, -fe)
                }
                for (let pe = 0, Oe = I.length; pe < Oe; pe++) {
                    const De = I[pe];
                    q = V[pe];
                    for (let Ge = 0, ft = De.length; Ge < ft; Ge++) {
                        const O = ie(De[Ge], q[Ge], Me);
                        ke(O.x, O.y, -fe)
                    }
                }
            }
            const Ce = _ + w;
            for (let z = 0; z < J; z++) {
                const ge = m ? ie(C[z], ce[z], Ce) : C[z];
                T ? (b.copy(P.normals[0]).multiplyScalar(ge.x),
                R.copy(P.binormals[0]).multiplyScalar(ge.y),
                N.copy(M[0]).add(b).add(R),
                ke(N.x, N.y, N.z)) : ke(ge.x, ge.y, 0)
            }
            for (let z = 1; z <= h; z++)
                for (let ge = 0; ge < J; ge++) {
                    const fe = m ? ie(C[ge], ce[ge], Ce) : C[ge];
                    T ? (b.copy(P.normals[z]).multiplyScalar(fe.x),
                    R.copy(P.binormals[z]).multiplyScalar(fe.y),
                    N.copy(M[z]).add(b).add(R),
                    ke(N.x, N.y, N.z)) : ke(fe.x, fe.y, d / h * z)
                }
            for (let z = x - 1; z >= 0; z--) {
                const ge = z / x
                  , fe = v * Math.cos(ge * Math.PI / 2)
                  , Me = _ * Math.sin(ge * Math.PI / 2) + w;
                for (let pe = 0, Oe = B.length; pe < Oe; pe++) {
                    const De = ie(B[pe], H[pe], Me);
                    ke(De.x, De.y, d + fe)
                }
                for (let pe = 0, Oe = I.length; pe < Oe; pe++) {
                    const De = I[pe];
                    q = V[pe];
                    for (let Ge = 0, ft = De.length; Ge < ft; Ge++) {
                        const O = ie(De[Ge], q[Ge], Me);
                        T ? ke(O.x, O.y + M[h - 1].y, M[h - 1].x + fe) : ke(O.x, O.y, d + fe)
                    }
                }
            }
            Z(),
            de();
            function Z() {
                const z = r.length / 3;
                if (m) {
                    let ge = 0
                      , fe = J * ge;
                    for (let Me = 0; Me < ue; Me++) {
                        const pe = se[Me];
                        Xe(pe[2] + fe, pe[1] + fe, pe[0] + fe)
                    }
                    ge = h + x * 2,
                    fe = J * ge;
                    for (let Me = 0; Me < ue; Me++) {
                        const pe = se[Me];
                        Xe(pe[0] + fe, pe[1] + fe, pe[2] + fe)
                    }
                } else {
                    for (let ge = 0; ge < ue; ge++) {
                        const fe = se[ge];
                        Xe(fe[2], fe[1], fe[0])
                    }
                    for (let ge = 0; ge < ue; ge++) {
                        const fe = se[ge];
                        Xe(fe[0] + J * h, fe[1] + J * h, fe[2] + J * h)
                    }
                }
                i.addGroup(z, r.length / 3 - z, 0)
            }
            function de() {
                const z = r.length / 3;
                let ge = 0;
                Se(B, ge),
                ge += B.length;
                for (let fe = 0, Me = I.length; fe < Me; fe++) {
                    const pe = I[fe];
                    Se(pe, ge),
                    ge += pe.length
                }
                i.addGroup(z, r.length / 3 - z, 1)
            }
            function Se(z, ge) {
                let fe = z.length;
                for (; --fe >= 0; ) {
                    const Me = fe;
                    let pe = fe - 1;
                    pe < 0 && (pe = z.length - 1);
                    for (let Oe = 0, De = h + x * 2; Oe < De; Oe++) {
                        const Ge = J * Oe
                          , ft = J * (Oe + 1)
                          , O = ge + Me + Ge
                          , L = ge + pe + Ge
                          , oe = ge + pe + ft
                          , le = ge + Me + ft;
                        ze(O, L, oe, le)
                    }
                }
            }
            function ke(z, ge, fe) {
                c.push(z),
                c.push(ge),
                c.push(fe)
            }
            function Xe(z, ge, fe) {
                ut(z),
                ut(ge),
                ut(fe);
                const Me = r.length / 3
                  , pe = S.generateTopUV(i, r, Me - 3, Me - 2, Me - 1);
                He(pe[0]),
                He(pe[1]),
                He(pe[2])
            }
            function ze(z, ge, fe, Me) {
                ut(z),
                ut(ge),
                ut(Me),
                ut(ge),
                ut(fe),
                ut(Me);
                const pe = r.length / 3
                  , Oe = S.generateSideWallUV(i, r, pe - 6, pe - 3, pe - 2, pe - 1);
                He(Oe[0]),
                He(Oe[1]),
                He(Oe[3]),
                He(Oe[1]),
                He(Oe[2]),
                He(Oe[3])
            }
            function ut(z) {
                r.push(c[z * 3 + 0]),
                r.push(c[z * 3 + 1]),
                r.push(c[z * 3 + 2])
            }
            function He(z) {
                s.push(z.x),
                s.push(z.y)
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes
          , i = this.parameters.options;
        return ZF(t, i, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let s = 0, o = e.shapes.length; s < o; s++) {
            const a = t[e.shapes[s]];
            i.push(a)
        }
        const r = e.options.extrudePath;
        return r !== void 0 && (e.options.extrudePath = new bp[r.type]().fromJSON(r)),
        new Mf(i,e.options)
    }
}
const qF = {
    generateTopUV: function(n, e, t, i, r) {
        const s = e[t * 3]
          , o = e[t * 3 + 1]
          , a = e[i * 3]
          , c = e[i * 3 + 1]
          , f = e[r * 3]
          , h = e[r * 3 + 1];
        return [new he(s,o), new he(a,c), new he(f,h)]
    },
    generateSideWallUV: function(n, e, t, i, r, s) {
        const o = e[t * 3]
          , a = e[t * 3 + 1]
          , c = e[t * 3 + 2]
          , f = e[i * 3]
          , h = e[i * 3 + 1]
          , d = e[i * 3 + 2]
          , m = e[r * 3]
          , v = e[r * 3 + 1]
          , _ = e[r * 3 + 2]
          , w = e[s * 3]
          , x = e[s * 3 + 1]
          , g = e[s * 3 + 2];
        return Math.abs(a - h) < Math.abs(o - f) ? [new he(o,1 - c), new he(f,1 - d), new he(m,1 - _), new he(w,1 - g)] : [new he(a,1 - c), new he(h,1 - d), new he(v,1 - _), new he(x,1 - g)]
    }
};
function ZF(n, e, t) {
    if (t.shapes = [],
    Array.isArray(n))
        for (let i = 0, r = n.length; i < r; i++) {
            const s = n[i];
            t.shapes.push(s.uuid)
        }
    else
        t.shapes.push(n.uuid);
    return t.options = Object.assign({}, e),
    e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()),
    t
}
class mm extends Mo {
    constructor(e=1, t=0) {
        const i = (1 + Math.sqrt(5)) / 2
          , r = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1]
          , s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        super(r, s, e, t),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new mm(e.radius,e.detail)
    }
}
class wf extends Mo {
    constructor(e=1, t=0) {
        const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
          , r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(i, r, e, t),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new wf(e.radius,e.detail)
    }
}
class gm extends _t {
    constructor(e=.5, t=1, i=32, r=1, s=0, o=Math.PI * 2) {
        super(),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: r,
            thetaStart: s,
            thetaLength: o
        },
        i = Math.max(3, i),
        r = Math.max(1, r);
        const a = []
          , c = []
          , f = []
          , h = [];
        let d = e;
        const m = (t - e) / r
          , v = new U
          , _ = new he;
        for (let w = 0; w <= r; w++) {
            for (let x = 0; x <= i; x++) {
                const g = s + x / i * o;
                v.x = d * Math.cos(g),
                v.y = d * Math.sin(g),
                c.push(v.x, v.y, v.z),
                f.push(0, 0, 1),
                _.x = (v.x / t + 1) / 2,
                _.y = (v.y / t + 1) / 2,
                h.push(_.x, _.y)
            }
            d += m
        }
        for (let w = 0; w < r; w++) {
            const x = w * (i + 1);
            for (let g = 0; g < i; g++) {
                const S = g + x
                  , M = S
                  , T = S + i + 1
                  , P = S + i + 2
                  , R = S + 1;
                a.push(M, T, R),
                a.push(T, P, R)
            }
        }
        this.setIndex(a),
        this.setAttribute("position", new We(c,3)),
        this.setAttribute("normal", new We(f,3)),
        this.setAttribute("uv", new We(h,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new gm(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)
    }
}
class vm extends _t {
    constructor(e=new fa([new he(0,.5), new he(-.5,-.5), new he(.5,-.5)]), t=12) {
        super(),
        this.type = "ShapeGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        };
        const i = []
          , r = []
          , s = []
          , o = [];
        let a = 0
          , c = 0;
        if (Array.isArray(e) === !1)
            f(e);
        else
            for (let h = 0; h < e.length; h++)
                f(e[h]),
                this.addGroup(a, c, h),
                a += c,
                c = 0;
        this.setIndex(i),
        this.setAttribute("position", new We(r,3)),
        this.setAttribute("normal", new We(s,3)),
        this.setAttribute("uv", new We(o,2));
        function f(h) {
            const d = r.length / 3
              , m = h.extractPoints(t);
            let v = m.shape;
            const _ = m.holes;
            qr.isClockWise(v) === !1 && (v = v.reverse());
            for (let x = 0, g = _.length; x < g; x++) {
                const S = _[x];
                qr.isClockWise(S) === !0 && (_[x] = S.reverse())
            }
            const w = qr.triangulateShape(v, _);
            for (let x = 0, g = _.length; x < g; x++) {
                const S = _[x];
                v = v.concat(S)
            }
            for (let x = 0, g = v.length; x < g; x++) {
                const S = v[x];
                r.push(S.x, S.y, 0),
                s.push(0, 0, 1),
                o.push(S.x, S.y)
            }
            for (let x = 0, g = w.length; x < g; x++) {
                const S = w[x]
                  , M = S[0] + d
                  , T = S[1] + d
                  , P = S[2] + d;
                i.push(M, T, P),
                c += 3
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes;
        return JF(t, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let r = 0, s = e.shapes.length; r < s; r++) {
            const o = t[e.shapes[r]];
            i.push(o)
        }
        return new vm(i,e.curveSegments)
    }
}
function JF(n, e) {
    if (e.shapes = [],
    Array.isArray(n))
        for (let t = 0, i = n.length; t < i; t++) {
            const r = n[t];
            e.shapes.push(r.uuid)
        }
    else
        e.shapes.push(n.uuid);
    return e
}
class Ef extends _t {
    constructor(e=1, t=32, i=16, r=0, s=Math.PI * 2, o=0, a=Math.PI) {
        super(),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: r,
            phiLength: s,
            thetaStart: o,
            thetaLength: a
        },
        t = Math.max(3, Math.floor(t)),
        i = Math.max(2, Math.floor(i));
        const c = Math.min(o + a, Math.PI);
        let f = 0;
        const h = []
          , d = new U
          , m = new U
          , v = []
          , _ = []
          , w = []
          , x = [];
        for (let g = 0; g <= i; g++) {
            const S = []
              , M = g / i;
            let T = 0;
            g === 0 && o === 0 ? T = .5 / t : g === i && c === Math.PI && (T = -.5 / t);
            for (let P = 0; P <= t; P++) {
                const R = P / t;
                d.x = -e * Math.cos(r + R * s) * Math.sin(o + M * a),
                d.y = e * Math.cos(o + M * a),
                d.z = e * Math.sin(r + R * s) * Math.sin(o + M * a),
                _.push(d.x, d.y, d.z),
                m.copy(d).normalize(),
                w.push(m.x, m.y, m.z),
                x.push(R + T, 1 - M),
                S.push(f++)
            }
            h.push(S)
        }
        for (let g = 0; g < i; g++)
            for (let S = 0; S < t; S++) {
                const M = h[g][S + 1]
                  , T = h[g][S]
                  , P = h[g + 1][S]
                  , R = h[g + 1][S + 1];
                (g !== 0 || o > 0) && v.push(M, T, R),
                (g !== i - 1 || c < Math.PI) && v.push(T, P, R)
            }
        this.setIndex(v),
        this.setAttribute("position", new We(_,3)),
        this.setAttribute("normal", new We(w,3)),
        this.setAttribute("uv", new We(x,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Ef(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
    }
}
class ym extends Mo {
    constructor(e=1, t=0) {
        const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]
          , r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(i, r, e, t),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new ym(e.radius,e.detail)
    }
}
class _m extends _t {
    constructor(e=1, t=.4, i=12, r=48, s=Math.PI * 2) {
        super(),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: r,
            arc: s
        },
        i = Math.floor(i),
        r = Math.floor(r);
        const o = []
          , a = []
          , c = []
          , f = []
          , h = new U
          , d = new U
          , m = new U;
        for (let v = 0; v <= i; v++)
            for (let _ = 0; _ <= r; _++) {
                const w = _ / r * s
                  , x = v / i * Math.PI * 2;
                d.x = (e + t * Math.cos(x)) * Math.cos(w),
                d.y = (e + t * Math.cos(x)) * Math.sin(w),
                d.z = t * Math.sin(x),
                a.push(d.x, d.y, d.z),
                h.x = e * Math.cos(w),
                h.y = e * Math.sin(w),
                m.subVectors(d, h).normalize(),
                c.push(m.x, m.y, m.z),
                f.push(_ / r),
                f.push(v / i)
            }
        for (let v = 1; v <= i; v++)
            for (let _ = 1; _ <= r; _++) {
                const w = (r + 1) * v + _ - 1
                  , x = (r + 1) * (v - 1) + _ - 1
                  , g = (r + 1) * (v - 1) + _
                  , S = (r + 1) * v + _;
                o.push(w, x, S),
                o.push(x, g, S)
            }
        this.setIndex(o),
        this.setAttribute("position", new We(a,3)),
        this.setAttribute("normal", new We(c,3)),
        this.setAttribute("uv", new We(f,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new _m(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)
    }
}
class xm extends _t {
    constructor(e=1, t=.4, i=64, r=8, s=2, o=3) {
        super(),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: r,
            p: s,
            q: o
        },
        i = Math.floor(i),
        r = Math.floor(r);
        const a = []
          , c = []
          , f = []
          , h = []
          , d = new U
          , m = new U
          , v = new U
          , _ = new U
          , w = new U
          , x = new U
          , g = new U;
        for (let M = 0; M <= i; ++M) {
            const T = M / i * s * Math.PI * 2;
            S(T, s, o, e, v),
            S(T + .01, s, o, e, _),
            x.subVectors(_, v),
            g.addVectors(_, v),
            w.crossVectors(x, g),
            g.crossVectors(w, x),
            w.normalize(),
            g.normalize();
            for (let P = 0; P <= r; ++P) {
                const R = P / r * Math.PI * 2
                  , b = -t * Math.cos(R)
                  , N = t * Math.sin(R);
                d.x = v.x + (b * g.x + N * w.x),
                d.y = v.y + (b * g.y + N * w.y),
                d.z = v.z + (b * g.z + N * w.z),
                c.push(d.x, d.y, d.z),
                m.subVectors(d, v).normalize(),
                f.push(m.x, m.y, m.z),
                h.push(M / i),
                h.push(P / r)
            }
        }
        for (let M = 1; M <= i; M++)
            for (let T = 1; T <= r; T++) {
                const P = (r + 1) * (M - 1) + (T - 1)
                  , R = (r + 1) * M + (T - 1)
                  , b = (r + 1) * M + T
                  , N = (r + 1) * (M - 1) + T;
                a.push(P, R, N),
                a.push(R, b, N)
            }
        this.setIndex(a),
        this.setAttribute("position", new We(c,3)),
        this.setAttribute("normal", new We(f,3)),
        this.setAttribute("uv", new We(h,2));
        function S(M, T, P, R, b) {
            const N = Math.cos(M)
              , G = Math.sin(M)
              , C = P / T * M
              , I = Math.cos(C);
            b.x = R * (2 + I) * .5 * N,
            b.y = R * (2 + I) * G * .5,
            b.z = R * Math.sin(C) * .5
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new xm(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)
    }
}
class Sm extends _t {
    constructor(e=new ax(new U(-1,-1,0),new U(-1,1,0),new U(1,1,0)), t=64, i=1, r=8, s=!1) {
        super(),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: r,
            closed: s
        };
        const o = e.computeFrenetFrames(t, s);
        this.tangents = o.tangents,
        this.normals = o.normals,
        this.binormals = o.binormals;
        const a = new U
          , c = new U
          , f = new he;
        let h = new U;
        const d = []
          , m = []
          , v = []
          , _ = [];
        w(),
        this.setIndex(_),
        this.setAttribute("position", new We(d,3)),
        this.setAttribute("normal", new We(m,3)),
        this.setAttribute("uv", new We(v,2));
        function w() {
            for (let M = 0; M < t; M++)
                x(M);
            x(s === !1 ? t : 0),
            S(),
            g()
        }
        function x(M) {
            h = e.getPointAt(M / t, h);
            const T = o.normals[M]
              , P = o.binormals[M];
            for (let R = 0; R <= r; R++) {
                const b = R / r * Math.PI * 2
                  , N = Math.sin(b)
                  , G = -Math.cos(b);
                c.x = G * T.x + N * P.x,
                c.y = G * T.y + N * P.y,
                c.z = G * T.z + N * P.z,
                c.normalize(),
                m.push(c.x, c.y, c.z),
                a.x = h.x + i * c.x,
                a.y = h.y + i * c.y,
                a.z = h.z + i * c.z,
                d.push(a.x, a.y, a.z)
            }
        }
        function g() {
            for (let M = 1; M <= t; M++)
                for (let T = 1; T <= r; T++) {
                    const P = (r + 1) * (M - 1) + (T - 1)
                      , R = (r + 1) * M + (T - 1)
                      , b = (r + 1) * M + T
                      , N = (r + 1) * (M - 1) + T;
                    _.push(P, R, N),
                    _.push(R, b, N)
                }
        }
        function S() {
            for (let M = 0; M <= t; M++)
                for (let T = 0; T <= r; T++)
                    f.x = M / t,
                    f.y = T / r,
                    v.push(f.x, f.y)
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(),
        e
    }
    static fromJSON(e) {
        return new Sm(new bp[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)
    }
}
class zC extends _t {
    constructor(e=null) {
        if (super(),
        this.type = "WireframeGeometry",
        this.parameters = {
            geometry: e
        },
        e !== null) {
            const t = []
              , i = new Set
              , r = new U
              , s = new U;
            if (e.index !== null) {
                const o = e.attributes.position
                  , a = e.index;
                let c = e.groups;
                c.length === 0 && (c = [{
                    start: 0,
                    count: a.count,
                    materialIndex: 0
                }]);
                for (let f = 0, h = c.length; f < h; ++f) {
                    const d = c[f]
                      , m = d.start
                      , v = d.count;
                    for (let _ = m, w = m + v; _ < w; _ += 3)
                        for (let x = 0; x < 3; x++) {
                            const g = a.getX(_ + x)
                              , S = a.getX(_ + (x + 1) % 3);
                            r.fromBufferAttribute(o, g),
                            s.fromBufferAttribute(o, S),
                            Ew(r, s, i) === !0 && (t.push(r.x, r.y, r.z),
                            t.push(s.x, s.y, s.z))
                        }
                }
            } else {
                const o = e.attributes.position;
                for (let a = 0, c = o.count / 3; a < c; a++)
                    for (let f = 0; f < 3; f++) {
                        const h = 3 * a + f
                          , d = 3 * a + (f + 1) % 3;
                        r.fromBufferAttribute(o, h),
                        s.fromBufferAttribute(o, d),
                        Ew(r, s, i) === !0 && (t.push(r.x, r.y, r.z),
                        t.push(s.x, s.y, s.z))
                    }
            }
            this.setAttribute("position", new We(t,3))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
}
function Ew(n, e, t) {
    const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`
      , r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
    return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i),
    t.add(r),
    !0)
}
var Tw = Object.freeze({
    __proto__: null,
    BoxGeometry: wa,
    CapsuleGeometry: cm,
    CircleGeometry: fm,
    ConeGeometry: hm,
    CylinderGeometry: lu,
    DodecahedronGeometry: dm,
    EdgesGeometry: UC,
    ExtrudeGeometry: Mf,
    IcosahedronGeometry: mm,
    LatheGeometry: Sf,
    OctahedronGeometry: wf,
    PlaneGeometry: ou,
    PolyhedronGeometry: Mo,
    RingGeometry: gm,
    ShapeGeometry: vm,
    SphereGeometry: Ef,
    TetrahedronGeometry: ym,
    TorusGeometry: _m,
    TorusKnotGeometry: xm,
    TubeGeometry: Sm,
    WireframeGeometry: zC
});
class BC extends Gn {
    constructor(e) {
        super(),
        this.isShadowMaterial = !0,
        this.type = "ShadowMaterial",
        this.color = new Ne(0),
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.fog = e.fog,
        this
    }
}
class HC extends fr {
    constructor(e) {
        super(e),
        this.isRawShaderMaterial = !0,
        this.type = "RawShaderMaterial"
    }
}
class ux extends Gn {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Ne(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ne(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = xo,
        this.normalScale = new he(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Ri,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class cx extends ux {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.anisotropyRotation = 0,
        this.anisotropyMap = null,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new he(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return ln(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new Ne(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new Ne(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new Ne(1,1,1),
        this.specularColorMap = null,
        this._anisotropy = 0,
        this._clearcoat = 0,
        this._iridescence = 0,
        this._sheen = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++,
        this._anisotropy = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.anisotropy = e.anisotropy,
        this.anisotropyRotation = e.anisotropyRotation,
        this.anisotropyMap = e.anisotropyMap,
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
class VC extends Gn {
    constructor(e) {
        super(),
        this.isMeshPhongMaterial = !0,
        this.type = "MeshPhongMaterial",
        this.color = new Ne(16777215),
        this.specular = new Ne(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ne(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = xo,
        this.normalScale = new he(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Ri,
        this.combine = mf,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class GC extends Gn {
    constructor(e) {
        super(),
        this.isMeshToonMaterial = !0,
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new Ne(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ne(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = xo,
        this.normalScale = new he(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.gradientMap = e.gradientMap,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
class WC extends Gn {
    constructor(e) {
        super(),
        this.isMeshNormalMaterial = !0,
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = xo,
        this.normalScale = new he(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.flatShading = e.flatShading,
        this
    }
}
class XC extends Gn {
    constructor(e) {
        super(),
        this.isMeshLambertMaterial = !0,
        this.type = "MeshLambertMaterial",
        this.color = new Ne(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ne(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = xo,
        this.normalScale = new he(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Ri,
        this.combine = mf,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class YC extends Gn {
    constructor(e) {
        super(),
        this.isMeshMatcapMaterial = !0,
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new Ne(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = xo,
        this.normalScale = new he(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class jC extends gi {
    constructor(e) {
        super(),
        this.isLineDashedMaterial = !0,
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
}
function ra(n, e, t) {
    return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n)
}
function qC(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView)
}
function ZC(n) {
    function e(r, s) {
        return n[r] - n[s]
    }
    const t = n.length
      , i = new Array(t);
    for (let r = 0; r !== t; ++r)
        i[r] = r;
    return i.sort(e),
    i
}
function Py(n, e, t) {
    const i = n.length
      , r = new n.constructor(i);
    for (let s = 0, o = 0; o !== i; ++s) {
        const a = t[s] * e;
        for (let c = 0; c !== e; ++c)
            r[o++] = n[a + c]
    }
    return r
}
function fx(n, e, t, i) {
    let r = 1
      , s = n[0];
    for (; s !== void 0 && s[i] === void 0; )
        s = n[r++];
    if (s === void 0)
        return;
    let o = s[i];
    if (o !== void 0)
        if (Array.isArray(o))
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                t.push.apply(t, o)),
                s = n[r++];
            while (s !== void 0);
        else if (o.toArray !== void 0)
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                o.toArray(t, t.length)),
                s = n[r++];
            while (s !== void 0);
        else
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                t.push(o)),
                s = n[r++];
            while (s !== void 0)
}
function KF(n, e, t, i, r=30) {
    const s = n.clone();
    s.name = e;
    const o = [];
    for (let c = 0; c < s.tracks.length; ++c) {
        const f = s.tracks[c]
          , h = f.getValueSize()
          , d = []
          , m = [];
        for (let v = 0; v < f.times.length; ++v) {
            const _ = f.times[v] * r;
            if (!(_ < t || _ >= i)) {
                d.push(f.times[v]);
                for (let w = 0; w < h; ++w)
                    m.push(f.values[v * h + w])
            }
        }
        d.length !== 0 && (f.times = ra(d, f.times.constructor),
        f.values = ra(m, f.values.constructor),
        o.push(f))
    }
    s.tracks = o;
    let a = 1 / 0;
    for (let c = 0; c < s.tracks.length; ++c)
        a > s.tracks[c].times[0] && (a = s.tracks[c].times[0]);
    for (let c = 0; c < s.tracks.length; ++c)
        s.tracks[c].shift(-1 * a);
    return s.resetDuration(),
    s
}
function QF(n, e=0, t=n, i=30) {
    i <= 0 && (i = 30);
    const r = t.tracks.length
      , s = e / i;
    for (let o = 0; o < r; ++o) {
        const a = t.tracks[o]
          , c = a.ValueTypeName;
        if (c === "bool" || c === "string")
            continue;
        const f = n.tracks.find(function(g) {
            return g.name === a.name && g.ValueTypeName === c
        });
        if (f === void 0)
            continue;
        let h = 0;
        const d = a.getValueSize();
        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = d / 3);
        let m = 0;
        const v = f.getValueSize();
        f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (m = v / 3);
        const _ = a.times.length - 1;
        let w;
        if (s <= a.times[0]) {
            const g = h
              , S = d - h;
            w = a.values.slice(g, S)
        } else if (s >= a.times[_]) {
            const g = _ * d + h
              , S = g + d - h;
            w = a.values.slice(g, S)
        } else {
            const g = a.createInterpolant()
              , S = h
              , M = d - h;
            g.evaluate(s),
            w = g.resultBuffer.slice(S, M)
        }
        c === "quaternion" && new En().fromArray(w).normalize().conjugate().toArray(w);
        const x = f.times.length;
        for (let g = 0; g < x; ++g) {
            const S = g * v + m;
            if (c === "quaternion")
                En.multiplyQuaternionsFlat(f.values, S, w, 0, f.values, S);
            else {
                const M = v - m * 2;
                for (let T = 0; T < M; ++T)
                    f.values[S + T] -= w[T]
            }
        }
    }
    return n.blendMode = V_,
    n
}
const $F = {
    convertArray: ra,
    isTypedArray: qC,
    getKeyframeOrder: ZC,
    sortedArray: Py,
    flattenJSON: fx,
    subclip: KF,
    makeClipAdditive: QF
};
class Tf {
    constructor(e, t, i, r) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = r !== void 0 ? r : new t.constructor(i),
        this.sampleValues = t,
        this.valueSize = i,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let i = this._cachedIndex
          , r = t[i]
          , s = t[i - 1];
        e: {
            t: {
                let o;
                n: {
                    i: if (!(e < r)) {
                        for (let a = i + 2; ; ) {
                            if (r === void 0) {
                                if (e < s)
                                    break i;
                                return i = t.length,
                                this._cachedIndex = i,
                                this.copySampleValue_(i - 1)
                            }
                            if (i === a)
                                break;
                            if (s = r,
                            r = t[++i],
                            e < r)
                                break t
                        }
                        o = t.length;
                        break n
                    }
                    if (!(e >= s)) {
                        const a = t[1];
                        e < a && (i = 2,
                        s = a);
                        for (let c = i - 2; ; ) {
                            if (s === void 0)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (i === c)
                                break;
                            if (r = s,
                            s = t[--i - 1],
                            e >= s)
                                break t
                        }
                        o = i,
                        i = 0;
                        break n
                    }
                    break e
                }
                for (; i < o; ) {
                    const a = i + o >>> 1;
                    e < t[a] ? o = a : i = a + 1
                }
                if (r = t[i],
                s = t[i - 1],
                s === void 0)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (r === void 0)
                    return i = t.length,
                    this._cachedIndex = i,
                    this.copySampleValue_(i - 1)
            }
            this._cachedIndex = i,
            this.intervalChanged_(i, s, r)
        }
        return this.interpolate_(i, s, e, r)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , i = this.sampleValues
          , r = this.valueSize
          , s = e * r;
        for (let o = 0; o !== r; ++o)
            t[o] = i[s + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class JC extends Tf {
    constructor(e, t, i, r) {
        super(e, t, i, r),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: ta,
            endingEnd: ta
        }
    }
    intervalChanged_(e, t, i) {
        const r = this.parameterPositions;
        let s = e - 2
          , o = e + 1
          , a = r[s]
          , c = r[o];
        if (a === void 0)
            switch (this.getSettings_().endingStart) {
            case na:
                s = e,
                a = 2 * t - i;
                break;
            case qc:
                s = r.length - 2,
                a = t + r[s] - r[s + 1];
                break;
            default:
                s = e,
                a = i
            }
        if (c === void 0)
            switch (this.getSettings_().endingEnd) {
            case na:
                o = e,
                c = 2 * i - t;
                break;
            case qc:
                o = 1,
                c = i + r[1] - r[0];
                break;
            default:
                o = e - 1,
                c = t
            }
        const f = (i - t) * .5
          , h = this.valueSize;
        this._weightPrev = f / (t - a),
        this._weightNext = f / (c - i),
        this._offsetPrev = s * h,
        this._offsetNext = o * h
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , c = e * a
          , f = c - a
          , h = this._offsetPrev
          , d = this._offsetNext
          , m = this._weightPrev
          , v = this._weightNext
          , _ = (i - t) / (r - t)
          , w = _ * _
          , x = w * _
          , g = -m * x + 2 * m * w - m * _
          , S = (1 + m) * x + (-1.5 - 2 * m) * w + (-.5 + m) * _ + 1
          , M = (-1 - v) * x + (1.5 + v) * w + .5 * _
          , T = v * x - v * w;
        for (let P = 0; P !== a; ++P)
            s[P] = g * o[h + P] + S * o[f + P] + M * o[c + P] + T * o[d + P];
        return s
    }
}
class hx extends Tf {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , c = e * a
          , f = c - a
          , h = (i - t) / (r - t)
          , d = 1 - h;
        for (let m = 0; m !== a; ++m)
            s[m] = o[f + m] * d + o[c + m] * h;
        return s
    }
}
class KC extends Tf {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class br {
    constructor(e, t, i, r) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = ra(t, this.TimeBufferType),
        this.values = ra(i, this.ValueBufferType),
        this.setInterpolation(r || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let i;
        if (t.toJSON !== this.toJSON)
            i = t.toJSON(e);
        else {
            i = {
                name: e.name,
                times: ra(e.times, Array),
                values: ra(e.values, Array)
            };
            const r = e.getInterpolation();
            r !== e.DefaultInterpolation && (i.interpolation = r)
        }
        return i.type = e.ValueTypeName,
        i
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new KC(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new hx(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new JC(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case Yc:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case jc:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case Jd:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(i);
            return console.warn("THREE.KeyframeTrack:", i),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return Yc;
        case this.InterpolantFactoryMethodLinear:
            return jc;
        case this.InterpolantFactoryMethodSmooth:
            return Jd
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i)
                t[i] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i)
                t[i] *= e
        }
        return this
    }
    trim(e, t) {
        const i = this.times
          , r = i.length;
        let s = 0
          , o = r - 1;
        for (; s !== r && i[s] < e; )
            ++s;
        for (; o !== -1 && i[o] > t; )
            --o;
        if (++o,
        s !== 0 || o !== r) {
            s >= o && (o = Math.max(o, 1),
            s = o - 1);
            const a = this.getValueSize();
            this.times = i.slice(s, o),
            this.values = this.values.slice(s * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const i = this.times
          , r = this.values
          , s = i.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let o = null;
        for (let a = 0; a !== s; a++) {
            const c = i[a];
            if (typeof c == "number" && isNaN(c)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, c),
                e = !1;
                break
            }
            if (o !== null && o > c) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, c, o),
                e = !1;
                break
            }
            o = c
        }
        if (r !== void 0 && qC(r))
            for (let a = 0, c = r.length; a !== c; ++a) {
                const f = r[a];
                if (isNaN(f)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, f),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = this.times.slice()
          , t = this.values.slice()
          , i = this.getValueSize()
          , r = this.getInterpolation() === Jd
          , s = e.length - 1;
        let o = 1;
        for (let a = 1; a < s; ++a) {
            let c = !1;
            const f = e[a]
              , h = e[a + 1];
            if (f !== h && (a !== 1 || f !== e[0]))
                if (r)
                    c = !0;
                else {
                    const d = a * i
                      , m = d - i
                      , v = d + i;
                    for (let _ = 0; _ !== i; ++_) {
                        const w = t[d + _];
                        if (w !== t[m + _] || w !== t[v + _]) {
                            c = !0;
                            break
                        }
                    }
                }
            if (c) {
                if (a !== o) {
                    e[o] = e[a];
                    const d = a * i
                      , m = o * i;
                    for (let v = 0; v !== i; ++v)
                        t[m + v] = t[d + v]
                }
                ++o
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for (let a = s * i, c = o * i, f = 0; f !== i; ++f)
                t[c + f] = t[a + f];
            ++o
        }
        return o !== e.length ? (this.times = e.slice(0, o),
        this.values = t.slice(0, o * i)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        const e = this.times.slice()
          , t = this.values.slice()
          , i = this.constructor
          , r = new i(this.name,e,t);
        return r.createInterpolant = this.createInterpolant,
        r
    }
}
br.prototype.TimeBufferType = Float32Array;
br.prototype.ValueBufferType = Float32Array;
br.prototype.DefaultInterpolation = jc;
class Ea extends br {
}
Ea.prototype.ValueTypeName = "bool";
Ea.prototype.ValueBufferType = Array;
Ea.prototype.DefaultInterpolation = Yc;
Ea.prototype.InterpolantFactoryMethodLinear = void 0;
Ea.prototype.InterpolantFactoryMethodSmooth = void 0;
class dx extends br {
}
dx.prototype.ValueTypeName = "color";
class of extends br {
}
of.prototype.ValueTypeName = "number";
class QC extends Tf {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , c = (i - t) / (r - t);
        let f = e * a;
        for (let h = f + a; f !== h; f += 4)
            En.slerpFlat(s, 0, o, f - a, o, f, c);
        return s
    }
}
class uu extends br {
    InterpolantFactoryMethodLinear(e) {
        return new QC(this.times,this.values,this.getValueSize(),e)
    }
}
uu.prototype.ValueTypeName = "quaternion";
uu.prototype.DefaultInterpolation = jc;
uu.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ta extends br {
}
Ta.prototype.ValueTypeName = "string";
Ta.prototype.ValueBufferType = Array;
Ta.prototype.DefaultInterpolation = Yc;
Ta.prototype.InterpolantFactoryMethodLinear = void 0;
Ta.prototype.InterpolantFactoryMethodSmooth = void 0;
class af extends br {
}
af.prototype.ValueTypeName = "vector";
class lf {
    constructor(e, t=-1, i, r=$p) {
        this.name = e,
        this.tracks = i,
        this.duration = t,
        this.blendMode = r,
        this.uuid = Hi(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = []
          , i = e.tracks
          , r = 1 / (e.fps || 1);
        for (let o = 0, a = i.length; o !== a; ++o)
            t.push(tk(i[o]).scale(r));
        const s = new this(e.name,e.duration,t,e.blendMode);
        return s.uuid = e.uuid,
        s
    }
    static toJSON(e) {
        const t = []
          , i = e.tracks
          , r = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let s = 0, o = i.length; s !== o; ++s)
            t.push(br.toJSON(i[s]));
        return r
    }
    static CreateFromMorphTargetSequence(e, t, i, r) {
        const s = t.length
          , o = [];
        for (let a = 0; a < s; a++) {
            let c = []
              , f = [];
            c.push((a + s - 1) % s, a, (a + 1) % s),
            f.push(0, 1, 0);
            const h = ZC(c);
            c = Py(c, 1, h),
            f = Py(f, 1, h),
            !r && c[0] === 0 && (c.push(s),
            f.push(f[0])),
            o.push(new of(".morphTargetInfluences[" + t[a].name + "]",c,f).scale(1 / i))
        }
        return new this(e,-1,o)
    }
    static findByName(e, t) {
        let i = e;
        if (!Array.isArray(e)) {
            const r = e;
            i = r.geometry && r.geometry.animations || r.animations
        }
        for (let r = 0; r < i.length; r++)
            if (i[r].name === t)
                return i[r];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, i) {
        const r = {}
          , s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, c = e.length; a < c; a++) {
            const f = e[a]
              , h = f.name.match(s);
            if (h && h.length > 1) {
                const d = h[1];
                let m = r[d];
                m || (r[d] = m = []),
                m.push(f)
            }
        }
        const o = [];
        for (const a in r)
            o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
        return o
    }
    static parseAnimation(e, t) {
        if (!e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const i = function(d, m, v, _, w) {
            if (v.length !== 0) {
                const x = []
                  , g = [];
                fx(v, x, g, _),
                x.length !== 0 && w.push(new d(m,x,g))
            }
        }
          , r = []
          , s = e.name || "default"
          , o = e.fps || 30
          , a = e.blendMode;
        let c = e.length || -1;
        const f = e.hierarchy || [];
        for (let d = 0; d < f.length; d++) {
            const m = f[d].keys;
            if (!(!m || m.length === 0))
                if (m[0].morphTargets) {
                    const v = {};
                    let _;
                    for (_ = 0; _ < m.length; _++)
                        if (m[_].morphTargets)
                            for (let w = 0; w < m[_].morphTargets.length; w++)
                                v[m[_].morphTargets[w]] = -1;
                    for (const w in v) {
                        const x = []
                          , g = [];
                        for (let S = 0; S !== m[_].morphTargets.length; ++S) {
                            const M = m[_];
                            x.push(M.time),
                            g.push(M.morphTarget === w ? 1 : 0)
                        }
                        r.push(new of(".morphTargetInfluence[" + w + "]",x,g))
                    }
                    c = v.length * o
                } else {
                    const v = ".bones[" + t[d].name + "]";
                    i(af, v + ".position", m, "pos", r),
                    i(uu, v + ".quaternion", m, "rot", r),
                    i(af, v + ".scale", m, "scl", r)
                }
        }
        return r.length === 0 ? null : new this(s,c,r,a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let i = 0, r = e.length; i !== r; ++i) {
            const s = this.tracks[i];
            t = Math.max(t, s.times[s.times.length - 1])
        }
        return this.duration = t,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function ek(n) {
    switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return of;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return af;
    case "color":
        return dx;
    case "quaternion":
        return uu;
    case "bool":
    case "boolean":
        return Ea;
    case "string":
        return Ta
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n)
}
function tk(n) {
    if (n.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = ek(n.type);
    if (n.times === void 0) {
        const t = []
          , i = [];
        fx(n.keys, t, i, "value"),
        n.times = t,
        n.values = i
    }
    return e.parse !== void 0 ? e.parse(n) : new e(n.name,n.times,n.values,n.interpolation)
}
const ys = {
    enabled: !1,
    files: {},
    add: function(n, e) {
        this.enabled !== !1 && (this.files[n] = e)
    },
    get: function(n) {
        if (this.enabled !== !1)
            return this.files[n]
    },
    remove: function(n) {
        delete this.files[n]
    },
    clear: function() {
        this.files = {}
    }
};
class px {
    constructor(e, t, i) {
        const r = this;
        let s = !1, o = 0, a = 0, c;
        const f = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = i,
        this.itemStart = function(h) {
            a++,
            s === !1 && r.onStart !== void 0 && r.onStart(h, o, a),
            s = !0
        }
        ,
        this.itemEnd = function(h) {
            o++,
            r.onProgress !== void 0 && r.onProgress(h, o, a),
            o === a && (s = !1,
            r.onLoad !== void 0 && r.onLoad())
        }
        ,
        this.itemError = function(h) {
            r.onError !== void 0 && r.onError(h)
        }
        ,
        this.resolveURL = function(h) {
            return c ? c(h) : h
        }
        ,
        this.setURLModifier = function(h) {
            return c = h,
            this
        }
        ,
        this.addHandler = function(h, d) {
            return f.push(h, d),
            this
        }
        ,
        this.removeHandler = function(h) {
            const d = f.indexOf(h);
            return d !== -1 && f.splice(d, 2),
            this
        }
        ,
        this.getHandler = function(h) {
            for (let d = 0, m = f.length; d < m; d += 2) {
                const v = f[d]
                  , _ = f[d + 1];
                if (v.global && (v.lastIndex = 0),
                v.test(h))
                    return _
            }
            return null
        }
    }
}
const $C = new px;
class vi {
    constructor(e) {
        this.manager = e !== void 0 ? e : $C,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const i = this;
        return new Promise(function(r, s) {
            i.load(e, r, t, s)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
vi.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const us = {};
class nk extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class Jr extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = ys.get(e);
        if (s !== void 0)
            return this.manager.itemStart(e),
            setTimeout(()=>{
                t && t(s),
                this.manager.itemEnd(e)
            }
            , 0),
            s;
        if (us[e] !== void 0) {
            us[e].push({
                onLoad: t,
                onProgress: i,
                onError: r
            });
            return
        }
        us[e] = [],
        us[e].push({
            onLoad: t,
            onProgress: i,
            onError: r
        });
        const o = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , a = this.mimeType
          , c = this.responseType;
        fetch(o).then(f=>{
            if (f.status === 200 || f.status === 0) {
                if (f.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || f.body === void 0 || f.body.getReader === void 0)
                    return f;
                const h = us[e]
                  , d = f.body.getReader()
                  , m = f.headers.get("Content-Length") || f.headers.get("X-File-Size")
                  , v = m ? parseInt(m) : 0
                  , _ = v !== 0;
                let w = 0;
                const x = new ReadableStream({
                    start(g) {
                        S();
                        function S() {
                            d.read().then(({done: M, value: T})=>{
                                if (M)
                                    g.close();
                                else {
                                    w += T.byteLength;
                                    const P = new ProgressEvent("progress",{
                                        lengthComputable: _,
                                        loaded: w,
                                        total: v
                                    });
                                    for (let R = 0, b = h.length; R < b; R++) {
                                        const N = h[R];
                                        N.onProgress && N.onProgress(P)
                                    }
                                    g.enqueue(T),
                                    S()
                                }
                            }
                            )
                        }
                    }
                });
                return new Response(x)
            } else
                throw new nk(`fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`,f)
        }
        ).then(f=>{
            switch (c) {
            case "arraybuffer":
                return f.arrayBuffer();
            case "blob":
                return f.blob();
            case "document":
                return f.text().then(h=>new DOMParser().parseFromString(h, a));
            case "json":
                return f.json();
            default:
                if (a === void 0)
                    return f.text();
                {
                    const d = /charset="?([^;"\s]*)"?/i.exec(a)
                      , m = d && d[1] ? d[1].toLowerCase() : void 0
                      , v = new TextDecoder(m);
                    return f.arrayBuffer().then(_=>v.decode(_))
                }
            }
        }
        ).then(f=>{
            ys.add(e, f);
            const h = us[e];
            delete us[e];
            for (let d = 0, m = h.length; d < m; d++) {
                const v = h[d];
                v.onLoad && v.onLoad(f)
            }
        }
        ).catch(f=>{
            const h = us[e];
            if (h === void 0)
                throw this.manager.itemError(e),
                f;
            delete us[e];
            for (let d = 0, m = h.length; d < m; d++) {
                const v = h[d];
                v.onError && v.onError(f)
            }
            this.manager.itemError(e)
        }
        ).finally(()=>{
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class ik extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new Jr(this.manager);
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (c) {
                r ? r(c) : console.error(c),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
            const r = lf.parse(e[i]);
            t.push(r)
        }
        return t
    }
}
class rk extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = []
          , a = new lm
          , c = new Jr(this.manager);
        c.setPath(this.path),
        c.setResponseType("arraybuffer"),
        c.setRequestHeader(this.requestHeader),
        c.setWithCredentials(s.withCredentials);
        let f = 0;
        function h(d) {
            c.load(e[d], function(m) {
                const v = s.parse(m, !0);
                o[d] = {
                    width: v.width,
                    height: v.height,
                    format: v.format,
                    mipmaps: v.mipmaps
                },
                f += 1,
                f === 6 && (v.mipmapCount === 1 && (a.minFilter = Wt),
                a.image = o,
                a.format = v.format,
                a.needsUpdate = !0,
                t && t(a))
            }, i, r)
        }
        if (Array.isArray(e))
            for (let d = 0, m = e.length; d < m; ++d)
                h(d);
        else
            c.load(e, function(d) {
                const m = s.parse(d, !0);
                if (m.isCubemap) {
                    const v = m.mipmaps.length / m.mipmapCount;
                    for (let _ = 0; _ < v; _++) {
                        o[_] = {
                            mipmaps: []
                        };
                        for (let w = 0; w < m.mipmapCount; w++)
                            o[_].mipmaps.push(m.mipmaps[_ * m.mipmapCount + w]),
                            o[_].format = m.format,
                            o[_].width = m.width,
                            o[_].height = m.height
                    }
                    a.image = o
                } else
                    a.image.width = m.width,
                    a.image.height = m.height,
                    a.mipmaps = m.mipmaps;
                m.mipmapCount === 1 && (a.minFilter = Wt),
                a.format = m.format,
                a.needsUpdate = !0,
                t && t(a)
            }, i, r);
        return a
    }
}
class uf extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = ys.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = ef("img");
        function c() {
            h(),
            ys.add(e, this),
            t && t(this),
            s.manager.itemEnd(e)
        }
        function f(d) {
            h(),
            r && r(d),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
        function h() {
            a.removeEventListener("load", c, !1),
            a.removeEventListener("error", f, !1)
        }
        return a.addEventListener("load", c, !1),
        a.addEventListener("error", f, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        a.src = e,
        a
    }
}
class sk extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new yf;
        s.colorSpace = Fi;
        const o = new uf(this.manager);
        o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path);
        let a = 0;
        function c(f) {
            o.load(e[f], function(h) {
                s.images[f] = h,
                a++,
                a === 6 && (s.needsUpdate = !0,
                t && t(s))
            }, void 0, r)
        }
        for (let f = 0; f < e.length; ++f)
            c(f);
        return s
    }
}
class ok extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new fo
          , a = new Jr(this.manager);
        return a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader),
        a.setPath(this.path),
        a.setWithCredentials(s.withCredentials),
        a.load(e, function(c) {
            let f;
            try {
                f = s.parse(c)
            } catch (h) {
                if (r !== void 0)
                    r(h);
                else {
                    console.error(h);
                    return
                }
            }
            f.image !== void 0 ? o.image = f.image : f.data !== void 0 && (o.image.width = f.width,
            o.image.height = f.height,
            o.image.data = f.data),
            o.wrapS = f.wrapS !== void 0 ? f.wrapS : ei,
            o.wrapT = f.wrapT !== void 0 ? f.wrapT : ei,
            o.magFilter = f.magFilter !== void 0 ? f.magFilter : Wt,
            o.minFilter = f.minFilter !== void 0 ? f.minFilter : Wt,
            o.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1,
            f.colorSpace !== void 0 && (o.colorSpace = f.colorSpace),
            f.flipY !== void 0 && (o.flipY = f.flipY),
            f.format !== void 0 && (o.format = f.format),
            f.type !== void 0 && (o.type = f.type),
            f.mipmaps !== void 0 && (o.mipmaps = f.mipmaps,
            o.minFilter = Gr),
            f.mipmapCount === 1 && (o.minFilter = Wt),
            f.generateMipmaps !== void 0 && (o.generateMipmaps = f.generateMipmaps),
            o.needsUpdate = !0,
            t && t(o, f)
        }, i, r),
        o
    }
}
class ak extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new en
          , o = new uf(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(a) {
            s.image = a,
            s.needsUpdate = !0,
            t !== void 0 && t(s)
        }, i, r),
        s
    }
}
class wo extends bt {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new Ne(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        t
    }
}
class eR extends wo {
    constructor(e, t, i) {
        super(e, i),
        this.isHemisphereLight = !0,
        this.type = "HemisphereLight",
        this.position.copy(bt.DEFAULT_UP),
        this.updateMatrix(),
        this.groundColor = new Ne(t)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.groundColor.copy(e.groundColor),
        this
    }
}
const F0 = new $e
  , Aw = new U
  , Cw = new U;
class mx {
    constructor(e) {
        this.camera = e,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new he(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new $e,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new _f,
        this._frameExtents = new he(1,1),
        this._viewportCount = 1,
        this._viewports = [new Ct(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , i = this.matrix;
        Aw.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(Aw),
        Cw.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(Cw),
        t.updateMatrixWorld(),
        F0.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(F0),
        i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        i.multiply(F0)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class lk extends mx {
    constructor() {
        super(new Dn(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera
          , i = Jl * 2 * e.angle * this.focus
          , r = this.mapSize.width / this.mapSize.height
          , s = e.distance || t.far;
        (i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i,
        t.aspect = r,
        t.far = s,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class tR extends wo {
    constructor(e, t, i=0, r=Math.PI / 3, s=0, o=2) {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(bt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new bt,
        this.distance = i,
        this.angle = r,
        this.penumbra = s,
        this.decay = o,
        this.map = null,
        this.shadow = new lk
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const Rw = new $e
  , Zu = new U
  , k0 = new U;
class uk extends mx {
    constructor() {
        super(new Dn(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new he(4,2),
        this._viewportCount = 6,
        this._viewports = [new Ct(2,1,1,1), new Ct(0,1,1,1), new Ct(3,1,1,1), new Ct(1,1,1,1), new Ct(3,0,1,1), new Ct(1,0,1,1)],
        this._cubeDirections = [new U(1,0,0), new U(-1,0,0), new U(0,0,1), new U(0,0,-1), new U(0,1,0), new U(0,-1,0)],
        this._cubeUps = [new U(0,1,0), new U(0,1,0), new U(0,1,0), new U(0,1,0), new U(0,0,1), new U(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        const i = this.camera
          , r = this.matrix
          , s = e.distance || i.far;
        s !== i.far && (i.far = s,
        i.updateProjectionMatrix()),
        Zu.setFromMatrixPosition(e.matrixWorld),
        i.position.copy(Zu),
        k0.copy(i.position),
        k0.add(this._cubeDirections[t]),
        i.up.copy(this._cubeUps[t]),
        i.lookAt(k0),
        i.updateMatrixWorld(),
        r.makeTranslation(-Zu.x, -Zu.y, -Zu.z),
        Rw.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Rw)
    }
}
class nR extends wo {
    constructor(e, t, i=0, r=2) {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = i,
        this.decay = r,
        this.shadow = new uk
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class ck extends mx {
    constructor() {
        super(new xf(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class iR extends wo {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(bt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new bt,
        this.shadow = new ck
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class rR extends wo {
    constructor(e, t) {
        super(e, t),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
class sR extends wo {
    constructor(e, t, i=10, r=10) {
        super(e, t),
        this.isRectAreaLight = !0,
        this.type = "RectAreaLight",
        this.width = i,
        this.height = r
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI)
    }
    copy(e) {
        return super.copy(e),
        this.width = e.width,
        this.height = e.height,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.width = this.width,
        t.object.height = this.height,
        t
    }
}
class oR {
    constructor() {
        this.isSphericalHarmonics3 = !0,
        this.coefficients = [];
        for (let e = 0; e < 9; e++)
            this.coefficients.push(new U)
    }
    set(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].copy(e[t]);
        return this
    }
    zero() {
        for (let e = 0; e < 9; e++)
            this.coefficients[e].set(0, 0, 0);
        return this
    }
    getAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.282095),
        t.addScaledVector(o[1], .488603 * r),
        t.addScaledVector(o[2], .488603 * s),
        t.addScaledVector(o[3], .488603 * i),
        t.addScaledVector(o[4], 1.092548 * (i * r)),
        t.addScaledVector(o[5], 1.092548 * (r * s)),
        t.addScaledVector(o[6], .315392 * (3 * s * s - 1)),
        t.addScaledVector(o[7], 1.092548 * (i * s)),
        t.addScaledVector(o[8], .546274 * (i * i - r * r)),
        t
    }
    getIrradianceAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.886227),
        t.addScaledVector(o[1], 2 * .511664 * r),
        t.addScaledVector(o[2], 2 * .511664 * s),
        t.addScaledVector(o[3], 2 * .511664 * i),
        t.addScaledVector(o[4], 2 * .429043 * i * r),
        t.addScaledVector(o[5], 2 * .429043 * r * s),
        t.addScaledVector(o[6], .743125 * s * s - .247708),
        t.addScaledVector(o[7], 2 * .429043 * i * s),
        t.addScaledVector(o[8], .429043 * (i * i - r * r)),
        t
    }
    add(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
        return this
    }
    addScaledSH(e, t) {
        for (let i = 0; i < 9; i++)
            this.coefficients[i].addScaledVector(e.coefficients[i], t);
        return this
    }
    scale(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].multiplyScalar(e);
        return this
    }
    lerp(e, t) {
        for (let i = 0; i < 9; i++)
            this.coefficients[i].lerp(e.coefficients[i], t);
        return this
    }
    equals(e) {
        for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t]))
                return !1;
        return !0
    }
    copy(e) {
        return this.set(e.coefficients)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    fromArray(e, t=0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++)
            i[r].fromArray(e, t + r * 3);
        return this
    }
    toArray(e=[], t=0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++)
            i[r].toArray(e, t + r * 3);
        return e
    }
    static getBasisAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z;
        t[0] = .282095,
        t[1] = .488603 * r,
        t[2] = .488603 * s,
        t[3] = .488603 * i,
        t[4] = 1.092548 * i * r,
        t[5] = 1.092548 * r * s,
        t[6] = .315392 * (3 * s * s - 1),
        t[7] = 1.092548 * i * s,
        t[8] = .546274 * (i * i - r * r)
    }
}
class aR extends wo {
    constructor(e=new oR, t=1) {
        super(void 0, t),
        this.isLightProbe = !0,
        this.sh = e
    }
    copy(e) {
        return super.copy(e),
        this.sh.copy(e.sh),
        this
    }
    fromJSON(e) {
        return this.intensity = e.intensity,
        this.sh.fromArray(e.sh),
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.sh = this.sh.toArray(),
        t
    }
}
class Mm extends vi {
    constructor(e) {
        super(e),
        this.textures = {}
    }
    load(e, t, i, r) {
        const s = this
          , o = new Jr(s.manager);
        o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (c) {
                r ? r(c) : console.error(c),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = this.textures;
        function i(s) {
            return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s),
            t[s]
        }
        const r = Mm.createMaterialFromType(e.type);
        if (e.uuid !== void 0 && (r.uuid = e.uuid),
        e.name !== void 0 && (r.name = e.name),
        e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
        e.roughness !== void 0 && (r.roughness = e.roughness),
        e.metalness !== void 0 && (r.metalness = e.metalness),
        e.sheen !== void 0 && (r.sheen = e.sheen),
        e.sheenColor !== void 0 && (r.sheenColor = new Ne().setHex(e.sheenColor)),
        e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
        e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive),
        e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular),
        e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity),
        e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor),
        e.shininess !== void 0 && (r.shininess = e.shininess),
        e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
        e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness),
        e.iridescence !== void 0 && (r.iridescence = e.iridescence),
        e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
        e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
        e.transmission !== void 0 && (r.transmission = e.transmission),
        e.thickness !== void 0 && (r.thickness = e.thickness),
        e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance),
        e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor),
        e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy),
        e.anisotropyRotation !== void 0 && (r.anisotropyRotation = e.anisotropyRotation),
        e.fog !== void 0 && (r.fog = e.fog),
        e.flatShading !== void 0 && (r.flatShading = e.flatShading),
        e.blending !== void 0 && (r.blending = e.blending),
        e.combine !== void 0 && (r.combine = e.combine),
        e.side !== void 0 && (r.side = e.side),
        e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
        e.opacity !== void 0 && (r.opacity = e.opacity),
        e.transparent !== void 0 && (r.transparent = e.transparent),
        e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
        e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash),
        e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc),
        e.depthTest !== void 0 && (r.depthTest = e.depthTest),
        e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
        e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
        e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc),
        e.blendDst !== void 0 && (r.blendDst = e.blendDst),
        e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation),
        e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha),
        e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha),
        e.blendEquationAlpha !== void 0 && (r.blendEquationAlpha = e.blendEquationAlpha),
        e.blendColor !== void 0 && r.blendColor !== void 0 && r.blendColor.setHex(e.blendColor),
        e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha),
        e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask),
        e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
        e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
        e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
        e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
        e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
        e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
        e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
        e.wireframe !== void 0 && (r.wireframe = e.wireframe),
        e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth),
        e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap),
        e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin),
        e.rotation !== void 0 && (r.rotation = e.rotation),
        e.linewidth !== void 0 && (r.linewidth = e.linewidth),
        e.dashSize !== void 0 && (r.dashSize = e.dashSize),
        e.gapSize !== void 0 && (r.gapSize = e.gapSize),
        e.scale !== void 0 && (r.scale = e.scale),
        e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
        e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor),
        e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits),
        e.dithering !== void 0 && (r.dithering = e.dithering),
        e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
        e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha),
        e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
        e.visible !== void 0 && (r.visible = e.visible),
        e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
        e.userData !== void 0 && (r.userData = e.userData),
        e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors),
        e.uniforms !== void 0)
            for (const s in e.uniforms) {
                const o = e.uniforms[s];
                switch (r.uniforms[s] = {},
                o.type) {
                case "t":
                    r.uniforms[s].value = i(o.value);
                    break;
                case "c":
                    r.uniforms[s].value = new Ne().setHex(o.value);
                    break;
                case "v2":
                    r.uniforms[s].value = new he().fromArray(o.value);
                    break;
                case "v3":
                    r.uniforms[s].value = new U().fromArray(o.value);
                    break;
                case "v4":
                    r.uniforms[s].value = new Ct().fromArray(o.value);
                    break;
                case "m3":
                    r.uniforms[s].value = new mt().fromArray(o.value);
                    break;
                case "m4":
                    r.uniforms[s].value = new $e().fromArray(o.value);
                    break;
                default:
                    r.uniforms[s].value = o.value
                }
            }
        if (e.defines !== void 0 && (r.defines = e.defines),
        e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
        e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
        e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
        e.extensions !== void 0)
            for (const s in e.extensions)
                r.extensions[s] = e.extensions[s];
        if (e.lights !== void 0 && (r.lights = e.lights),
        e.clipping !== void 0 && (r.clipping = e.clipping),
        e.size !== void 0 && (r.size = e.size),
        e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
        e.map !== void 0 && (r.map = i(e.map)),
        e.matcap !== void 0 && (r.matcap = i(e.matcap)),
        e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
        e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
        e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
        e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
        e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
        e.normalScale !== void 0) {
            let s = e.normalScale;
            Array.isArray(s) === !1 && (s = [s, s]),
            r.normalScale = new he().fromArray(s)
        }
        return e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)),
        e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale),
        e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias),
        e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
        e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
        e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
        e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity),
        e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
        e.specularIntensityMap !== void 0 && (r.specularIntensityMap = i(e.specularIntensityMap)),
        e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)),
        e.envMap !== void 0 && (r.envMap = i(e.envMap)),
        e.envMapRotation !== void 0 && r.envMapRotation.fromArray(e.envMapRotation),
        e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
        e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
        e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
        e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
        e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity),
        e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
        e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
        e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
        e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
        e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
        e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
        e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new he().fromArray(e.clearcoatNormalScale)),
        e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)),
        e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
        e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)),
        e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
        e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)),
        e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
        e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
        r
    }
    setTextures(e) {
        return this.textures = e,
        this
    }
    static createMaterialFromType(e) {
        const t = {
            ShadowMaterial: BC,
            SpriteMaterial: ex,
            RawShaderMaterial: HC,
            ShaderMaterial: fr,
            PointsMaterial: nx,
            MeshPhysicalMaterial: cx,
            MeshStandardMaterial: ux,
            MeshPhongMaterial: VC,
            MeshToonMaterial: GC,
            MeshNormalMaterial: WC,
            MeshLambertMaterial: XC,
            MeshDepthMaterial: K_,
            MeshDistanceMaterial: Q_,
            MeshBasicMaterial: So,
            MeshMatcapMaterial: YC,
            LineDashedMaterial: jC,
            LineBasicMaterial: gi,
            Material: Gn
        };
        return new t[e]
    }
}
class Ly {
    static decodeText(e) {
        if (typeof TextDecoder < "u")
            return new TextDecoder().decode(e);
        let t = "";
        for (let i = 0, r = e.length; i < r; i++)
            t += String.fromCharCode(e[i]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class lR extends _t {
    constructor() {
        super(),
        this.isInstancedBufferGeometry = !0,
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e),
        this.instanceCount = e.instanceCount,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount,
        e.isInstancedBufferGeometry = !0,
        e
    }
}
class uR extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new Jr(s.manager);
        o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (c) {
                r ? r(c) : console.error(c),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = {}
          , i = {};
        function r(v, _) {
            if (t[_] !== void 0)
                return t[_];
            const x = v.interleavedBuffers[_]
              , g = s(v, x.buffer)
              , S = bl(x.type, g)
              , M = new om(S,x.stride);
            return M.uuid = x.uuid,
            t[_] = M,
            M
        }
        function s(v, _) {
            if (i[_] !== void 0)
                return i[_];
            const x = v.arrayBuffers[_]
              , g = new Uint32Array(x).buffer;
            return i[_] = g,
            g
        }
        const o = e.isInstancedBufferGeometry ? new lR : new _t
          , a = e.data.index;
        if (a !== void 0) {
            const v = bl(a.type, a.array);
            o.setIndex(new Nt(v,1))
        }
        const c = e.data.attributes;
        for (const v in c) {
            const _ = c[v];
            let w;
            if (_.isInterleavedBufferAttribute) {
                const x = r(e.data, _.data);
                w = new _a(x,_.itemSize,_.offset,_.normalized)
            } else {
                const x = bl(_.type, _.array)
                  , g = _.isInstancedBufferAttribute ? Ql : Nt;
                w = new g(x,_.itemSize,_.normalized)
            }
            _.name !== void 0 && (w.name = _.name),
            _.usage !== void 0 && w.setUsage(_.usage),
            o.setAttribute(v, w)
        }
        const f = e.data.morphAttributes;
        if (f)
            for (const v in f) {
                const _ = f[v]
                  , w = [];
                for (let x = 0, g = _.length; x < g; x++) {
                    const S = _[x];
                    let M;
                    if (S.isInterleavedBufferAttribute) {
                        const T = r(e.data, S.data);
                        M = new _a(T,S.itemSize,S.offset,S.normalized)
                    } else {
                        const T = bl(S.type, S.array);
                        M = new Nt(T,S.itemSize,S.normalized)
                    }
                    S.name !== void 0 && (M.name = S.name),
                    w.push(M)
                }
                o.morphAttributes[v] = w
            }
        e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
        const d = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (d !== void 0)
            for (let v = 0, _ = d.length; v !== _; ++v) {
                const w = d[v];
                o.addGroup(w.start, w.count, w.materialIndex)
            }
        const m = e.data.boundingSphere;
        if (m !== void 0) {
            const v = new U;
            m.center !== void 0 && v.fromArray(m.center),
            o.boundingSphere = new ni(v,m.radius)
        }
        return e.name && (o.name = e.name),
        e.userData && (o.userData = e.userData),
        o
    }
}
class fk extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = this.path === "" ? Ly.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || o;
        const a = new Jr(this.manager);
        a.setPath(this.path),
        a.setRequestHeader(this.requestHeader),
        a.setWithCredentials(this.withCredentials),
        a.load(e, function(c) {
            let f = null;
            try {
                f = JSON.parse(c)
            } catch (d) {
                r !== void 0 && r(d),
                console.error("THREE:ObjectLoader: Can't parse " + e + ".", d.message);
                return
            }
            const h = f.metadata;
            if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") {
                r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)),
                console.error("THREE.ObjectLoader: Can't load " + e);
                return
            }
            s.parse(f, t)
        }, i, r)
    }
    async loadAsync(e, t) {
        const i = this
          , r = this.path === "" ? Ly.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || r;
        const s = new Jr(this.manager);
        s.setPath(this.path),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials);
        const o = await s.loadAsync(e, t)
          , a = JSON.parse(o)
          , c = a.metadata;
        if (c === void 0 || c.type === void 0 || c.type.toLowerCase() === "geometry")
            throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await i.parseAsync(a)
    }
    parse(e, t) {
        const i = this.parseAnimations(e.animations)
          , r = this.parseShapes(e.shapes)
          , s = this.parseGeometries(e.geometries, r)
          , o = this.parseImages(e.images, function() {
            t !== void 0 && t(f)
        })
          , a = this.parseTextures(e.textures, o)
          , c = this.parseMaterials(e.materials, a)
          , f = this.parseObject(e.object, s, c, a, i)
          , h = this.parseSkeletons(e.skeletons, f);
        if (this.bindSkeletons(f, h),
        t !== void 0) {
            let d = !1;
            for (const m in o)
                if (o[m].data instanceof HTMLImageElement) {
                    d = !0;
                    break
                }
            d === !1 && t(f)
        }
        return f
    }
    async parseAsync(e) {
        const t = this.parseAnimations(e.animations)
          , i = this.parseShapes(e.shapes)
          , r = this.parseGeometries(e.geometries, i)
          , s = await this.parseImagesAsync(e.images)
          , o = this.parseTextures(e.textures, s)
          , a = this.parseMaterials(e.materials, o)
          , c = this.parseObject(e.object, r, a, o, t)
          , f = this.parseSkeletons(e.skeletons, c);
        return this.bindSkeletons(c, f),
        c
    }
    parseShapes(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0, r = e.length; i < r; i++) {
                const s = new fa().fromJSON(e[i]);
                t[s.uuid] = s
            }
        return t
    }
    parseSkeletons(e, t) {
        const i = {}
          , r = {};
        if (t.traverse(function(s) {
            s.isBone && (r[s.uuid] = s)
        }),
        e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = new am().fromJSON(e[s], r);
                i[a.uuid] = a
            }
        return i
    }
    parseGeometries(e, t) {
        const i = {};
        if (e !== void 0) {
            const r = new uR;
            for (let s = 0, o = e.length; s < o; s++) {
                let a;
                const c = e[s];
                switch (c.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                    a = r.parse(c);
                    break;
                default:
                    c.type in Tw ? a = Tw[c.type].fromJSON(c, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${c.type}"`)
                }
                a.uuid = c.uuid,
                c.name !== void 0 && (a.name = c.name),
                c.userData !== void 0 && (a.userData = c.userData),
                i[c.uuid] = a
            }
        }
        return i
    }
    parseMaterials(e, t) {
        const i = {}
          , r = {};
        if (e !== void 0) {
            const s = new Mm;
            s.setTextures(t);
            for (let o = 0, a = e.length; o < a; o++) {
                const c = e[o];
                i[c.uuid] === void 0 && (i[c.uuid] = s.parse(c)),
                r[c.uuid] = i[c.uuid]
            }
        }
        return r
    }
    parseAnimations(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0; i < e.length; i++) {
                const r = e[i]
                  , s = lf.parse(r);
                t[s.uuid] = s
            }
        return t
    }
    parseImages(e, t) {
        const i = this
          , r = {};
        let s;
        function o(c) {
            return i.manager.itemStart(c),
            s.load(c, function() {
                i.manager.itemEnd(c)
            }, void 0, function() {
                i.manager.itemError(c),
                i.manager.itemEnd(c)
            })
        }
        function a(c) {
            if (typeof c == "string") {
                const f = c
                  , h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : i.resourcePath + f;
                return o(h)
            } else
                return c.data ? {
                    data: bl(c.type, c.data),
                    width: c.width,
                    height: c.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            const c = new px(t);
            s = new uf(c),
            s.setCrossOrigin(this.crossOrigin);
            for (let f = 0, h = e.length; f < h; f++) {
                const d = e[f]
                  , m = d.url;
                if (Array.isArray(m)) {
                    const v = [];
                    for (let _ = 0, w = m.length; _ < w; _++) {
                        const x = m[_]
                          , g = a(x);
                        g !== null && (g instanceof HTMLImageElement ? v.push(g) : v.push(new fo(g.data,g.width,g.height)))
                    }
                    r[d.uuid] = new ia(v)
                } else {
                    const v = a(d.url);
                    r[d.uuid] = new ia(v)
                }
            }
        }
        return r
    }
    async parseImagesAsync(e) {
        const t = this
          , i = {};
        let r;
        async function s(o) {
            if (typeof o == "string") {
                const a = o
                  , c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
                return await r.loadAsync(c)
            } else
                return o.data ? {
                    data: bl(o.type, o.data),
                    width: o.width,
                    height: o.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            r = new uf(this.manager),
            r.setCrossOrigin(this.crossOrigin);
            for (let o = 0, a = e.length; o < a; o++) {
                const c = e[o]
                  , f = c.url;
                if (Array.isArray(f)) {
                    const h = [];
                    for (let d = 0, m = f.length; d < m; d++) {
                        const v = f[d]
                          , _ = await s(v);
                        _ !== null && (_ instanceof HTMLImageElement ? h.push(_) : h.push(new fo(_.data,_.width,_.height)))
                    }
                    i[c.uuid] = new ia(h)
                } else {
                    const h = await s(c.url);
                    i[c.uuid] = new ia(h)
                }
            }
        }
        return i
    }
    parseTextures(e, t) {
        function i(s, o) {
            return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s),
            o[s])
        }
        const r = {};
        if (e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = e[s];
                a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
                t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                const c = t[a.image]
                  , f = c.data;
                let h;
                Array.isArray(f) ? (h = new yf,
                f.length === 6 && (h.needsUpdate = !0)) : (f && f.data ? h = new fo : h = new en,
                f && (h.needsUpdate = !0)),
                h.source = c,
                h.uuid = a.uuid,
                a.name !== void 0 && (h.name = a.name),
                a.mapping !== void 0 && (h.mapping = i(a.mapping, hk)),
                a.channel !== void 0 && (h.channel = a.channel),
                a.offset !== void 0 && h.offset.fromArray(a.offset),
                a.repeat !== void 0 && h.repeat.fromArray(a.repeat),
                a.center !== void 0 && h.center.fromArray(a.center),
                a.rotation !== void 0 && (h.rotation = a.rotation),
                a.wrap !== void 0 && (h.wrapS = i(a.wrap[0], bw),
                h.wrapT = i(a.wrap[1], bw)),
                a.format !== void 0 && (h.format = a.format),
                a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat),
                a.type !== void 0 && (h.type = a.type),
                a.colorSpace !== void 0 && (h.colorSpace = a.colorSpace),
                a.minFilter !== void 0 && (h.minFilter = i(a.minFilter, Pw)),
                a.magFilter !== void 0 && (h.magFilter = i(a.magFilter, Pw)),
                a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy),
                a.flipY !== void 0 && (h.flipY = a.flipY),
                a.generateMipmaps !== void 0 && (h.generateMipmaps = a.generateMipmaps),
                a.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = a.premultiplyAlpha),
                a.unpackAlignment !== void 0 && (h.unpackAlignment = a.unpackAlignment),
                a.compareFunction !== void 0 && (h.compareFunction = a.compareFunction),
                a.userData !== void 0 && (h.userData = a.userData),
                r[a.uuid] = h
            }
        return r
    }
    parseObject(e, t, i, r, s) {
        let o;
        function a(m) {
            return t[m] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", m),
            t[m]
        }
        function c(m) {
            if (m !== void 0) {
                if (Array.isArray(m)) {
                    const v = [];
                    for (let _ = 0, w = m.length; _ < w; _++) {
                        const x = m[_];
                        i[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", x),
                        v.push(i[x])
                    }
                    return v
                }
                return i[m] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", m),
                i[m]
            }
        }
        function f(m) {
            return r[m] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", m),
            r[m]
        }
        let h, d;
        switch (e.type) {
        case "Scene":
            o = new Rp,
            e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new Ne(e.background) : o.background = f(e.background)),
            e.environment !== void 0 && (o.environment = f(e.environment)),
            e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new sm(e.fog.color,e.fog.near,e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new rm(e.fog.color,e.fog.density)),
            e.fog.name !== "" && (o.fog.name = e.fog.name)),
            e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness),
            e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity),
            e.backgroundRotation !== void 0 && o.backgroundRotation.fromArray(e.backgroundRotation),
            e.environmentRotation !== void 0 && o.environmentRotation.fromArray(e.environmentRotation);
            break;
        case "PerspectiveCamera":
            o = new Dn(e.fov,e.aspect,e.near,e.far),
            e.focus !== void 0 && (o.focus = e.focus),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
            e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "OrthographicCamera":
            o = new xf(e.left,e.right,e.top,e.bottom,e.near,e.far),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "AmbientLight":
            o = new rR(e.color,e.intensity);
            break;
        case "DirectionalLight":
            o = new iR(e.color,e.intensity);
            break;
        case "PointLight":
            o = new nR(e.color,e.intensity,e.distance,e.decay);
            break;
        case "RectAreaLight":
            o = new sR(e.color,e.intensity,e.width,e.height);
            break;
        case "SpotLight":
            o = new tR(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);
            break;
        case "HemisphereLight":
            o = new eR(e.color,e.groundColor,e.intensity);
            break;
        case "LightProbe":
            o = new aR().fromJSON(e);
            break;
        case "SkinnedMesh":
            h = a(e.geometry),
            d = c(e.material),
            o = new TC(h,d),
            e.bindMode !== void 0 && (o.bindMode = e.bindMode),
            e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
            e.skeleton !== void 0 && (o.skeleton = e.skeleton);
            break;
        case "Mesh":
            h = a(e.geometry),
            d = c(e.material),
            o = new _n(h,d);
            break;
        case "InstancedMesh":
            h = a(e.geometry),
            d = c(e.material);
            const m = e.count
              , v = e.instanceMatrix
              , _ = e.instanceColor;
            o = new AC(h,d,m),
            o.instanceMatrix = new Ql(new Float32Array(v.array),16),
            _ !== void 0 && (o.instanceColor = new Ql(new Float32Array(_.array),_.itemSize));
            break;
        case "BatchedMesh":
            h = a(e.geometry),
            d = c(e.material),
            o = new CC(e.maxGeometryCount,e.maxVertexCount,e.maxIndexCount,d),
            o.geometry = h,
            o.perObjectFrustumCulled = e.perObjectFrustumCulled,
            o.sortObjects = e.sortObjects,
            o._drawRanges = e.drawRanges,
            o._reservedRanges = e.reservedRanges,
            o._visibility = e.visibility,
            o._active = e.active,
            o._bounds = e.bounds.map(w=>{
                const x = new di;
                x.min.fromArray(w.boxMin),
                x.max.fromArray(w.boxMax);
                const g = new ni;
                return g.radius = w.sphereRadius,
                g.center.fromArray(w.sphereCenter),
                {
                    boxInitialized: w.boxInitialized,
                    box: x,
                    sphereInitialized: w.sphereInitialized,
                    sphere: g
                }
            }
            ),
            o._maxGeometryCount = e.maxGeometryCount,
            o._maxVertexCount = e.maxVertexCount,
            o._maxIndexCount = e.maxIndexCount,
            o._geometryInitialized = e.geometryInitialized,
            o._geometryCount = e.geometryCount,
            o._matricesTexture = f(e.matricesTexture.uuid);
            break;
        case "LOD":
            o = new EC;
            break;
        case "Line":
            o = new go(a(e.geometry),c(e.material));
            break;
        case "LineLoop":
            o = new RC(a(e.geometry),c(e.material));
            break;
        case "LineSegments":
            o = new Kr(a(e.geometry),c(e.material));
            break;
        case "PointCloud":
        case "Points":
            o = new bC(a(e.geometry),c(e.material));
            break;
        case "Sprite":
            o = new wC(c(e.material));
            break;
        case "Group":
            o = new Il;
            break;
        case "Bone":
            o = new tx;
            break;
        default:
            o = new bt
        }
        if (o.uuid = e.uuid,
        e.name !== void 0 && (o.name = e.name),
        e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix),
        e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate),
        o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position),
        e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
        e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
        e.scale !== void 0 && o.scale.fromArray(e.scale)),
        e.up !== void 0 && o.up.fromArray(e.up),
        e.castShadow !== void 0 && (o.castShadow = e.castShadow),
        e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
        e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))),
        e.visible !== void 0 && (o.visible = e.visible),
        e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
        e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
        e.userData !== void 0 && (o.userData = e.userData),
        e.layers !== void 0 && (o.layers.mask = e.layers),
        e.children !== void 0) {
            const m = e.children;
            for (let v = 0; v < m.length; v++)
                o.add(this.parseObject(m[v], t, i, r, s))
        }
        if (e.animations !== void 0) {
            const m = e.animations;
            for (let v = 0; v < m.length; v++) {
                const _ = m[v];
                o.animations.push(s[_])
            }
        }
        if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
            const m = e.levels;
            for (let v = 0; v < m.length; v++) {
                const _ = m[v]
                  , w = o.getObjectByProperty("uuid", _.object);
                w !== void 0 && o.addLevel(w, _.distance, _.hysteresis)
            }
        }
        return o
    }
    bindSkeletons(e, t) {
        Object.keys(t).length !== 0 && e.traverse(function(i) {
            if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
                const r = t[i.skeleton];
                r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(r, i.bindMatrix)
            }
        })
    }
}
const hk = {
    UVMapping: Kp,
    CubeReflectionMapping: Ts,
    CubeRefractionMapping: mo,
    EquirectangularReflectionMapping: Vc,
    EquirectangularRefractionMapping: Gc,
    CubeUVReflectionMapping: ru
}
  , bw = {
    RepeatWrapping: Wc,
    ClampToEdgeWrapping: ei,
    MirroredRepeatWrapping: Xc
}
  , Pw = {
    NearestFilter: hn,
    NearestMipmapNearestFilter: Tp,
    NearestMipmapLinearFilter: Jo,
    LinearFilter: Wt,
    LinearMipmapNearestFilter: _c,
    LinearMipmapLinearFilter: Gr
};
class dk extends vi {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = ys.get(e);
        if (o !== void 0) {
            if (s.manager.itemStart(e),
            o.then) {
                o.then(f=>{
                    t && t(f),
                    s.manager.itemEnd(e)
                }
                ).catch(f=>{
                    r && r(f)
                }
                );
                return
            }
            return setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o
        }
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        a.headers = this.requestHeader;
        const c = fetch(e, a).then(function(f) {
            return f.blob()
        }).then(function(f) {
            return createImageBitmap(f, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(f) {
            return ys.add(e, f),
            t && t(f),
            s.manager.itemEnd(e),
            f
        }).catch(function(f) {
            r && r(f),
            ys.remove(e),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        });
        ys.add(e, c),
        s.manager.itemStart(e)
    }
}
let wd;
class gx {
    static getContext() {
        return wd === void 0 && (wd = new (window.AudioContext || window.webkitAudioContext)),
        wd
    }
    static setContext(e) {
        wd = e
    }
}
class pk extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new Jr(this.manager);
        o.setResponseType("arraybuffer"),
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(c) {
            try {
                const f = c.slice(0);
                gx.getContext().decodeAudioData(f, function(d) {
                    t(d)
                }).catch(a)
            } catch (f) {
                a(f)
            }
        }, i, r);
        function a(c) {
            r ? r(c) : console.error(c),
            s.manager.itemError(e)
        }
    }
}
const Lw = new $e
  , Iw = new $e
  , Bo = new $e;
class mk {
    constructor() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new Dn,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new Dn,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1,
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    update(e) {
        const t = this._cache;
        if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
            t.focus = e.focus,
            t.fov = e.fov,
            t.aspect = e.aspect * this.aspect,
            t.near = e.near,
            t.far = e.far,
            t.zoom = e.zoom,
            t.eyeSep = this.eyeSep,
            Bo.copy(e.projectionMatrix);
            const r = t.eyeSep / 2
              , s = r * t.near / t.focus
              , o = t.near * Math.tan(ua * t.fov * .5) / t.zoom;
            let a, c;
            Iw.elements[12] = -r,
            Lw.elements[12] = r,
            a = -o * t.aspect + s,
            c = o * t.aspect + s,
            Bo.elements[0] = 2 * t.near / (c - a),
            Bo.elements[8] = (c + a) / (c - a),
            this.cameraL.projectionMatrix.copy(Bo),
            a = -o * t.aspect - s,
            c = o * t.aspect - s,
            Bo.elements[0] = 2 * t.near / (c - a),
            Bo.elements[8] = (c + a) / (c - a),
            this.cameraR.projectionMatrix.copy(Bo)
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Iw),
        this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Lw)
    }
}
class vx {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = Nw(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const t = Nw();
            e = (t - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
}
function Nw() {
    return (typeof performance > "u" ? Date : performance).now()
}
const Ho = new U
  , Dw = new En
  , gk = new U
  , Vo = new U;
class vk extends bt {
    constructor() {
        super(),
        this.type = "AudioListener",
        this.context = gx.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0,
        this._clock = new vx
    }
    getInput() {
        return this.gain
    }
    removeFilter() {
        return this.filter !== null && (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        this.filter = null),
        this
    }
    getFilter() {
        return this.filter
    }
    setFilter(e) {
        return this.filter !== null ? (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
        this.filter = e,
        this.gain.connect(this.filter),
        this.filter.connect(this.context.destination),
        this
    }
    getMasterVolume() {
        return this.gain.gain.value
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener
          , i = this.up;
        if (this.timeDelta = this._clock.getDelta(),
        this.matrixWorld.decompose(Ho, Dw, gk),
        Vo.set(0, 0, -1).applyQuaternion(Dw),
        t.positionX) {
            const r = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(Ho.x, r),
            t.positionY.linearRampToValueAtTime(Ho.y, r),
            t.positionZ.linearRampToValueAtTime(Ho.z, r),
            t.forwardX.linearRampToValueAtTime(Vo.x, r),
            t.forwardY.linearRampToValueAtTime(Vo.y, r),
            t.forwardZ.linearRampToValueAtTime(Vo.z, r),
            t.upX.linearRampToValueAtTime(i.x, r),
            t.upY.linearRampToValueAtTime(i.y, r),
            t.upZ.linearRampToValueAtTime(i.z, r)
        } else
            t.setPosition(Ho.x, Ho.y, Ho.z),
            t.setOrientation(Vo.x, Vo.y, Vo.z, i.x, i.y, i.z)
    }
}
class cR extends bt {
    constructor(e) {
        super(),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.source = null,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this._connected = !1,
        this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "audioNode",
        this.source = e,
        this.connect(),
        this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaNode",
        this.source = this.context.createMediaElementSource(e),
        this.connect(),
        this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaStreamNode",
        this.source = this.context.createMediaStreamSource(e),
        this.connect(),
        this
    }
    setBuffer(e) {
        return this.buffer = e,
        this.sourceType = "buffer",
        this.autoplay && this.play(),
        this
    }
    play(e=0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return t.buffer = this.buffer,
        t.loop = this.loop,
        t.loopStart = this.loopStart,
        t.loopEnd = this.loopEnd,
        t.onended = this.onEnded.bind(this),
        t.start(this._startedAt, this._progress + this.offset, this.duration),
        this.isPlaying = !0,
        this.source = t,
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1),
        this
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0,
        this.source !== null && (this.source.stop(),
        this.source.onended = null),
        this.isPlaying = !1,
        this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else
            this.source.connect(this.getOutput());
        return this._connected = !0,
        this
    }
    disconnect() {
        if (this._connected !== !1) {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this._connected = !1,
            this
        }
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []),
        this._connected === !0 ? (this.disconnect(),
        this.filters = e.slice(),
        this.connect()) : this.filters = e.slice(),
        this
    }
    setDetune(e) {
        return this.detune = e,
        this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
        this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = e,
        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
        this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
        !1) : this.loop
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = e,
        this.isPlaying === !0 && (this.source.loop = this.loop),
        this
    }
    setLoopStart(e) {
        return this.loopStart = e,
        this
    }
    setLoopEnd(e) {
        return this.loopEnd = e,
        this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
}
const Go = new U
  , Uw = new En
  , yk = new U
  , Wo = new U;
class _k extends cR {
    constructor(e) {
        super(e),
        this.panner = this.context.createPanner(),
        this.panner.panningModel = "HRTF",
        this.panner.connect(this.gain)
    }
    connect() {
        super.connect(),
        this.panner.connect(this.gain)
    }
    disconnect() {
        super.disconnect(),
        this.panner.disconnect(this.gain)
    }
    getOutput() {
        return this.panner
    }
    getRefDistance() {
        return this.panner.refDistance
    }
    setRefDistance(e) {
        return this.panner.refDistance = e,
        this
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor
    }
    setRolloffFactor(e) {
        return this.panner.rolloffFactor = e,
        this
    }
    getDistanceModel() {
        return this.panner.distanceModel
    }
    setDistanceModel(e) {
        return this.panner.distanceModel = e,
        this
    }
    getMaxDistance() {
        return this.panner.maxDistance
    }
    setMaxDistance(e) {
        return this.panner.maxDistance = e,
        this
    }
    setDirectionalCone(e, t, i) {
        return this.panner.coneInnerAngle = e,
        this.panner.coneOuterAngle = t,
        this.panner.coneOuterGain = i,
        this
    }
    updateMatrixWorld(e) {
        if (super.updateMatrixWorld(e),
        this.hasPlaybackControl === !0 && this.isPlaying === !1)
            return;
        this.matrixWorld.decompose(Go, Uw, yk),
        Wo.set(0, 0, 1).applyQuaternion(Uw);
        const t = this.panner;
        if (t.positionX) {
            const i = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(Go.x, i),
            t.positionY.linearRampToValueAtTime(Go.y, i),
            t.positionZ.linearRampToValueAtTime(Go.z, i),
            t.orientationX.linearRampToValueAtTime(Wo.x, i),
            t.orientationY.linearRampToValueAtTime(Wo.y, i),
            t.orientationZ.linearRampToValueAtTime(Wo.z, i)
        } else
            t.setPosition(Go.x, Go.y, Go.z),
            t.setOrientation(Wo.x, Wo.y, Wo.z)
    }
}
class xk {
    constructor(e, t=2048) {
        this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = t,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser)
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data),
        this.data
    }
    getAverageFrequency() {
        let e = 0;
        const t = this.getFrequencyData();
        for (let i = 0; i < t.length; i++)
            e += t[i];
        return e / t.length
    }
}
class fR {
    constructor(e, t, i) {
        this.binding = e,
        this.valueSize = i;
        let r, s, o;
        switch (t) {
        case "quaternion":
            r = this._slerp,
            s = this._slerpAdditive,
            o = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(i * 6),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            r = this._select,
            s = this._select,
            o = this._setAdditiveIdentityOther,
            this.buffer = new Array(i * 5);
            break;
        default:
            r = this._lerp,
            s = this._lerpAdditive,
            o = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(i * 5)
        }
        this._mixBufferRegion = r,
        this._mixBufferRegionAdditive = s,
        this._setIdentity = o,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    accumulate(e, t) {
        const i = this.buffer
          , r = this.valueSize
          , s = e * r + r;
        let o = this.cumulativeWeight;
        if (o === 0) {
            for (let a = 0; a !== r; ++a)
                i[s + a] = i[a];
            o = t
        } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(i, s, 0, a, r)
        }
        this.cumulativeWeight = o
    }
    accumulateAdditive(e) {
        const t = this.buffer
          , i = this.valueSize
          , r = i * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
        this._mixBufferRegionAdditive(t, r, 0, e, i),
        this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const t = this.valueSize
          , i = this.buffer
          , r = e * t + t
          , s = this.cumulativeWeight
          , o = this.cumulativeWeightAdditive
          , a = this.binding;
        if (this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        s < 1) {
            const c = t * this._origIndex;
            this._mixBufferRegion(i, r, c, 1 - s, t)
        }
        o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
        for (let c = t, f = t + t; c !== f; ++c)
            if (i[c] !== i[c + t]) {
                a.setValue(i, r);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding
          , t = this.buffer
          , i = this.valueSize
          , r = i * this._origIndex;
        e.getValue(t, r);
        for (let s = i, o = r; s !== o; ++s)
            t[s] = t[r + s % i];
        this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize
          , t = e + this.valueSize;
        for (let i = e; i < t; i++)
            this.buffer[i] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize
          , t = this._addIndex * this.valueSize;
        for (let i = 0; i < this.valueSize; i++)
            this.buffer[t + i] = this.buffer[e + i]
    }
    _select(e, t, i, r, s) {
        if (r >= .5)
            for (let o = 0; o !== s; ++o)
                e[t + o] = e[i + o]
    }
    _slerp(e, t, i, r) {
        En.slerpFlat(e, t, e, t, e, i, r)
    }
    _slerpAdditive(e, t, i, r, s) {
        const o = this._workIndex * s;
        En.multiplyQuaternionsFlat(e, o, e, t, e, i),
        En.slerpFlat(e, t, e, t, e, o, r)
    }
    _lerp(e, t, i, r, s) {
        const o = 1 - r;
        for (let a = 0; a !== s; ++a) {
            const c = t + a;
            e[c] = e[c] * o + e[i + a] * r
        }
    }
    _lerpAdditive(e, t, i, r, s) {
        for (let o = 0; o !== s; ++o) {
            const a = t + o;
            e[a] = e[a] + e[i + o] * r
        }
    }
}
const yx = "\\[\\]\\.:\\/"
  , Sk = new RegExp("[" + yx + "]","g")
  , _x = "[^" + yx + "]"
  , Mk = "[^" + yx.replace("\\.", "") + "]"
  , wk = /((?:WC+[\/:])*)/.source.replace("WC", _x)
  , Ek = /(WCOD+)?/.source.replace("WCOD", Mk)
  , Tk = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _x)
  , Ak = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _x)
  , Ck = new RegExp("^" + wk + Ek + Tk + Ak + "$")
  , Rk = ["material", "materials", "bones", "map"];
class bk {
    constructor(e, t, i) {
        const r = i || At.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, r)
    }
    getValue(e, t) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_
          , r = this._bindings[i];
        r !== void 0 && r.getValue(e, t)
    }
    setValue(e, t) {
        const i = this._bindings;
        for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
            i[r].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
            e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
            e[t].unbind()
    }
}
class At {
    constructor(e, t, i) {
        this.path = t,
        this.parsedPath = i || At.parseTrackName(t),
        this.node = At.findNode(e, this.parsedPath.nodeName),
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, i) {
        return e && e.isAnimationObjectGroup ? new At.Composite(e,t,i) : new At(e,t,i)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(Sk, "")
    }
    static parseTrackName(e) {
        const t = Ck.exec(e);
        if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const i = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , r = i.nodeName && i.nodeName.lastIndexOf(".");
        if (r !== void 0 && r !== -1) {
            const s = i.nodeName.substring(r + 1);
            Rk.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r),
            i.objectName = s)
        }
        if (i.propertyName === null || i.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return i
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const i = e.skeleton.getBoneByName(t);
            if (i !== void 0)
                return i
        }
        if (e.children) {
            const i = function(s) {
                for (let o = 0; o < s.length; o++) {
                    const a = s[o];
                    if (a.name === t || a.uuid === t)
                        return a;
                    const c = i(a.children);
                    if (c)
                        return c
                }
                return null
            }
              , r = i(e.children);
            if (r)
                return r
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            e[t++] = i[r]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath
          , i = t.objectName
          , r = t.propertyName;
        let s = t.propertyIndex;
        if (e || (e = At.findNode(this.rootNode, t.nodeName),
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (i) {
            let f = t.objectIndex;
            switch (i) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let h = 0; h < e.length; h++)
                    if (e[h].name === f) {
                        f = h;
                        break
                    }
                break;
            case "map":
                if ("map"in e) {
                    e = e.map;
                    break
                }
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[i] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[i]
            }
            if (f !== void 0) {
                if (e[f] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[f]
            }
        }
        const o = e[r];
        if (o === void 0) {
            const f = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + f + "." + r + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e,
        e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let c = this.BindingType.Direct;
        if (s !== void 0) {
            if (r === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
            }
            c = this.BindingType.ArrayElement,
            this.resolvedProperty = o,
            this.propertyIndex = s
        } else
            o.fromArray !== void 0 && o.toArray !== void 0 ? (c = this.BindingType.HasFromToArray,
            this.resolvedProperty = o) : Array.isArray(o) ? (c = this.BindingType.EntireArray,
            this.resolvedProperty = o) : this.propertyName = r;
        this.getValue = this.GetterByBindingType[c],
        this.setValue = this.SetterByBindingTypeAndVersioning[c][a]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
At.Composite = bk;
At.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
At.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
At.prototype.GetterByBindingType = [At.prototype._getValue_direct, At.prototype._getValue_array, At.prototype._getValue_arrayElement, At.prototype._getValue_toArray];
At.prototype.SetterByBindingTypeAndVersioning = [[At.prototype._setValue_direct, At.prototype._setValue_direct_setNeedsUpdate, At.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [At.prototype._setValue_array, At.prototype._setValue_array_setNeedsUpdate, At.prototype._setValue_array_setMatrixWorldNeedsUpdate], [At.prototype._setValue_arrayElement, At.prototype._setValue_arrayElement_setNeedsUpdate, At.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [At.prototype._setValue_fromArray, At.prototype._setValue_fromArray_setNeedsUpdate, At.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class Pk {
    constructor() {
        this.isAnimationObjectGroup = !0,
        this.uuid = Hi(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        const e = {};
        this._indicesByUUID = e;
        for (let i = 0, r = arguments.length; i !== r; ++i)
            e[arguments[i].uuid] = i;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        const t = this;
        this.stats = {
            objects: {
                get total() {
                    return t._objects.length
                },
                get inUse() {
                    return this.total - t.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return t._bindings.length
            }
        }
    }
    add() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._paths
          , r = this._parsedPaths
          , s = this._bindings
          , o = s.length;
        let a, c = e.length, f = this.nCachedObjects_;
        for (let h = 0, d = arguments.length; h !== d; ++h) {
            const m = arguments[h]
              , v = m.uuid;
            let _ = t[v];
            if (_ === void 0) {
                _ = c++,
                t[v] = _,
                e.push(m);
                for (let w = 0, x = o; w !== x; ++w)
                    s[w].push(new At(m,i[w],r[w]))
            } else if (_ < f) {
                a = e[_];
                const w = --f
                  , x = e[w];
                t[x.uuid] = _,
                e[_] = x,
                t[v] = w,
                e[w] = m;
                for (let g = 0, S = o; g !== S; ++g) {
                    const M = s[g]
                      , T = M[w];
                    let P = M[_];
                    M[_] = T,
                    P === void 0 && (P = new At(m,i[g],r[g])),
                    M[w] = P
                }
            } else
                e[_] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = f
    }
    remove() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._bindings
          , r = i.length;
        let s = this.nCachedObjects_;
        for (let o = 0, a = arguments.length; o !== a; ++o) {
            const c = arguments[o]
              , f = c.uuid
              , h = t[f];
            if (h !== void 0 && h >= s) {
                const d = s++
                  , m = e[d];
                t[m.uuid] = h,
                e[h] = m,
                t[f] = d,
                e[d] = c;
                for (let v = 0, _ = r; v !== _; ++v) {
                    const w = i[v]
                      , x = w[d]
                      , g = w[h];
                    w[h] = x,
                    w[d] = g
                }
            }
        }
        this.nCachedObjects_ = s
    }
    uncache() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._bindings
          , r = i.length;
        let s = this.nCachedObjects_
          , o = e.length;
        for (let a = 0, c = arguments.length; a !== c; ++a) {
            const f = arguments[a]
              , h = f.uuid
              , d = t[h];
            if (d !== void 0)
                if (delete t[h],
                d < s) {
                    const m = --s
                      , v = e[m]
                      , _ = --o
                      , w = e[_];
                    t[v.uuid] = d,
                    e[d] = v,
                    t[w.uuid] = m,
                    e[m] = w,
                    e.pop();
                    for (let x = 0, g = r; x !== g; ++x) {
                        const S = i[x]
                          , M = S[m]
                          , T = S[_];
                        S[d] = M,
                        S[m] = T,
                        S.pop()
                    }
                } else {
                    const m = --o
                      , v = e[m];
                    m > 0 && (t[v.uuid] = d),
                    e[d] = v,
                    e.pop();
                    for (let _ = 0, w = r; _ !== w; ++_) {
                        const x = i[_];
                        x[d] = x[m],
                        x.pop()
                    }
                }
        }
        this.nCachedObjects_ = s
    }
    subscribe_(e, t) {
        const i = this._bindingsIndicesByPath;
        let r = i[e];
        const s = this._bindings;
        if (r !== void 0)
            return s[r];
        const o = this._paths
          , a = this._parsedPaths
          , c = this._objects
          , f = c.length
          , h = this.nCachedObjects_
          , d = new Array(f);
        r = s.length,
        i[e] = r,
        o.push(e),
        a.push(t),
        s.push(d);
        for (let m = h, v = c.length; m !== v; ++m) {
            const _ = c[m];
            d[m] = new At(_,e,t)
        }
        return d
    }
    unsubscribe_(e) {
        const t = this._bindingsIndicesByPath
          , i = t[e];
        if (i !== void 0) {
            const r = this._paths
              , s = this._parsedPaths
              , o = this._bindings
              , a = o.length - 1
              , c = o[a]
              , f = e[a];
            t[f] = i,
            o[i] = c,
            o.pop(),
            s[i] = s[a],
            s.pop(),
            r[i] = r[a],
            r.pop()
        }
    }
}
class hR {
    constructor(e, t, i=null, r=t.blendMode) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = i,
        this.blendMode = r;
        const s = t.tracks
          , o = s.length
          , a = new Array(o)
          , c = {
            endingStart: ta,
            endingEnd: ta
        };
        for (let f = 0; f !== o; ++f) {
            const h = s[f].createInterpolant(null);
            a[f] = h,
            h.settings = c
        }
        this._interpolantSettings = c,
        this._interpolants = a,
        this._propertyBindings = new Array(o),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = Y2,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this),
        this
    }
    stop() {
        return this._mixer._deactivateAction(this),
        this.reset()
    }
    reset() {
        return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e,
        this
    }
    setLoop(e, t) {
        return this.loop = e,
        this.repetitions = t,
        this
    }
    setEffectiveWeight(e) {
        return this.weight = e,
        this._effectiveWeight = this.enabled ? e : 0,
        this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, t, i) {
        if (e.fadeOut(t),
        this.fadeIn(t),
        i) {
            const r = this._clip.duration
              , s = e._clip.duration
              , o = s / r
              , a = r / s;
            e.warp(1, o, t),
            this.warp(a, 1, t)
        }
        return this
    }
    crossFadeTo(e, t, i) {
        return e.crossFadeFrom(this, t, i)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e,
        this._effectiveTimeScale = this.paused ? 0 : e,
        this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e,
        this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time,
        this.timeScale = e.timeScale,
        this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, t, i) {
        const r = this._mixer
          , s = r.time
          , o = this.timeScale;
        let a = this._timeScaleInterpolant;
        a === null && (a = r._lendControlInterpolant(),
        this._timeScaleInterpolant = a);
        const c = a.parameterPositions
          , f = a.sampleValues;
        return c[0] = s,
        c[1] = s + i,
        f[0] = e / o,
        f[1] = t / o,
        this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, t, i, r) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        const s = this._startTime;
        if (s !== null) {
            const c = (e - s) * i;
            c < 0 || i === 0 ? t = 0 : (this._startTime = null,
            t = i * c)
        }
        t *= this._updateTimeScale(e);
        const o = this._updateTime(t)
          , a = this._updateWeight(e);
        if (a > 0) {
            const c = this._interpolants
              , f = this._propertyBindings;
            switch (this.blendMode) {
            case V_:
                for (let h = 0, d = c.length; h !== d; ++h)
                    c[h].evaluate(o),
                    f[h].accumulateAdditive(a);
                break;
            case $p:
            default:
                for (let h = 0, d = c.length; h !== d; ++h)
                    c[h].evaluate(o),
                    f[h].accumulate(r, a)
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const i = this._weightInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                t *= r,
                e > i.parameterPositions[1] && (this.stopFading(),
                r === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t,
        t
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const i = this._timeScaleInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                t *= r,
                e > i.parameterPositions[1] && (this.stopWarping(),
                t === 0 ? this.paused = !0 : this.timeScale = t)
            }
        }
        return this._effectiveTimeScale = t,
        t
    }
    _updateTime(e) {
        const t = this._clip.duration
          , i = this.loop;
        let r = this.time + e
          , s = this._loopCount;
        const o = i === j2;
        if (e === 0)
            return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
        if (i === X2) {
            s === -1 && (this._loopCount = 0,
            this._setEndings(!0, !0, !1));
            e: {
                if (r >= t)
                    r = t;
                else if (r < 0)
                    r = 0;
                else {
                    this.time = r;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = r,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (s === -1 && (e >= 0 ? (s = 0,
            this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)),
            r >= t || r < 0) {
                const a = Math.floor(r / t);
                r -= t * a,
                s += Math.abs(a);
                const c = this.repetitions - s;
                if (c <= 0)
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    r = e > 0 ? t : 0,
                    this.time = r,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                else {
                    if (c === 1) {
                        const f = e < 0;
                        this._setEndings(f, !f, o)
                    } else
                        this._setEndings(!1, !1, o);
                    this._loopCount = s,
                    this.time = r,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: a
                    })
                }
            } else
                this.time = r;
            if (o && (s & 1) === 1)
                return t - r
        }
        return r
    }
    _setEndings(e, t, i) {
        const r = this._interpolantSettings;
        i ? (r.endingStart = na,
        r.endingEnd = na) : (e ? r.endingStart = this.zeroSlopeAtStart ? na : ta : r.endingStart = qc,
        t ? r.endingEnd = this.zeroSlopeAtEnd ? na : ta : r.endingEnd = qc)
    }
    _scheduleFading(e, t, i) {
        const r = this._mixer
          , s = r.time;
        let o = this._weightInterpolant;
        o === null && (o = r._lendControlInterpolant(),
        this._weightInterpolant = o);
        const a = o.parameterPositions
          , c = o.sampleValues;
        return a[0] = s,
        c[0] = t,
        a[1] = s + e,
        c[1] = i,
        this
    }
}
const Lk = new Float32Array(1);
class Ik extends Rs {
    constructor(e) {
        super(),
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    _bindAction(e, t) {
        const i = e._localRoot || this._root
          , r = e._clip.tracks
          , s = r.length
          , o = e._propertyBindings
          , a = e._interpolants
          , c = i.uuid
          , f = this._bindingsByRootAndName;
        let h = f[c];
        h === void 0 && (h = {},
        f[c] = h);
        for (let d = 0; d !== s; ++d) {
            const m = r[d]
              , v = m.name;
            let _ = h[v];
            if (_ !== void 0)
                ++_.referenceCount,
                o[d] = _;
            else {
                if (_ = o[d],
                _ !== void 0) {
                    _._cacheIndex === null && (++_.referenceCount,
                    this._addInactiveBinding(_, c, v));
                    continue
                }
                const w = t && t._propertyBindings[d].binding.parsedPath;
                _ = new fR(At.create(i, v, w),m.ValueTypeName,m.getValueSize()),
                ++_.referenceCount,
                this._addInactiveBinding(_, c, v),
                o[d] = _
            }
            a[d].resultBuffer = _.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const i = (e._localRoot || this._root).uuid
                  , r = e._clip.uuid
                  , s = this._actionsByClip[r];
                this._bindAction(e, s && s.knownActions[0]),
                this._addInactiveAction(e, r, i)
            }
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                s.useCount++ === 0 && (this._lendBinding(s),
                s.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                --s.useCount === 0 && (s.restoreOriginalState(),
                this._takeBackBinding(s))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return t !== null && t < this._nActiveActions
    }
    _addInactiveAction(e, t, i) {
        const r = this._actions
          , s = this._actionsByClip;
        let o = s[t];
        if (o === void 0)
            o = {
                knownActions: [e],
                actionByRoot: {}
            },
            e._byClipCacheIndex = 0,
            s[t] = o;
        else {
            const a = o.knownActions;
            e._byClipCacheIndex = a.length,
            a.push(e)
        }
        e._cacheIndex = r.length,
        r.push(e),
        o.actionByRoot[i] = e
    }
    _removeInactiveAction(e) {
        const t = this._actions
          , i = t[t.length - 1]
          , r = e._cacheIndex;
        i._cacheIndex = r,
        t[r] = i,
        t.pop(),
        e._cacheIndex = null;
        const s = e._clip.uuid
          , o = this._actionsByClip
          , a = o[s]
          , c = a.knownActions
          , f = c[c.length - 1]
          , h = e._byClipCacheIndex;
        f._byClipCacheIndex = h,
        c[h] = f,
        c.pop(),
        e._byClipCacheIndex = null;
        const d = a.actionByRoot
          , m = (e._localRoot || this._root).uuid;
        delete d[m],
        c.length === 0 && delete o[s],
        this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let i = 0, r = t.length; i !== r; ++i) {
            const s = t[i];
            --s.referenceCount === 0 && this._removeInactiveBinding(s)
        }
    }
    _lendAction(e) {
        const t = this._actions
          , i = e._cacheIndex
          , r = this._nActiveActions++
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _takeBackAction(e) {
        const t = this._actions
          , i = e._cacheIndex
          , r = --this._nActiveActions
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _addInactiveBinding(e, t, i) {
        const r = this._bindingsByRootAndName
          , s = this._bindings;
        let o = r[t];
        o === void 0 && (o = {},
        r[t] = o),
        o[i] = e,
        e._cacheIndex = s.length,
        s.push(e)
    }
    _removeInactiveBinding(e) {
        const t = this._bindings
          , i = e.binding
          , r = i.rootNode.uuid
          , s = i.path
          , o = this._bindingsByRootAndName
          , a = o[r]
          , c = t[t.length - 1]
          , f = e._cacheIndex;
        c._cacheIndex = f,
        t[f] = c,
        t.pop(),
        delete a[s],
        Object.keys(a).length === 0 && delete o[r]
    }
    _lendBinding(e) {
        const t = this._bindings
          , i = e._cacheIndex
          , r = this._nActiveBindings++
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _takeBackBinding(e) {
        const t = this._bindings
          , i = e._cacheIndex
          , r = --this._nActiveBindings
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants
          , t = this._nActiveControlInterpolants++;
        let i = e[t];
        return i === void 0 && (i = new hx(new Float32Array(2),new Float32Array(2),1,Lk),
        i.__cacheIndex = t,
        e[t] = i),
        i
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants
          , i = e.__cacheIndex
          , r = --this._nActiveControlInterpolants
          , s = t[r];
        e.__cacheIndex = r,
        t[r] = e,
        s.__cacheIndex = i,
        t[i] = s
    }
    clipAction(e, t, i) {
        const r = t || this._root
          , s = r.uuid;
        let o = typeof e == "string" ? lf.findByName(r, e) : e;
        const a = o !== null ? o.uuid : e
          , c = this._actionsByClip[a];
        let f = null;
        if (i === void 0 && (o !== null ? i = o.blendMode : i = $p),
        c !== void 0) {
            const d = c.actionByRoot[s];
            if (d !== void 0 && d.blendMode === i)
                return d;
            f = c.knownActions[0],
            o === null && (o = f._clip)
        }
        if (o === null)
            return null;
        const h = new hR(this,o,t,i);
        return this._bindAction(h, f),
        this._addInactiveAction(h, a, s),
        h
    }
    existingAction(e, t) {
        const i = t || this._root
          , r = i.uuid
          , s = typeof e == "string" ? lf.findByName(i, e) : e
          , o = s ? s.uuid : e
          , a = this._actionsByClip[o];
        return a !== void 0 && a.actionByRoot[r] || null
    }
    stopAllAction() {
        const e = this._actions
          , t = this._nActiveActions;
        for (let i = t - 1; i >= 0; --i)
            e[i].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions
          , i = this._nActiveActions
          , r = this.time += e
          , s = Math.sign(e)
          , o = this._accuIndex ^= 1;
        for (let f = 0; f !== i; ++f)
            t[f]._update(r, e, s, o);
        const a = this._bindings
          , c = this._nActiveBindings;
        for (let f = 0; f !== c; ++f)
            a[f].apply(o);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const t = this._actions
          , i = e.uuid
          , r = this._actionsByClip
          , s = r[i];
        if (s !== void 0) {
            const o = s.knownActions;
            for (let a = 0, c = o.length; a !== c; ++a) {
                const f = o[a];
                this._deactivateAction(f);
                const h = f._cacheIndex
                  , d = t[t.length - 1];
                f._cacheIndex = null,
                f._byClipCacheIndex = null,
                d._cacheIndex = h,
                t[h] = d,
                t.pop(),
                this._removeInactiveBindingsForAction(f)
            }
            delete r[i]
        }
    }
    uncacheRoot(e) {
        const t = e.uuid
          , i = this._actionsByClip;
        for (const o in i) {
            const a = i[o].actionByRoot
              , c = a[t];
            c !== void 0 && (this._deactivateAction(c),
            this._removeInactiveAction(c))
        }
        const r = this._bindingsByRootAndName
          , s = r[t];
        if (s !== void 0)
            for (const o in s) {
                const a = s[o];
                a.restoreOriginalState(),
                this._removeInactiveBinding(a)
            }
    }
    uncacheAction(e, t) {
        const i = this.existingAction(e, t);
        i !== null && (this._deactivateAction(i),
        this._removeInactiveAction(i))
    }
}
class xx {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new xx(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
let Nk = 0;
class Dk extends Rs {
    constructor() {
        super(),
        this.isUniformsGroup = !0,
        Object.defineProperty(this, "id", {
            value: Nk++
        }),
        this.name = "",
        this.usage = Qc,
        this.uniforms = []
    }
    add(e) {
        return this.uniforms.push(e),
        this
    }
    remove(e) {
        const t = this.uniforms.indexOf(e);
        return t !== -1 && this.uniforms.splice(t, 1),
        this
    }
    setName(e) {
        return this.name = e,
        this
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }),
        this
    }
    copy(e) {
        this.name = e.name,
        this.usage = e.usage;
        const t = e.uniforms;
        this.uniforms.length = 0;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = Array.isArray(t[i]) ? t[i] : [t[i]];
            for (let o = 0; o < s.length; o++)
                this.uniforms.push(s[o].clone())
        }
        return this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Uk extends om {
    constructor(e, t, i=1) {
        super(e, t),
        this.isInstancedInterleavedBuffer = !0,
        this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    clone(e) {
        const t = super.clone(e);
        return t.meshPerAttribute = this.meshPerAttribute,
        t
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.isInstancedInterleavedBuffer = !0,
        t.meshPerAttribute = this.meshPerAttribute,
        t
    }
}
class Ok {
    constructor(e, t, i, r, s) {
        this.isGLBufferAttribute = !0,
        this.name = "",
        this.buffer = e,
        this.type = t,
        this.itemSize = i,
        this.elementSize = r,
        this.count = s,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setBuffer(e) {
        return this.buffer = e,
        this
    }
    setType(e, t) {
        return this.type = e,
        this.elementSize = t,
        this
    }
    setItemSize(e) {
        return this.itemSize = e,
        this
    }
    setCount(e) {
        return this.count = e,
        this
    }
}
const Ow = new $e;
class dR {
    constructor(e, t, i=0, r=1 / 0) {
        this.ray = new su(e,t),
        this.near = i,
        this.far = r,
        this.camera = null,
        this.layers = new ca,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, t) {
        this.ray.set(e, t)
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
    }
    setFromXRController(e) {
        return Ow.identity().extractRotation(e.matrixWorld),
        this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction.set(0, 0, -1).applyMatrix4(Ow),
        this
    }
    intersectObject(e, t=!0, i=[]) {
        return Iy(e, this, i, t),
        i.sort(Fw),
        i
    }
    intersectObjects(e, t=!0, i=[]) {
        for (let r = 0, s = e.length; r < s; r++)
            Iy(e[r], this, i, t);
        return i.sort(Fw),
        i
    }
}
function Fw(n, e) {
    return n.distance - e.distance
}
function Iy(n, e, t, i) {
    if (n.layers.test(e.layers) && n.raycast(e, t),
    i === !0) {
        const r = n.children;
        for (let s = 0, o = r.length; s < o; s++)
            Iy(r[s], e, t, !0)
    }
}
class pR {
    constructor(e=1, t=0, i=0) {
        return this.radius = e,
        this.phi = t,
        this.theta = i,
        this
    }
    set(e, t, i) {
        return this.radius = e,
        this.phi = t,
        this.theta = i,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + t * t + i * i),
        this.radius === 0 ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(e, i),
        this.phi = Math.acos(ln(t / this.radius, -1, 1))),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Fk {
    constructor(e=1, t=0, i=0) {
        return this.radius = e,
        this.theta = t,
        this.y = i,
        this
    }
    set(e, t, i) {
        return this.radius = e,
        this.theta = t,
        this.y = i,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.theta = e.theta,
        this.y = e.y,
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + i * i),
        this.theta = Math.atan2(e, i),
        this.y = t,
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const kw = new he;
class kk {
    constructor(e=new he(1 / 0,1 / 0), t=new he(-1 / 0,-1 / 0)) {
        this.isBox2 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = kw.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0,
        this.max.x = this.max.y = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, kw).distanceTo(e)
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const zw = new U
  , Ed = new U;
class zk {
    constructor(e=new U, t=new U) {
        this.start = e,
        this.end = t
    }
    set(e, t) {
        return this.start.copy(e),
        this.end.copy(t),
        this
    }
    copy(e) {
        return this.start.copy(e.start),
        this.end.copy(e.end),
        this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, t) {
        zw.subVectors(e, this.start),
        Ed.subVectors(this.end, this.start);
        const i = Ed.dot(Ed);
        let s = Ed.dot(zw) / i;
        return t && (s = ln(s, 0, 1)),
        s
    }
    closestPointToPoint(e, t, i) {
        const r = this.closestPointToPointParameter(e, t);
        return this.delta(i).multiplyScalar(r).add(this.start)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e),
        this.end.applyMatrix4(e),
        this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Bw = new U;
class Bk extends bt {
    constructor(e, t) {
        super(),
        this.light = e,
        this.matrixAutoUpdate = !1,
        this.color = t,
        this.type = "SpotLightHelper";
        const i = new _t
          , r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let o = 0, a = 1, c = 32; o < c; o++,
        a++) {
            const f = o / c * Math.PI * 2
              , h = a / c * Math.PI * 2;
            r.push(Math.cos(f), Math.sin(f), 1, Math.cos(h), Math.sin(h), 1)
        }
        i.setAttribute("position", new We(r,3));
        const s = new gi({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new Kr(i,s),
        this.add(this.cone),
        this.update()
    }
    dispose() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1),
        this.parent ? (this.parent.updateWorldMatrix(!0),
        this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld),
        this.matrixWorld.copy(this.light.matrixWorld);
        const e = this.light.distance ? this.light.distance : 1e3
          , t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e),
        Bw.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(Bw),
        this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
}
const Ys = new U
  , Td = new $e
  , z0 = new $e;
class Hk extends Kr {
    constructor(e) {
        const t = mR(e)
          , i = new _t
          , r = []
          , s = []
          , o = new Ne(0,0,1)
          , a = new Ne(0,1,0);
        for (let f = 0; f < t.length; f++) {
            const h = t[f];
            h.parent && h.parent.isBone && (r.push(0, 0, 0),
            r.push(0, 0, 0),
            s.push(o.r, o.g, o.b),
            s.push(a.r, a.g, a.b))
        }
        i.setAttribute("position", new We(r,3)),
        i.setAttribute("color", new We(s,3));
        const c = new gi({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        super(i, c),
        this.isSkeletonHelper = !0,
        this.type = "SkeletonHelper",
        this.root = e,
        this.bones = t,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    updateMatrixWorld(e) {
        const t = this.bones
          , i = this.geometry
          , r = i.getAttribute("position");
        z0.copy(this.root.matrixWorld).invert();
        for (let s = 0, o = 0; s < t.length; s++) {
            const a = t[s];
            a.parent && a.parent.isBone && (Td.multiplyMatrices(z0, a.matrixWorld),
            Ys.setFromMatrixPosition(Td),
            r.setXYZ(o, Ys.x, Ys.y, Ys.z),
            Td.multiplyMatrices(z0, a.parent.matrixWorld),
            Ys.setFromMatrixPosition(Td),
            r.setXYZ(o + 1, Ys.x, Ys.y, Ys.z),
            o += 2)
        }
        i.getAttribute("position").needsUpdate = !0,
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function mR(n) {
    const e = [];
    n.isBone === !0 && e.push(n);
    for (let t = 0; t < n.children.length; t++)
        e.push.apply(e, mR(n.children[t]));
    return e
}
class Vk extends _n {
    constructor(e, t, i) {
        const r = new Ef(t,4,2)
          , s = new So({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        });
        super(r, s),
        this.light = e,
        this.color = i,
        this.type = "PointLightHelper",
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
}
const Gk = new U
  , Hw = new Ne
  , Vw = new Ne;
class Wk extends bt {
    constructor(e, t, i) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        this.type = "HemisphereLightHelper";
        const r = new wf(t);
        r.rotateY(Math.PI * .5),
        this.material = new So({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }),
        this.color === void 0 && (this.material.vertexColors = !0);
        const s = r.getAttribute("position")
          , o = new Float32Array(s.count * 3);
        r.setAttribute("color", new Nt(o,3)),
        this.add(new _n(r,this.material)),
        this.update()
    }
    dispose() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    update() {
        const e = this.children[0];
        if (this.color !== void 0)
            this.material.color.set(this.color);
        else {
            const t = e.geometry.getAttribute("color");
            Hw.copy(this.light.color),
            Vw.copy(this.light.groundColor);
            for (let i = 0, r = t.count; i < r; i++) {
                const s = i < r / 2 ? Hw : Vw;
                t.setXYZ(i, s.r, s.g, s.b)
            }
            t.needsUpdate = !0
        }
        this.light.updateWorldMatrix(!0, !1),
        e.lookAt(Gk.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
}
class Xk extends Kr {
    constructor(e=10, t=10, i=4473924, r=8947848) {
        i = new Ne(i),
        r = new Ne(r);
        const s = t / 2
          , o = e / t
          , a = e / 2
          , c = []
          , f = [];
        for (let m = 0, v = 0, _ = -a; m <= t; m++,
        _ += o) {
            c.push(-a, 0, _, a, 0, _),
            c.push(_, 0, -a, _, 0, a);
            const w = m === s ? i : r;
            w.toArray(f, v),
            v += 3,
            w.toArray(f, v),
            v += 3,
            w.toArray(f, v),
            v += 3,
            w.toArray(f, v),
            v += 3
        }
        const h = new _t;
        h.setAttribute("position", new We(c,3)),
        h.setAttribute("color", new We(f,3));
        const d = new gi({
            vertexColors: !0,
            toneMapped: !1
        });
        super(h, d),
        this.type = "GridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class Yk extends Kr {
    constructor(e=10, t=16, i=8, r=64, s=4473924, o=8947848) {
        s = new Ne(s),
        o = new Ne(o);
        const a = []
          , c = [];
        if (t > 1)
            for (let d = 0; d < t; d++) {
                const m = d / t * (Math.PI * 2)
                  , v = Math.sin(m) * e
                  , _ = Math.cos(m) * e;
                a.push(0, 0, 0),
                a.push(v, 0, _);
                const w = d & 1 ? s : o;
                c.push(w.r, w.g, w.b),
                c.push(w.r, w.g, w.b)
            }
        for (let d = 0; d < i; d++) {
            const m = d & 1 ? s : o
              , v = e - e / i * d;
            for (let _ = 0; _ < r; _++) {
                let w = _ / r * (Math.PI * 2)
                  , x = Math.sin(w) * v
                  , g = Math.cos(w) * v;
                a.push(x, 0, g),
                c.push(m.r, m.g, m.b),
                w = (_ + 1) / r * (Math.PI * 2),
                x = Math.sin(w) * v,
                g = Math.cos(w) * v,
                a.push(x, 0, g),
                c.push(m.r, m.g, m.b)
            }
        }
        const f = new _t;
        f.setAttribute("position", new We(a,3)),
        f.setAttribute("color", new We(c,3));
        const h = new gi({
            vertexColors: !0,
            toneMapped: !1
        });
        super(f, h),
        this.type = "PolarGridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
const Gw = new U
  , Ad = new U
  , Ww = new U;
class jk extends bt {
    constructor(e, t, i) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        this.type = "DirectionalLightHelper",
        t === void 0 && (t = 1);
        let r = new _t;
        r.setAttribute("position", new We([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
        const s = new gi({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new go(r,s),
        this.add(this.lightPlane),
        r = new _t,
        r.setAttribute("position", new We([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new go(r,s),
        this.add(this.targetLine),
        this.update()
    }
    dispose() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1),
        Gw.setFromMatrixPosition(this.light.matrixWorld),
        Ad.setFromMatrixPosition(this.light.target.matrixWorld),
        Ww.subVectors(Ad, Gw),
        this.lightPlane.lookAt(Ad),
        this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(Ad),
        this.targetLine.scale.z = Ww.length()
    }
}
const Cd = new U
  , on = new vf;
class qk extends Kr {
    constructor(e) {
        const t = new _t
          , i = new gi({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1
        })
          , r = []
          , s = []
          , o = {};
        a("n1", "n2"),
        a("n2", "n4"),
        a("n4", "n3"),
        a("n3", "n1"),
        a("f1", "f2"),
        a("f2", "f4"),
        a("f4", "f3"),
        a("f3", "f1"),
        a("n1", "f1"),
        a("n2", "f2"),
        a("n3", "f3"),
        a("n4", "f4"),
        a("p", "n1"),
        a("p", "n2"),
        a("p", "n3"),
        a("p", "n4"),
        a("u1", "u2"),
        a("u2", "u3"),
        a("u3", "u1"),
        a("c", "t"),
        a("p", "c"),
        a("cn1", "cn2"),
        a("cn3", "cn4"),
        a("cf1", "cf2"),
        a("cf3", "cf4");
        function a(_, w) {
            c(_),
            c(w)
        }
        function c(_) {
            r.push(0, 0, 0),
            s.push(0, 0, 0),
            o[_] === void 0 && (o[_] = []),
            o[_].push(r.length / 3 - 1)
        }
        t.setAttribute("position", new We(r,3)),
        t.setAttribute("color", new We(s,3)),
        super(t, i),
        this.type = "CameraHelper",
        this.camera = e,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = o,
        this.update();
        const f = new Ne(16755200)
          , h = new Ne(16711680)
          , d = new Ne(43775)
          , m = new Ne(16777215)
          , v = new Ne(3355443);
        this.setColors(f, h, d, m, v)
    }
    setColors(e, t, i, r, s) {
        const a = this.geometry.getAttribute("color");
        a.setXYZ(0, e.r, e.g, e.b),
        a.setXYZ(1, e.r, e.g, e.b),
        a.setXYZ(2, e.r, e.g, e.b),
        a.setXYZ(3, e.r, e.g, e.b),
        a.setXYZ(4, e.r, e.g, e.b),
        a.setXYZ(5, e.r, e.g, e.b),
        a.setXYZ(6, e.r, e.g, e.b),
        a.setXYZ(7, e.r, e.g, e.b),
        a.setXYZ(8, e.r, e.g, e.b),
        a.setXYZ(9, e.r, e.g, e.b),
        a.setXYZ(10, e.r, e.g, e.b),
        a.setXYZ(11, e.r, e.g, e.b),
        a.setXYZ(12, e.r, e.g, e.b),
        a.setXYZ(13, e.r, e.g, e.b),
        a.setXYZ(14, e.r, e.g, e.b),
        a.setXYZ(15, e.r, e.g, e.b),
        a.setXYZ(16, e.r, e.g, e.b),
        a.setXYZ(17, e.r, e.g, e.b),
        a.setXYZ(18, e.r, e.g, e.b),
        a.setXYZ(19, e.r, e.g, e.b),
        a.setXYZ(20, e.r, e.g, e.b),
        a.setXYZ(21, e.r, e.g, e.b),
        a.setXYZ(22, e.r, e.g, e.b),
        a.setXYZ(23, e.r, e.g, e.b),
        a.setXYZ(24, t.r, t.g, t.b),
        a.setXYZ(25, t.r, t.g, t.b),
        a.setXYZ(26, t.r, t.g, t.b),
        a.setXYZ(27, t.r, t.g, t.b),
        a.setXYZ(28, t.r, t.g, t.b),
        a.setXYZ(29, t.r, t.g, t.b),
        a.setXYZ(30, t.r, t.g, t.b),
        a.setXYZ(31, t.r, t.g, t.b),
        a.setXYZ(32, i.r, i.g, i.b),
        a.setXYZ(33, i.r, i.g, i.b),
        a.setXYZ(34, i.r, i.g, i.b),
        a.setXYZ(35, i.r, i.g, i.b),
        a.setXYZ(36, i.r, i.g, i.b),
        a.setXYZ(37, i.r, i.g, i.b),
        a.setXYZ(38, r.r, r.g, r.b),
        a.setXYZ(39, r.r, r.g, r.b),
        a.setXYZ(40, s.r, s.g, s.b),
        a.setXYZ(41, s.r, s.g, s.b),
        a.setXYZ(42, s.r, s.g, s.b),
        a.setXYZ(43, s.r, s.g, s.b),
        a.setXYZ(44, s.r, s.g, s.b),
        a.setXYZ(45, s.r, s.g, s.b),
        a.setXYZ(46, s.r, s.g, s.b),
        a.setXYZ(47, s.r, s.g, s.b),
        a.setXYZ(48, s.r, s.g, s.b),
        a.setXYZ(49, s.r, s.g, s.b),
        a.needsUpdate = !0
    }
    update() {
        const e = this.geometry
          , t = this.pointMap
          , i = 1
          , r = 1;
        on.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        fn("c", t, e, on, 0, 0, -1),
        fn("t", t, e, on, 0, 0, 1),
        fn("n1", t, e, on, -i, -r, -1),
        fn("n2", t, e, on, i, -r, -1),
        fn("n3", t, e, on, -i, r, -1),
        fn("n4", t, e, on, i, r, -1),
        fn("f1", t, e, on, -i, -r, 1),
        fn("f2", t, e, on, i, -r, 1),
        fn("f3", t, e, on, -i, r, 1),
        fn("f4", t, e, on, i, r, 1),
        fn("u1", t, e, on, i * .7, r * 1.1, -1),
        fn("u2", t, e, on, -i * .7, r * 1.1, -1),
        fn("u3", t, e, on, 0, r * 2, -1),
        fn("cf1", t, e, on, -i, 0, 1),
        fn("cf2", t, e, on, i, 0, 1),
        fn("cf3", t, e, on, 0, -r, 1),
        fn("cf4", t, e, on, 0, r, 1),
        fn("cn1", t, e, on, -i, 0, -1),
        fn("cn2", t, e, on, i, 0, -1),
        fn("cn3", t, e, on, 0, -r, -1),
        fn("cn4", t, e, on, 0, r, -1),
        e.getAttribute("position").needsUpdate = !0
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function fn(n, e, t, i, r, s, o) {
    Cd.set(r, s, o).unproject(i);
    const a = e[n];
    if (a !== void 0) {
        const c = t.getAttribute("position");
        for (let f = 0, h = a.length; f < h; f++)
            c.setXYZ(a[f], Cd.x, Cd.y, Cd.z)
    }
}
const Rd = new di;
class Zk extends Kr {
    constructor(e, t=16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , r = new Float32Array(8 * 3)
          , s = new _t;
        s.setIndex(new Nt(i,1)),
        s.setAttribute("position", new Nt(r,3)),
        super(s, new gi({
            color: t,
            toneMapped: !1
        })),
        this.object = e,
        this.type = "BoxHelper",
        this.matrixAutoUpdate = !1,
        this.update()
    }
    update(e) {
        if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
        this.object !== void 0 && Rd.setFromObject(this.object),
        Rd.isEmpty())
            return;
        const t = Rd.min
          , i = Rd.max
          , r = this.geometry.attributes.position
          , s = r.array;
        s[0] = i.x,
        s[1] = i.y,
        s[2] = i.z,
        s[3] = t.x,
        s[4] = i.y,
        s[5] = i.z,
        s[6] = t.x,
        s[7] = t.y,
        s[8] = i.z,
        s[9] = i.x,
        s[10] = t.y,
        s[11] = i.z,
        s[12] = i.x,
        s[13] = i.y,
        s[14] = t.z,
        s[15] = t.x,
        s[16] = i.y,
        s[17] = t.z,
        s[18] = t.x,
        s[19] = t.y,
        s[20] = t.z,
        s[21] = i.x,
        s[22] = t.y,
        s[23] = t.z,
        r.needsUpdate = !0,
        this.geometry.computeBoundingSphere()
    }
    setFromObject(e) {
        return this.object = e,
        this.update(),
        this
    }
    copy(e, t) {
        return super.copy(e, t),
        this.object = e.object,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class Jk extends Kr {
    constructor(e, t=16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1]
          , s = new _t;
        s.setIndex(new Nt(i,1)),
        s.setAttribute("position", new We(r,3)),
        super(s, new gi({
            color: t,
            toneMapped: !1
        })),
        this.box = e,
        this.type = "Box3Helper",
        this.geometry.computeBoundingSphere()
    }
    updateMatrixWorld(e) {
        const t = this.box;
        t.isEmpty() || (t.getCenter(this.position),
        t.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        super.updateMatrixWorld(e))
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class Kk extends go {
    constructor(e, t=1, i=16776960) {
        const r = i
          , s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0]
          , o = new _t;
        o.setAttribute("position", new We(s,3)),
        o.computeBoundingSphere(),
        super(o, new gi({
            color: r,
            toneMapped: !1
        })),
        this.type = "PlaneHelper",
        this.plane = e,
        this.size = t;
        const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]
          , c = new _t;
        c.setAttribute("position", new We(a,3)),
        c.computeBoundingSphere(),
        this.add(new _n(c,new So({
            color: r,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }
    updateMatrixWorld(e) {
        this.position.set(0, 0, 0),
        this.scale.set(.5 * this.size, .5 * this.size, 1),
        this.lookAt(this.plane.normal),
        this.translateZ(-this.plane.constant),
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose(),
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
}
const Xw = new U;
let bd, B0;
class Qk extends bt {
    constructor(e=new U(0,0,1), t=new U(0,0,0), i=1, r=16776960, s=i * .2, o=s * .2) {
        super(),
        this.type = "ArrowHelper",
        bd === void 0 && (bd = new _t,
        bd.setAttribute("position", new We([0, 0, 0, 0, 1, 0],3)),
        B0 = new lu(0,.5,1,5,1),
        B0.translate(0, -.5, 0)),
        this.position.copy(t),
        this.line = new go(bd,new gi({
            color: r,
            toneMapped: !1
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new _n(B0,new So({
            color: r,
            toneMapped: !1
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(i, s, o)
    }
    setDirection(e) {
        if (e.y > .99999)
            this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -.99999)
            this.quaternion.set(1, 0, 0, 0);
        else {
            Xw.set(e.z, 0, -e.x).normalize();
            const t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(Xw, t)
        }
    }
    setLength(e, t=e * .2, i=t * .2) {
        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(i, t, i),
        this.cone.position.y = e,
        this.cone.updateMatrix()
    }
    setColor(e) {
        this.line.material.color.set(e),
        this.cone.material.color.set(e)
    }
    copy(e) {
        return super.copy(e, !1),
        this.line.copy(e.line),
        this.cone.copy(e.cone),
        this
    }
    dispose() {
        this.line.geometry.dispose(),
        this.line.material.dispose(),
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
}
class $k extends Kr {
    constructor(e=1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
          , r = new _t;
        r.setAttribute("position", new We(t,3)),
        r.setAttribute("color", new We(i,3));
        const s = new gi({
            vertexColors: !0,
            toneMapped: !1
        });
        super(r, s),
        this.type = "AxesHelper"
    }
    setColors(e, t, i) {
        const r = new Ne
          , s = this.geometry.attributes.color.array;
        return r.set(e),
        r.toArray(s, 0),
        r.toArray(s, 3),
        r.set(t),
        r.toArray(s, 6),
        r.toArray(s, 9),
        r.set(i),
        r.toArray(s, 12),
        r.toArray(s, 15),
        this.geometry.attributes.color.needsUpdate = !0,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class gR {
    constructor() {
        this.type = "ShapePath",
        this.color = new Ne,
        this.subPaths = [],
        this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new tf,
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t),
        this
    }
    quadraticCurveTo(e, t, i, r) {
        return this.currentPath.quadraticCurveTo(e, t, i, r),
        this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        return this.currentPath.bezierCurveTo(e, t, i, r, s, o),
        this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e),
        this
    }
    toShapes(e) {
        function t(g) {
            const S = [];
            for (let M = 0, T = g.length; M < T; M++) {
                const P = g[M]
                  , R = new fa;
                R.curves = P.curves,
                S.push(R)
            }
            return S
        }
        function i(g, S) {
            const M = S.length;
            let T = !1;
            for (let P = M - 1, R = 0; R < M; P = R++) {
                let b = S[P]
                  , N = S[R]
                  , G = N.x - b.x
                  , C = N.y - b.y;
                if (Math.abs(C) > Number.EPSILON) {
                    if (C < 0 && (b = S[R],
                    G = -G,
                    N = S[P],
                    C = -C),
                    g.y < b.y || g.y > N.y)
                        continue;
                    if (g.y === b.y) {
                        if (g.x === b.x)
                            return !0
                    } else {
                        const I = C * (g.x - b.x) - G * (g.y - b.y);
                        if (I === 0)
                            return !0;
                        if (I < 0)
                            continue;
                        T = !T
                    }
                } else {
                    if (g.y !== b.y)
                        continue;
                    if (N.x <= g.x && g.x <= b.x || b.x <= g.x && g.x <= N.x)
                        return !0
                }
            }
            return T
        }
        const r = qr.isClockWise
          , s = this.subPaths;
        if (s.length === 0)
            return [];
        let o, a, c;
        const f = [];
        if (s.length === 1)
            return a = s[0],
            c = new fa,
            c.curves = a.curves,
            f.push(c),
            f;
        let h = !r(s[0].getPoints());
        h = e ? !h : h;
        const d = []
          , m = [];
        let v = [], _ = 0, w;
        m[_] = void 0,
        v[_] = [];
        for (let g = 0, S = s.length; g < S; g++)
            a = s[g],
            w = a.getPoints(),
            o = r(w),
            o = e ? !o : o,
            o ? (!h && m[_] && _++,
            m[_] = {
                s: new fa,
                p: w
            },
            m[_].s.curves = a.curves,
            h && _++,
            v[_] = []) : v[_].push({
                h: a,
                p: w[0]
            });
        if (!m[0])
            return t(s);
        if (m.length > 1) {
            let g = !1
              , S = 0;
            for (let M = 0, T = m.length; M < T; M++)
                d[M] = [];
            for (let M = 0, T = m.length; M < T; M++) {
                const P = v[M];
                for (let R = 0; R < P.length; R++) {
                    const b = P[R];
                    let N = !0;
                    for (let G = 0; G < m.length; G++)
                        i(b.p, m[G].p) && (M !== G && S++,
                        N ? (N = !1,
                        d[G].push(b)) : g = !0);
                    N && d[M].push(b)
                }
            }
            S > 0 && g === !1 && (v = d)
        }
        let x;
        for (let g = 0, S = m.length; g < S; g++) {
            c = m[g].s,
            f.push(c),
            x = v[g];
            for (let M = 0, T = x.length; M < T; M++)
                c.holes.push(x[M].h)
        }
        return f
    }
}
class ez extends cr {
    constructor(e=1, t=1, i=1, r={}) {
        console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'),
        super(e, t, {
            ...r,
            count: i
        }),
        this.isWebGLMultipleRenderTargets = !0
    }
    get texture() {
        return this.textures
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: qp
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = qp);
const tz = Object.freeze(Object.defineProperty({
    __proto__: null,
    ACESFilmicToneMapping: Jp,
    AddEquation: Qs,
    AddOperation: P2,
    AdditiveAnimationBlendMode: V_,
    AdditiveBlending: Xv,
    AgXToneMapping: U2,
    AlphaFormat: B2,
    AlwaysCompare: iC,
    AlwaysDepth: w2,
    AlwaysStencilFunc: My,
    AmbientLight: rR,
    AnimationAction: hR,
    AnimationClip: lf,
    AnimationLoader: ik,
    AnimationMixer: Ik,
    AnimationObjectGroup: Pk,
    AnimationUtils: $F,
    ArcCurve: PC,
    ArrayCamera: xC,
    ArrowHelper: Qk,
    AttachedBindMode: Jv,
    Audio: cR,
    AudioAnalyser: xk,
    AudioContext: gx,
    AudioListener: vk,
    AudioLoader: pk,
    AxesHelper: $k,
    BackSide: ti,
    BasicDepthPacking: q2,
    BasicShadowMap: s2,
    BatchedMesh: CC,
    Bone: tx,
    BooleanKeyframeTrack: Ea,
    Box2: kk,
    Box3: di,
    Box3Helper: Jk,
    BoxGeometry: wa,
    BoxHelper: Zk,
    BufferAttribute: Nt,
    BufferGeometry: _t,
    BufferGeometryLoader: uR,
    ByteType: k2,
    Cache: ys,
    Camera: vf,
    CameraHelper: qk,
    CanvasTexture: wF,
    CapsuleGeometry: cm,
    CatmullRomCurve3: LC,
    CineonToneMapping: N2,
    CircleGeometry: fm,
    ClampToEdgeWrapping: ei,
    Clock: vx,
    Color: Ne,
    ColorKeyframeTrack: dx,
    ColorManagement: Ut,
    CompressedArrayTexture: SF,
    CompressedCubeTexture: MF,
    CompressedTexture: lm,
    CompressedTextureLoader: rk,
    ConeGeometry: hm,
    ConstantAlphaFactor: x2,
    ConstantColorFactor: y2,
    CubeCamera: fC,
    CubeReflectionMapping: Ts,
    CubeRefractionMapping: mo,
    CubeTexture: yf,
    CubeTextureLoader: sk,
    CubeUVReflectionMapping: ru,
    CubicBezierCurve: rx,
    CubicBezierCurve3: IC,
    CubicInterpolant: JC,
    CullFaceBack: Wv,
    CullFaceFront: r2,
    CullFaceFrontBack: lL,
    CullFaceNone: i2,
    Curve: Rr,
    CurvePath: DC,
    CustomBlending: o2,
    CustomToneMapping: D2,
    CylinderGeometry: lu,
    Cylindrical: Fk,
    Data3DTexture: Y_,
    DataArrayTexture: tm,
    DataTexture: fo,
    DataTextureLoader: ok,
    DataUtils: mI,
    DecrementStencilOp: _L,
    DecrementWrapStencilOp: SL,
    DefaultLoadingManager: $C,
    DepthFormat: co,
    DepthStencilFormat: ya,
    DepthTexture: nm,
    DetachedBindMode: F2,
    DirectionalLight: iR,
    DirectionalLightHelper: jk,
    DiscreteInterpolant: KC,
    DisplayP3ColorSpace: em,
    DodecahedronGeometry: dm,
    DoubleSide: Vr,
    DstAlphaFactor: d2,
    DstColorFactor: m2,
    DynamicCopyUsage: OL,
    DynamicDrawUsage: PL,
    DynamicReadUsage: NL,
    EdgesGeometry: UC,
    EllipseCurve: um,
    EqualCompare: $2,
    EqualDepth: T2,
    EqualStencilFunc: TL,
    EquirectangularReflectionMapping: Vc,
    EquirectangularRefractionMapping: Gc,
    Euler: Ri,
    EventDispatcher: Rs,
    ExtrudeGeometry: Mf,
    FileLoader: Jr,
    Float16BufferAttribute: SI,
    Float32BufferAttribute: We,
    FloatType: wi,
    Fog: sm,
    FogExp2: rm,
    FramebufferTexture: xF,
    FrontSide: Zr,
    Frustum: _f,
    GLBufferAttribute: Ok,
    GLSL1: kL,
    GLSL3: wy,
    GreaterCompare: eC,
    GreaterDepth: C2,
    GreaterEqualCompare: nC,
    GreaterEqualDepth: A2,
    GreaterEqualStencilFunc: bL,
    GreaterStencilFunc: CL,
    GridHelper: Xk,
    Group: Il,
    HalfFloatType: va,
    HemisphereLight: eR,
    HemisphereLightHelper: Wk,
    IcosahedronGeometry: mm,
    ImageBitmapLoader: dk,
    ImageLoader: uf,
    ImageUtils: X_,
    IncrementStencilOp: yL,
    IncrementWrapStencilOp: xL,
    InstancedBufferAttribute: Ql,
    InstancedBufferGeometry: lR,
    InstancedInterleavedBuffer: Uk,
    InstancedMesh: AC,
    Int16BufferAttribute: _I,
    Int32BufferAttribute: xI,
    Int8BufferAttribute: gI,
    IntType: D_,
    InterleavedBuffer: om,
    InterleavedBufferAttribute: _a,
    Interpolant: Tf,
    InterpolateDiscrete: Yc,
    InterpolateLinear: jc,
    InterpolateSmooth: Jd,
    InvertStencilOp: ML,
    KeepStencilOp: qo,
    KeyframeTrack: br,
    LOD: EC,
    LatheGeometry: Sf,
    Layers: ca,
    LessCompare: Q2,
    LessDepth: E2,
    LessEqualCompare: G_,
    LessEqualDepth: Hc,
    LessEqualStencilFunc: AL,
    LessStencilFunc: EL,
    Light: wo,
    LightProbe: aR,
    Line: go,
    Line3: zk,
    LineBasicMaterial: gi,
    LineCurve: sx,
    LineCurve3: NC,
    LineDashedMaterial: jC,
    LineLoop: RC,
    LineSegments: Kr,
    LinearDisplayP3ColorSpace: gf,
    LinearFilter: Wt,
    LinearInterpolant: hx,
    LinearMipMapLinearFilter: hL,
    LinearMipMapNearestFilter: fL,
    LinearMipmapLinearFilter: Gr,
    LinearMipmapNearestFilter: _c,
    LinearSRGBColorSpace: Cs,
    LinearToneMapping: L2,
    LinearTransfer: Zc,
    Loader: vi,
    LoaderUtils: Ly,
    LoadingManager: px,
    LoopOnce: X2,
    LoopPingPong: j2,
    LoopRepeat: Y2,
    LuminanceAlphaFormat: V2,
    LuminanceFormat: H2,
    MOUSE: oL,
    Material: Gn,
    MaterialLoader: Mm,
    MathUtils: rC,
    Matrix3: mt,
    Matrix4: $e,
    MaxEquation: Zv,
    Mesh: _n,
    MeshBasicMaterial: So,
    MeshDepthMaterial: K_,
    MeshDistanceMaterial: Q_,
    MeshLambertMaterial: XC,
    MeshMatcapMaterial: YC,
    MeshNormalMaterial: WC,
    MeshPhongMaterial: VC,
    MeshPhysicalMaterial: cx,
    MeshStandardMaterial: ux,
    MeshToonMaterial: GC,
    MinEquation: qv,
    MirroredRepeatWrapping: Xc,
    MixOperation: b2,
    MultiplyBlending: jv,
    MultiplyOperation: mf,
    NearestFilter: hn,
    NearestMipMapLinearFilter: cL,
    NearestMipMapNearestFilter: uL,
    NearestMipmapLinearFilter: Jo,
    NearestMipmapNearestFilter: Tp,
    NeutralToneMapping: O2,
    NeverCompare: K2,
    NeverDepth: M2,
    NeverStencilFunc: wL,
    NoBlending: xs,
    NoColorSpace: ds,
    NoToneMapping: Ar,
    NormalAnimationBlendMode: $p,
    NormalBlending: la,
    NotEqualCompare: tC,
    NotEqualDepth: R2,
    NotEqualStencilFunc: RL,
    NumberKeyframeTrack: of,
    Object3D: bt,
    ObjectLoader: fk,
    ObjectSpaceNormalMap: J2,
    OctahedronGeometry: wf,
    OneFactor: c2,
    OneMinusConstantAlphaFactor: S2,
    OneMinusConstantColorFactor: _2,
    OneMinusDstAlphaFactor: p2,
    OneMinusDstColorFactor: g2,
    OneMinusSrcAlphaFactor: Ep,
    OneMinusSrcColorFactor: h2,
    OrthographicCamera: xf,
    P3Primaries: Kc,
    PCFShadowMap: Zp,
    PCFSoftShadowMap: yc,
    PMREMGenerator: Ty,
    Path: tf,
    PerspectiveCamera: Dn,
    Plane: Zs,
    PlaneGeometry: ou,
    PlaneHelper: Kk,
    PointLight: nR,
    PointLightHelper: Vk,
    Points: bC,
    PointsMaterial: nx,
    PolarGridHelper: Yk,
    PolyhedronGeometry: Mo,
    PositionalAudio: _k,
    PropertyBinding: At,
    PropertyMixer: fR,
    QuadraticBezierCurve: ox,
    QuadraticBezierCurve3: ax,
    Quaternion: En,
    QuaternionKeyframeTrack: uu,
    QuaternionLinearInterpolant: QC,
    RED_GREEN_RGTC2_Format: xy,
    RED_RGTC1_Format: W2,
    REVISION: qp,
    RGBADepthPacking: Z2,
    RGBAFormat: ci,
    RGBAIntegerFormat: B_,
    RGBA_ASTC_10x10_Format: py,
    RGBA_ASTC_10x5_Format: fy,
    RGBA_ASTC_10x6_Format: hy,
    RGBA_ASTC_10x8_Format: dy,
    RGBA_ASTC_12x10_Format: my,
    RGBA_ASTC_12x12_Format: gy,
    RGBA_ASTC_4x4_Format: iy,
    RGBA_ASTC_5x4_Format: ry,
    RGBA_ASTC_5x5_Format: sy,
    RGBA_ASTC_6x5_Format: oy,
    RGBA_ASTC_6x6_Format: ay,
    RGBA_ASTC_8x5_Format: ly,
    RGBA_ASTC_8x6_Format: uy,
    RGBA_ASTC_8x8_Format: cy,
    RGBA_BPTC_Format: Zd,
    RGBA_ETC2_EAC_Format: ny,
    RGBA_PVRTC_2BPPV1_Format: ey,
    RGBA_PVRTC_4BPPV1_Format: $v,
    RGBA_S3TC_DXT1_Format: Yd,
    RGBA_S3TC_DXT3_Format: jd,
    RGBA_S3TC_DXT5_Format: qd,
    RGB_BPTC_SIGNED_Format: vy,
    RGB_BPTC_UNSIGNED_Format: yy,
    RGB_ETC1_Format: H_,
    RGB_ETC2_Format: ty,
    RGB_PVRTC_2BPPV1_Format: Qv,
    RGB_PVRTC_4BPPV1_Format: Kv,
    RGB_S3TC_DXT1_Format: Xd,
    RGFormat: G2,
    RGIntegerFormat: z_,
    RawShaderMaterial: HC,
    Ray: su,
    Raycaster: dR,
    Rec709Primaries: Jc,
    RectAreaLight: sR,
    RedFormat: F_,
    RedIntegerFormat: k_,
    ReinhardToneMapping: I2,
    RenderTarget: lC,
    RepeatWrapping: Wc,
    ReplaceStencilOp: vL,
    ReverseSubtractEquation: l2,
    RingGeometry: gm,
    SIGNED_RED_GREEN_RGTC2_Format: Sy,
    SIGNED_RED_RGTC1_Format: _y,
    SRGBColorSpace: Fi,
    SRGBTransfer: Bt,
    Scene: Rp,
    ShaderChunk: yt,
    ShaderLib: wr,
    ShaderMaterial: fr,
    ShadowMaterial: BC,
    Shape: fa,
    ShapeGeometry: vm,
    ShapePath: gR,
    ShapeUtils: qr,
    ShortType: z2,
    Skeleton: am,
    SkeletonHelper: Hk,
    SkinnedMesh: TC,
    Source: ia,
    Sphere: ni,
    SphereGeometry: Ef,
    Spherical: pR,
    SphericalHarmonics3: oR,
    SplineCurve: lx,
    SpotLight: tR,
    SpotLightHelper: Bk,
    Sprite: wC,
    SpriteMaterial: ex,
    SrcAlphaFactor: wp,
    SrcAlphaSaturateFactor: v2,
    SrcColorFactor: f2,
    StaticCopyUsage: UL,
    StaticDrawUsage: Qc,
    StaticReadUsage: IL,
    StereoCamera: mk,
    StreamCopyUsage: FL,
    StreamDrawUsage: LL,
    StreamReadUsage: DL,
    StringKeyframeTrack: Ta,
    SubtractEquation: a2,
    SubtractiveBlending: Yv,
    TOUCH: aL,
    TangentSpaceNormalMap: xo,
    TetrahedronGeometry: ym,
    Texture: en,
    TextureLoader: ak,
    TorusGeometry: _m,
    TorusKnotGeometry: xm,
    Triangle: ki,
    TriangleFanDrawMode: mL,
    TriangleStripDrawMode: pL,
    TrianglesDrawMode: dL,
    TubeGeometry: Sm,
    UVMapping: Kp,
    Uint16BufferAttribute: j_,
    Uint32BufferAttribute: q_,
    Uint8BufferAttribute: vI,
    Uint8ClampedBufferAttribute: yI,
    Uniform: xx,
    UniformsGroup: Dk,
    UniformsLib: Ae,
    UniformsUtils: Z_,
    UnsignedByteType: jr,
    UnsignedInt248Type: uo,
    UnsignedIntType: vs,
    UnsignedShort4444Type: U_,
    UnsignedShort5551Type: O_,
    UnsignedShortType: Qp,
    VSMShadowMap: xr,
    Vector2: he,
    Vector3: U,
    Vector4: Ct,
    VectorKeyframeTrack: af,
    VideoTexture: _F,
    WebGL1Renderer: SC,
    WebGL3DRenderTarget: rI,
    WebGLArrayRenderTarget: iI,
    WebGLCoordinateSystem: Wr,
    WebGLCubeRenderTarget: hC,
    WebGLMultipleRenderTargets: ez,
    WebGLRenderTarget: cr,
    WebGLRenderer: $_,
    WebGLUtils: _C,
    WebGPUCoordinateSystem: $c,
    WireframeGeometry: zC,
    WrapAroundEnding: qc,
    ZeroCurvatureEnding: ta,
    ZeroFactor: u2,
    ZeroSlopeEnding: na,
    ZeroStencilOp: gL,
    _SRGBAFormat: Ap,
    createCanvasElement: oC
}, Symbol.toStringTag, {
    value: "Module"
}));
var nz = `varying vec2 vUv;
uniform float uTime;
uniform vec2 iResolution;

float noise1(float seed1,float seed2);

float noise2(float seed1,float seed2);

float noise2(float seed1,float seed2,float seed3);

float noise3(float seed1,float seed2,float seed3);

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float noise1(float seed1,float seed2){
    return(
    fract(seed1+12.34567*
          fract(100.*(abs(seed1*0.91)+seed2+94.68)*
                fract((abs(seed2*0.41)+45.46)*
                      fract((abs(seed2)+757.21)*
                            fract(seed1*0.0171))))))
    * 1.0038 - 0.00185;
}

float noise2(float seed1,float seed2){
    float buff1 = abs(seed1+100.94) + 1000.;
    float buff2 = abs(seed2+100.73) + 1000.;
    buff1 = (buff1*fract(buff2*fract(buff1*fract(buff2*0.63))));
    buff2 = (buff2*fract(buff2*fract(buff1+buff2*fract(seed1*0.79))));
    buff1 = noise1(buff1, buff2);
    return(buff1 * 1.0038 - 0.00185);
}

float noise2(float seed1,float seed2,float seed3){
    float buff1 = abs(seed1+100.81) + 1000.3;
    float buff2 = abs(seed2+100.45) + 1000.2;
    float buff3 = abs(noise1(seed1, seed2)+seed3) + 1000.1;
    buff1 = (buff3*fract(buff2*fract(buff1*fract(buff2*0.146))));
    buff2 = (buff2*fract(buff2*fract(buff1+buff2*fract(buff3*0.52))));
    buff1 = noise1(buff1, buff2);
    return(buff1);
}

float noise3(float seed1,float seed2,float seed3){
    float buff1 = abs(seed1+100.813) + 1000.314;
    float buff2 = abs(seed2+100.453) + 1000.213;
    float buff3 = abs(noise1(buff2, buff1)+seed3) + 1000.17;
    buff1 = (buff3*fract(buff2*fract(buff1*fract(buff2*0.14619))));
    buff2 = (buff2*fract(buff2*fract(buff1+buff2*fract(buff3*0.5215))));
    buff1 = noise2(noise1(seed2,buff1), noise1(seed1,buff2), noise1(seed3,buff3));
    return(buff1);
}

void main() {
    float slowedTime = uTime / 10.0;
    vec2 uv = (.7 * gl_FragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);
    for(float i = 1.0; i < 6.0; i++){
        uv.x += 1.2 / i * cos(i * 0.5 * uv.y + slowedTime);
        uv.y += 0.6 / i * cos(i * 1.4 * uv.x + slowedTime);
    }

    float noise = noise3(gl_FragCoord.x*0.000001, gl_FragCoord.y*0.000001, uTime * 2e-14) * .4;

    float luminosity = abs(sin(slowedTime-uv.y-uv.x));
    gl_FragColor.rgb = vec3(min(.04/luminosity + min(noise * (.06/luminosity), .1), 1.0));
    gl_FragColor.a = 1.0;
}`
  , iz = `varying vec2 vUv;

void main() {
    vUv = uv;
    gl_Position = projectionMatrix  * viewMatrix * modelMatrix * vec4(position, 1.0);
}`
  , vR = {
    exports: {}
}
  , Aa = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Aa.ConcurrentRoot = 1;
Aa.ContinuousEventPriority = 4;
Aa.DefaultEventPriority = 16;
Aa.DiscreteEventPriority = 1;
Aa.IdleEventPriority = 536870912;
Aa.LegacyRoot = 0;
vR.exports = Aa;
var Dl = vR.exports;
function rz(n) {
    let e;
    const t = new Set
      , i = (f,h)=>{
        const d = typeof f == "function" ? f(e) : f;
        if (d !== e) {
            const m = e;
            e = h ? d : Object.assign({}, e, d),
            t.forEach(v=>v(e, m))
        }
    }
      , r = ()=>e
      , s = (f,h=r,d=Object.is)=>{
        console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
        let m = h(e);
        function v() {
            const _ = h(e);
            if (!d(m, _)) {
                const w = m;
                f(m = _, w)
            }
        }
        return t.add(v),
        ()=>t.delete(v)
    }
      , c = {
        setState: i,
        getState: r,
        subscribe: (f,h,d)=>h || d ? s(f, h, d) : (t.add(f),
        ()=>t.delete(f)),
        destroy: ()=>t.clear()
    };
    return e = n(i, r, c),
    c
}
const sz = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent)
  , Yw = sz ? ve.useEffect : ve.useLayoutEffect;
function oz(n) {
    const e = typeof n == "function" ? rz(n) : n
      , t = (i=e.getState,r=Object.is)=>{
        const [,s] = ve.useReducer(x=>x + 1, 0)
          , o = e.getState()
          , a = ve.useRef(o)
          , c = ve.useRef(i)
          , f = ve.useRef(r)
          , h = ve.useRef(!1)
          , d = ve.useRef();
        d.current === void 0 && (d.current = i(o));
        let m, v = !1;
        (a.current !== o || c.current !== i || f.current !== r || h.current) && (m = i(o),
        v = !r(d.current, m)),
        Yw(()=>{
            v && (d.current = m),
            a.current = o,
            c.current = i,
            f.current = r,
            h.current = !1
        }
        );
        const _ = ve.useRef(o);
        Yw(()=>{
            const x = ()=>{
                try {
                    const S = e.getState()
                      , M = c.current(S);
                    f.current(d.current, M) || (a.current = S,
                    d.current = M,
                    s())
                } catch {
                    h.current = !0,
                    s()
                }
            }
              , g = e.subscribe(x);
            return e.getState() !== _.current && x(),
            g
        }
        , []);
        const w = v ? m : d.current;
        return ve.useDebugValue(w),
        w
    }
    ;
    return Object.assign(t, e),
    t[Symbol.iterator] = function() {
        console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
        const i = [t, e];
        return {
            next() {
                const r = i.length <= 0;
                return {
                    value: i.shift(),
                    done: r
                }
            }
        }
    }
    ,
    t
}
var yR = {
    exports: {}
}
  , _R = {
    exports: {}
}
  , xR = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
    function e(F, H) {
        var V = F.length;
        F.push(H);
        e: for (; 0 < V; ) {
            var q = V - 1 >>> 1
              , ce = F[q];
            if (0 < r(ce, H))
                F[q] = H,
                F[V] = ce,
                V = q;
            else
                break e
        }
    }
    function t(F) {
        return F.length === 0 ? null : F[0]
    }
    function i(F) {
        if (F.length === 0)
            return null;
        var H = F[0]
          , V = F.pop();
        if (V !== H) {
            F[0] = V;
            e: for (var q = 0, ce = F.length, Ce = ce >>> 1; q < Ce; ) {
                var Z = 2 * (q + 1) - 1
                  , de = F[Z]
                  , Se = Z + 1
                  , ke = F[Se];
                if (0 > r(de, V))
                    Se < ce && 0 > r(ke, de) ? (F[q] = ke,
                    F[Se] = V,
                    q = Se) : (F[q] = de,
                    F[Z] = V,
                    q = Z);
                else if (Se < ce && 0 > r(ke, V))
                    F[q] = ke,
                    F[Se] = V,
                    q = Se;
                else
                    break e
            }
        }
        return H
    }
    function r(F, H) {
        var V = F.sortIndex - H.sortIndex;
        return V !== 0 ? V : F.id - H.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        n.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , a = o.now();
        n.unstable_now = function() {
            return o.now() - a
        }
    }
    var c = []
      , f = []
      , h = 1
      , d = null
      , m = 3
      , v = !1
      , _ = !1
      , w = !1
      , x = typeof setTimeout == "function" ? setTimeout : null
      , g = typeof clearTimeout == "function" ? clearTimeout : null
      , S = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function M(F) {
        for (var H = t(f); H !== null; ) {
            if (H.callback === null)
                i(f);
            else if (H.startTime <= F)
                i(f),
                H.sortIndex = H.expirationTime,
                e(c, H);
            else
                break;
            H = t(f)
        }
    }
    function T(F) {
        if (w = !1,
        M(F),
        !_)
            if (t(c) !== null)
                _ = !0,
                J(P);
            else {
                var H = t(f);
                H !== null && ue(T, H.startTime - F)
            }
    }
    function P(F, H) {
        _ = !1,
        w && (w = !1,
        g(N),
        N = -1),
        v = !0;
        var V = m;
        try {
            for (M(H),
            d = t(c); d !== null && (!(d.expirationTime > H) || F && !I()); ) {
                var q = d.callback;
                if (typeof q == "function") {
                    d.callback = null,
                    m = d.priorityLevel;
                    var ce = q(d.expirationTime <= H);
                    H = n.unstable_now(),
                    typeof ce == "function" ? d.callback = ce : d === t(c) && i(c),
                    M(H)
                } else
                    i(c);
                d = t(c)
            }
            if (d !== null)
                var Ce = !0;
            else {
                var Z = t(f);
                Z !== null && ue(T, Z.startTime - H),
                Ce = !1
            }
            return Ce
        } finally {
            d = null,
            m = V,
            v = !1
        }
    }
    var R = !1
      , b = null
      , N = -1
      , G = 5
      , C = -1;
    function I() {
        return !(n.unstable_now() - C < G)
    }
    function K() {
        if (b !== null) {
            var F = n.unstable_now();
            C = F;
            var H = !0;
            try {
                H = b(!0, F)
            } finally {
                H ? se() : (R = !1,
                b = null)
            }
        } else
            R = !1
    }
    var se;
    if (typeof S == "function")
        se = function() {
            S(K)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var B = new MessageChannel
          , ie = B.port2;
        B.port1.onmessage = K,
        se = function() {
            ie.postMessage(null)
        }
    } else
        se = function() {
            x(K, 0)
        }
        ;
    function J(F) {
        b = F,
        R || (R = !0,
        se())
    }
    function ue(F, H) {
        N = x(function() {
            F(n.unstable_now())
        }, H)
    }
    n.unstable_IdlePriority = 5,
    n.unstable_ImmediatePriority = 1,
    n.unstable_LowPriority = 4,
    n.unstable_NormalPriority = 3,
    n.unstable_Profiling = null,
    n.unstable_UserBlockingPriority = 2,
    n.unstable_cancelCallback = function(F) {
        F.callback = null
    }
    ,
    n.unstable_continueExecution = function() {
        _ || v || (_ = !0,
        J(P))
    }
    ,
    n.unstable_forceFrameRate = function(F) {
        0 > F || 125 < F ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : G = 0 < F ? Math.floor(1e3 / F) : 5
    }
    ,
    n.unstable_getCurrentPriorityLevel = function() {
        return m
    }
    ,
    n.unstable_getFirstCallbackNode = function() {
        return t(c)
    }
    ,
    n.unstable_next = function(F) {
        switch (m) {
        case 1:
        case 2:
        case 3:
            var H = 3;
            break;
        default:
            H = m
        }
        var V = m;
        m = H;
        try {
            return F()
        } finally {
            m = V
        }
    }
    ,
    n.unstable_pauseExecution = function() {}
    ,
    n.unstable_requestPaint = function() {}
    ,
    n.unstable_runWithPriority = function(F, H) {
        switch (F) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            F = 3
        }
        var V = m;
        m = F;
        try {
            return H()
        } finally {
            m = V
        }
    }
    ,
    n.unstable_scheduleCallback = function(F, H, V) {
        var q = n.unstable_now();
        switch (typeof V == "object" && V !== null ? (V = V.delay,
        V = typeof V == "number" && 0 < V ? q + V : q) : V = q,
        F) {
        case 1:
            var ce = -1;
            break;
        case 2:
            ce = 250;
            break;
        case 5:
            ce = 1073741823;
            break;
        case 4:
            ce = 1e4;
            break;
        default:
            ce = 5e3
        }
        return ce = V + ce,
        F = {
            id: h++,
            callback: H,
            priorityLevel: F,
            startTime: V,
            expirationTime: ce,
            sortIndex: -1
        },
        V > q ? (F.sortIndex = V,
        e(f, F),
        t(c) === null && F === t(f) && (w ? (g(N),
        N = -1) : w = !0,
        ue(T, V - q))) : (F.sortIndex = ce,
        e(c, F),
        _ || v || (_ = !0,
        J(P))),
        F
    }
    ,
    n.unstable_shouldYield = I,
    n.unstable_wrapCallback = function(F) {
        var H = m;
        return function() {
            var V = m;
            m = H;
            try {
                return F.apply(this, arguments)
            } finally {
                m = V
            }
        }
    }
}
)(xR);
_R.exports = xR;
var Ny = _R.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var az = function(e) {
    var t = {}
      , i = ve
      , r = Ny
      , s = Object.assign;
    function o(l) {
        for (var u = "https://reactjs.org/docs/error-decoder.html?invariant=" + l, p = 1; p < arguments.length; p++)
            u += "&args[]=" + encodeURIComponent(arguments[p]);
        return "Minified React error #" + l + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      , c = Symbol.for("react.element")
      , f = Symbol.for("react.portal")
      , h = Symbol.for("react.fragment")
      , d = Symbol.for("react.strict_mode")
      , m = Symbol.for("react.profiler")
      , v = Symbol.for("react.provider")
      , _ = Symbol.for("react.context")
      , w = Symbol.for("react.forward_ref")
      , x = Symbol.for("react.suspense")
      , g = Symbol.for("react.suspense_list")
      , S = Symbol.for("react.memo")
      , M = Symbol.for("react.lazy")
      , T = Symbol.for("react.offscreen")
      , P = Symbol.iterator;
    function R(l) {
        return l === null || typeof l != "object" ? null : (l = P && l[P] || l["@@iterator"],
        typeof l == "function" ? l : null)
    }
    function b(l) {
        if (l == null)
            return null;
        if (typeof l == "function")
            return l.displayName || l.name || null;
        if (typeof l == "string")
            return l;
        switch (l) {
        case h:
            return "Fragment";
        case f:
            return "Portal";
        case m:
            return "Profiler";
        case d:
            return "StrictMode";
        case x:
            return "Suspense";
        case g:
            return "SuspenseList"
        }
        if (typeof l == "object")
            switch (l.$$typeof) {
            case _:
                return (l.displayName || "Context") + ".Consumer";
            case v:
                return (l._context.displayName || "Context") + ".Provider";
            case w:
                var u = l.render;
                return l = l.displayName,
                l || (l = u.displayName || u.name || "",
                l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"),
                l;
            case S:
                return u = l.displayName || null,
                u !== null ? u : b(l.type) || "Memo";
            case M:
                u = l._payload,
                l = l._init;
                try {
                    return b(l(u))
                } catch {}
            }
        return null
    }
    function N(l) {
        var u = l.type;
        switch (l.tag) {
        case 24:
            return "Cache";
        case 9:
            return (u.displayName || "Context") + ".Consumer";
        case 10:
            return (u._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return l = u.render,
            l = l.displayName || l.name || "",
            u.displayName || (l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return u;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return b(u);
        case 8:
            return u === d ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof u == "function")
                return u.displayName || u.name || null;
            if (typeof u == "string")
                return u
        }
        return null
    }
    function G(l) {
        var u = l
          , p = l;
        if (l.alternate)
            for (; u.return; )
                u = u.return;
        else {
            l = u;
            do
                u = l,
                u.flags & 4098 && (p = u.return),
                l = u.return;
            while (l)
        }
        return u.tag === 3 ? p : null
    }
    function C(l) {
        if (G(l) !== l)
            throw Error(o(188))
    }
    function I(l) {
        var u = l.alternate;
        if (!u) {
            if (u = G(l),
            u === null)
                throw Error(o(188));
            return u !== l ? null : l
        }
        for (var p = l, y = u; ; ) {
            var E = p.return;
            if (E === null)
                break;
            var A = E.alternate;
            if (A === null) {
                if (y = E.return,
                y !== null) {
                    p = y;
                    continue
                }
                break
            }
            if (E.child === A.child) {
                for (A = E.child; A; ) {
                    if (A === p)
                        return C(E),
                        l;
                    if (A === y)
                        return C(E),
                        u;
                    A = A.sibling
                }
                throw Error(o(188))
            }
            if (p.return !== y.return)
                p = E,
                y = A;
            else {
                for (var k = !1, W = E.child; W; ) {
                    if (W === p) {
                        k = !0,
                        p = E,
                        y = A;
                        break
                    }
                    if (W === y) {
                        k = !0,
                        y = E,
                        p = A;
                        break
                    }
                    W = W.sibling
                }
                if (!k) {
                    for (W = A.child; W; ) {
                        if (W === p) {
                            k = !0,
                            p = A,
                            y = E;
                            break
                        }
                        if (W === y) {
                            k = !0,
                            y = A,
                            p = E;
                            break
                        }
                        W = W.sibling
                    }
                    if (!k)
                        throw Error(o(189))
                }
            }
            if (p.alternate !== y)
                throw Error(o(190))
        }
        if (p.tag !== 3)
            throw Error(o(188));
        return p.stateNode.current === p ? l : u
    }
    function K(l) {
        return l = I(l),
        l !== null ? se(l) : null
    }
    function se(l) {
        if (l.tag === 5 || l.tag === 6)
            return l;
        for (l = l.child; l !== null; ) {
            var u = se(l);
            if (u !== null)
                return u;
            l = l.sibling
        }
        return null
    }
    function B(l) {
        if (l.tag === 5 || l.tag === 6)
            return l;
        for (l = l.child; l !== null; ) {
            if (l.tag !== 4) {
                var u = B(l);
                if (u !== null)
                    return u
            }
            l = l.sibling
        }
        return null
    }
    var ie = Array.isArray, J = e.getPublicInstance, ue = e.getRootHostContext, F = e.getChildHostContext, H = e.prepareForCommit, V = e.resetAfterCommit, q = e.createInstance, ce = e.appendInitialChild, Ce = e.finalizeInitialChildren, Z = e.prepareUpdate, de = e.shouldSetTextContent, Se = e.createTextInstance, ke = e.scheduleTimeout, Xe = e.cancelTimeout, ze = e.noTimeout, ut = e.isPrimaryRenderer, He = e.supportsMutation, z = e.supportsPersistence, ge = e.supportsHydration, fe = e.getInstanceFromNode, Me = e.preparePortalMount, pe = e.getCurrentEventPriority, Oe = e.detachDeletedInstance, De = e.supportsMicrotasks, Ge = e.scheduleMicrotask, ft = e.supportsTestSelectors, O = e.findFiberRoot, L = e.getBoundingRect, oe = e.getTextContent, le = e.isHiddenSubtree, ye = e.matchAccessibilityRole, me = e.setFocusIfFocusable, st = e.setupIntersectionObserver, et = e.appendChild, Te = e.appendChildToContainer, Re = e.commitTextUpdate, ot = e.commitMount, we = e.commitUpdate, nn = e.insertBefore, St = e.insertInContainerBefore, Ke = e.removeChild, Ye = e.removeChildFromContainer, je = e.resetTextContent, Tt = e.hideInstance, ht = e.hideTextInstance, zt = e.unhideInstance, X = e.unhideTextInstance, be = e.clearContainer, ee = e.cloneInstance, Ee = e.createContainerChildSet, Pe = e.appendChildToContainerChildSet, wt = e.finalizeContainerChildren, Dt = e.replaceContainerChildren, pn = e.cloneHiddenInstance, ri = e.cloneHiddenTextInstance, Ft = e.canHydrateInstance, On = e.canHydrateTextInstance, Xi = e.canHydrateSuspenseInstance, cu = e.isSuspenseInstancePending, fu = e.isSuspenseInstanceFallback, Ca = e.registerSuspenseInstanceRetry, bs = e.getNextHydratableSibling, Ra = e.getFirstHydratableChild, Cf = e.getFirstHydratableChildWithinContainer, Rf = e.getFirstHydratableChildWithinSuspenseInstance, wm = e.hydrateInstance, Em = e.hydrateTextInstance, Tm = e.hydrateSuspenseInstance, D = e.getNextHydratableInstanceAfterSuspenseInstance, j = e.commitHydratedContainer, te = e.commitHydratedSuspenseInstance, ne = e.clearSuspenseBoundary, $ = e.clearSuspenseBoundaryFromContainer, Ue = e.shouldDeleteUnhydratedTailInstances, Ze = e.didNotMatchHydratedContainerTextInstance, tt = e.didNotMatchHydratedTextInstance, nt;
    function at(l) {
        if (nt === void 0)
            try {
                throw Error()
            } catch (p) {
                var u = p.stack.trim().match(/\n( *(at )?)/);
                nt = u && u[1] || ""
            }
        return `
` + nt + l
    }
    var rt = !1;
    function lt(l, u) {
        if (!l || rt)
            return "";
        rt = !0;
        var p = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (u)
                if (u = function() {
                    throw Error()
                }
                ,
                Object.defineProperty(u.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }),
                typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(u, [])
                    } catch (xe) {
                        var y = xe
                    }
                    Reflect.construct(l, [], u)
                } else {
                    try {
                        u.call()
                    } catch (xe) {
                        y = xe
                    }
                    l.call(u.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (xe) {
                    y = xe
                }
                l()
            }
        } catch (xe) {
            if (xe && y && typeof xe.stack == "string") {
                for (var E = xe.stack.split(`
`), A = y.stack.split(`
`), k = E.length - 1, W = A.length - 1; 1 <= k && 0 <= W && E[k] !== A[W]; )
                    W--;
                for (; 1 <= k && 0 <= W; k--,
                W--)
                    if (E[k] !== A[W]) {
                        if (k !== 1 || W !== 1)
                            do
                                if (k--,
                                W--,
                                0 > W || E[k] !== A[W]) {
                                    var ae = `
` + E[k].replace(" at new ", " at ");
                                    return l.displayName && ae.includes("<anonymous>") && (ae = ae.replace("<anonymous>", l.displayName)),
                                    ae
                                }
                            while (1 <= k && 0 <= W);
                        break
                    }
            }
        } finally {
            rt = !1,
            Error.prepareStackTrace = p
        }
        return (l = l ? l.displayName || l.name : "") ? at(l) : ""
    }
    var Zt = Object.prototype.hasOwnProperty
      , Fn = []
      , Vt = -1;
    function Cn(l) {
        return {
            current: l
        }
    }
    function it(l) {
        0 > Vt || (l.current = Fn[Vt],
        Fn[Vt] = null,
        Vt--)
    }
    function Fe(l, u) {
        Vt++,
        Fn[Vt] = l.current,
        l.current = u
    }
    var Yi = {}
      , vt = Cn(Yi)
      , rn = Cn(!1)
      , Pr = Yi;
    function ji(l, u) {
        var p = l.type.contextTypes;
        if (!p)
            return Yi;
        var y = l.stateNode;
        if (y && y.__reactInternalMemoizedUnmaskedChildContext === u)
            return y.__reactInternalMemoizedMaskedChildContext;
        var E = {}, A;
        for (A in p)
            E[A] = u[A];
        return y && (l = l.stateNode,
        l.__reactInternalMemoizedUnmaskedChildContext = u,
        l.__reactInternalMemoizedMaskedChildContext = E),
        E
    }
    function Rn(l) {
        return l = l.childContextTypes,
        l != null
    }
    function un() {
        it(rn),
        it(vt)
    }
    function Lr(l, u, p) {
        if (vt.current !== Yi)
            throw Error(o(168));
        Fe(vt, u),
        Fe(rn, p)
    }
    function ba(l, u, p) {
        var y = l.stateNode;
        if (u = u.childContextTypes,
        typeof y.getChildContext != "function")
            return p;
        y = y.getChildContext();
        for (var E in y)
            if (!(E in u))
                throw Error(o(108, N(l) || "Unknown", E));
        return s({}, p, y)
    }
    function kn(l) {
        return l = (l = l.stateNode) && l.__reactInternalMemoizedMergedChildContext || Yi,
        Pr = vt.current,
        Fe(vt, l),
        Fe(rn, rn.current),
        !0
    }
    function Pa(l, u, p) {
        var y = l.stateNode;
        if (!y)
            throw Error(o(169));
        p ? (l = ba(l, u, Pr),
        y.__reactInternalMemoizedMergedChildContext = l,
        it(rn),
        it(vt),
        Fe(vt, l)) : it(rn),
        Fe(rn, p)
    }
    var bi = Math.clz32 ? Math.clz32 : GR
      , bf = Math.log
      , VR = Math.LN2;
    function GR(l) {
        return l >>>= 0,
        l === 0 ? 32 : 31 - (bf(l) / VR | 0) | 0
    }
    var Pf = 64
      , Lf = 4194304;
    function hu(l) {
        switch (l & -l) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return l & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return l & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return l
        }
    }
    function If(l, u) {
        var p = l.pendingLanes;
        if (p === 0)
            return 0;
        var y = 0
          , E = l.suspendedLanes
          , A = l.pingedLanes
          , k = p & 268435455;
        if (k !== 0) {
            var W = k & ~E;
            W !== 0 ? y = hu(W) : (A &= k,
            A !== 0 && (y = hu(A)))
        } else
            k = p & ~E,
            k !== 0 ? y = hu(k) : A !== 0 && (y = hu(A));
        if (y === 0)
            return 0;
        if (u !== 0 && u !== y && !(u & E) && (E = y & -y,
        A = u & -u,
        E >= A || E === 16 && (A & 4194240) !== 0))
            return u;
        if (y & 4 && (y |= p & 16),
        u = l.entangledLanes,
        u !== 0)
            for (l = l.entanglements,
            u &= y; 0 < u; )
                p = 31 - bi(u),
                E = 1 << p,
                y |= l[p],
                u &= ~E;
        return y
    }
    function WR(l, u) {
        switch (l) {
        case 1:
        case 2:
        case 4:
            return u + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return u + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function XR(l, u) {
        for (var p = l.suspendedLanes, y = l.pingedLanes, E = l.expirationTimes, A = l.pendingLanes; 0 < A; ) {
            var k = 31 - bi(A)
              , W = 1 << k
              , ae = E[k];
            ae === -1 ? (!(W & p) || W & y) && (E[k] = WR(W, u)) : ae <= u && (l.expiredLanes |= W),
            A &= ~W
        }
    }
    function Am(l) {
        return l = l.pendingLanes & -1073741825,
        l !== 0 ? l : l & 1073741824 ? 1073741824 : 0
    }
    function Cm(l) {
        for (var u = [], p = 0; 31 > p; p++)
            u.push(l);
        return u
    }
    function du(l, u, p) {
        l.pendingLanes |= u,
        u !== 536870912 && (l.suspendedLanes = 0,
        l.pingedLanes = 0),
        l = l.eventTimes,
        u = 31 - bi(u),
        l[u] = p
    }
    function YR(l, u) {
        var p = l.pendingLanes & ~u;
        l.pendingLanes = u,
        l.suspendedLanes = 0,
        l.pingedLanes = 0,
        l.expiredLanes &= u,
        l.mutableReadLanes &= u,
        l.entangledLanes &= u,
        u = l.entanglements;
        var y = l.eventTimes;
        for (l = l.expirationTimes; 0 < p; ) {
            var E = 31 - bi(p)
              , A = 1 << E;
            u[E] = 0,
            y[E] = -1,
            l[E] = -1,
            p &= ~A
        }
    }
    function Rm(l, u) {
        var p = l.entangledLanes |= u;
        for (l = l.entanglements; p; ) {
            var y = 31 - bi(p)
              , E = 1 << y;
            E & u | l[y] & u && (l[y] |= u),
            p &= ~E
        }
    }
    var Pt = 0;
    function Rx(l) {
        return l &= -l,
        1 < l ? 4 < l ? l & 268435455 ? 16 : 536870912 : 4 : 1
    }
    var bm = r.unstable_scheduleCallback
      , bx = r.unstable_cancelCallback
      , jR = r.unstable_shouldYield
      , qR = r.unstable_requestPaint
      , bn = r.unstable_now
      , Pm = r.unstable_ImmediatePriority
      , ZR = r.unstable_UserBlockingPriority
      , Lm = r.unstable_NormalPriority
      , JR = r.unstable_IdlePriority
      , Nf = null
      , Ir = null;
    function KR(l) {
        if (Ir && typeof Ir.onCommitFiberRoot == "function")
            try {
                Ir.onCommitFiberRoot(Nf, l, void 0, (l.current.flags & 128) === 128)
            } catch {}
    }
    function QR(l, u) {
        return l === u && (l !== 0 || 1 / l === 1 / u) || l !== l && u !== u
    }
    var Nr = typeof Object.is == "function" ? Object.is : QR
      , Qr = null
      , Df = !1
      , Im = !1;
    function Px(l) {
        Qr === null ? Qr = [l] : Qr.push(l)
    }
    function $R(l) {
        Df = !0,
        Px(l)
    }
    function Dr() {
        if (!Im && Qr !== null) {
            Im = !0;
            var l = 0
              , u = Pt;
            try {
                var p = Qr;
                for (Pt = 1; l < p.length; l++) {
                    var y = p[l];
                    do
                        y = y(!0);
                    while (y !== null)
                }
                Qr = null,
                Df = !1
            } catch (E) {
                throw Qr !== null && (Qr = Qr.slice(l + 1)),
                bm(Pm, Dr),
                E
            } finally {
                Pt = u,
                Im = !1
            }
        }
        return null
    }
    var eb = a.ReactCurrentBatchConfig;
    function Uf(l, u) {
        if (Nr(l, u))
            return !0;
        if (typeof l != "object" || l === null || typeof u != "object" || u === null)
            return !1;
        var p = Object.keys(l)
          , y = Object.keys(u);
        if (p.length !== y.length)
            return !1;
        for (y = 0; y < p.length; y++) {
            var E = p[y];
            if (!Zt.call(u, E) || !Nr(l[E], u[E]))
                return !1
        }
        return !0
    }
    function tb(l) {
        switch (l.tag) {
        case 5:
            return at(l.type);
        case 16:
            return at("Lazy");
        case 13:
            return at("Suspense");
        case 19:
            return at("SuspenseList");
        case 0:
        case 2:
        case 15:
            return l = lt(l.type, !1),
            l;
        case 11:
            return l = lt(l.type.render, !1),
            l;
        case 1:
            return l = lt(l.type, !0),
            l;
        default:
            return ""
        }
    }
    function hr(l, u) {
        if (l && l.defaultProps) {
            u = s({}, u),
            l = l.defaultProps;
            for (var p in l)
                u[p] === void 0 && (u[p] = l[p]);
            return u
        }
        return u
    }
    var Of = Cn(null)
      , Ff = null
      , La = null
      , Nm = null;
    function Dm() {
        Nm = La = Ff = null
    }
    function Lx(l, u, p) {
        ut ? (Fe(Of, u._currentValue),
        u._currentValue = p) : (Fe(Of, u._currentValue2),
        u._currentValue2 = p)
    }
    function Um(l) {
        var u = Of.current;
        it(Of),
        ut ? l._currentValue = u : l._currentValue2 = u
    }
    function Om(l, u, p) {
        for (; l !== null; ) {
            var y = l.alternate;
            if ((l.childLanes & u) !== u ? (l.childLanes |= u,
            y !== null && (y.childLanes |= u)) : y !== null && (y.childLanes & u) !== u && (y.childLanes |= u),
            l === p)
                break;
            l = l.return
        }
    }
    function Ia(l, u) {
        Ff = l,
        Nm = La = null,
        l = l.dependencies,
        l !== null && l.firstContext !== null && (l.lanes & u && (Ii = !0),
        l.firstContext = null)
    }
    function qi(l) {
        var u = ut ? l._currentValue : l._currentValue2;
        if (Nm !== l)
            if (l = {
                context: l,
                memoizedValue: u,
                next: null
            },
            La === null) {
                if (Ff === null)
                    throw Error(o(308));
                La = l,
                Ff.dependencies = {
                    lanes: 0,
                    firstContext: l
                }
            } else
                La = La.next = l;
        return u
    }
    var Ur = null
      , Ps = !1;
    function Fm(l) {
        l.updateQueue = {
            baseState: l.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }
    function Ix(l, u) {
        l = l.updateQueue,
        u.updateQueue === l && (u.updateQueue = {
            baseState: l.baseState,
            firstBaseUpdate: l.firstBaseUpdate,
            lastBaseUpdate: l.lastBaseUpdate,
            shared: l.shared,
            effects: l.effects
        })
    }
    function $r(l, u) {
        return {
            eventTime: l,
            lane: u,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function Ls(l, u) {
        var p = l.updateQueue;
        p !== null && (p = p.shared,
        mn !== null && l.mode & 1 && !(Mt & 2) ? (l = p.interleaved,
        l === null ? (u.next = u,
        Ur === null ? Ur = [p] : Ur.push(p)) : (u.next = l.next,
        l.next = u),
        p.interleaved = u) : (l = p.pending,
        l === null ? u.next = u : (u.next = l.next,
        l.next = u),
        p.pending = u))
    }
    function kf(l, u, p) {
        if (u = u.updateQueue,
        u !== null && (u = u.shared,
        (p & 4194240) !== 0)) {
            var y = u.lanes;
            y &= l.pendingLanes,
            p |= y,
            u.lanes = p,
            Rm(l, p)
        }
    }
    function Nx(l, u) {
        var p = l.updateQueue
          , y = l.alternate;
        if (y !== null && (y = y.updateQueue,
        p === y)) {
            var E = null
              , A = null;
            if (p = p.firstBaseUpdate,
            p !== null) {
                do {
                    var k = {
                        eventTime: p.eventTime,
                        lane: p.lane,
                        tag: p.tag,
                        payload: p.payload,
                        callback: p.callback,
                        next: null
                    };
                    A === null ? E = A = k : A = A.next = k,
                    p = p.next
                } while (p !== null);
                A === null ? E = A = u : A = A.next = u
            } else
                E = A = u;
            p = {
                baseState: y.baseState,
                firstBaseUpdate: E,
                lastBaseUpdate: A,
                shared: y.shared,
                effects: y.effects
            },
            l.updateQueue = p;
            return
        }
        l = p.lastBaseUpdate,
        l === null ? p.firstBaseUpdate = u : l.next = u,
        p.lastBaseUpdate = u
    }
    function zf(l, u, p, y) {
        var E = l.updateQueue;
        Ps = !1;
        var A = E.firstBaseUpdate
          , k = E.lastBaseUpdate
          , W = E.shared.pending;
        if (W !== null) {
            E.shared.pending = null;
            var ae = W
              , xe = ae.next;
            ae.next = null,
            k === null ? A = xe : k.next = xe,
            k = ae;
            var Ve = l.alternate;
            Ve !== null && (Ve = Ve.updateQueue,
            W = Ve.lastBaseUpdate,
            W !== k && (W === null ? Ve.firstBaseUpdate = xe : W.next = xe,
            Ve.lastBaseUpdate = ae))
        }
        if (A !== null) {
            var dt = E.baseState;
            k = 0,
            Ve = xe = ae = null,
            W = A;
            do {
                var Qe = W.lane
                  , kt = W.eventTime;
                if ((y & Qe) === Qe) {
                    Ve !== null && (Ve = Ve.next = {
                        eventTime: kt,
                        lane: 0,
                        tag: W.tag,
                        payload: W.payload,
                        callback: W.callback,
                        next: null
                    });
                    e: {
                        var Je = l
                          , jn = W;
                        switch (Qe = u,
                        kt = p,
                        jn.tag) {
                        case 1:
                            if (Je = jn.payload,
                            typeof Je == "function") {
                                dt = Je.call(kt, dt, Qe);
                                break e
                            }
                            dt = Je;
                            break e;
                        case 3:
                            Je.flags = Je.flags & -65537 | 128;
                        case 0:
                            if (Je = jn.payload,
                            Qe = typeof Je == "function" ? Je.call(kt, dt, Qe) : Je,
                            Qe == null)
                                break e;
                            dt = s({}, dt, Qe);
                            break e;
                        case 2:
                            Ps = !0
                        }
                    }
                    W.callback !== null && W.lane !== 0 && (l.flags |= 64,
                    Qe = E.effects,
                    Qe === null ? E.effects = [W] : Qe.push(W))
                } else
                    kt = {
                        eventTime: kt,
                        lane: Qe,
                        tag: W.tag,
                        payload: W.payload,
                        callback: W.callback,
                        next: null
                    },
                    Ve === null ? (xe = Ve = kt,
                    ae = dt) : Ve = Ve.next = kt,
                    k |= Qe;
                if (W = W.next,
                W === null) {
                    if (W = E.shared.pending,
                    W === null)
                        break;
                    Qe = W,
                    W = Qe.next,
                    Qe.next = null,
                    E.lastBaseUpdate = Qe,
                    E.shared.pending = null
                }
            } while (!0);
            if (Ve === null && (ae = dt),
            E.baseState = ae,
            E.firstBaseUpdate = xe,
            E.lastBaseUpdate = Ve,
            u = E.shared.interleaved,
            u !== null) {
                E = u;
                do
                    k |= E.lane,
                    E = E.next;
                while (E !== u)
            } else
                A === null && (E.shared.lanes = 0);
            Ha |= k,
            l.lanes = k,
            l.memoizedState = dt
        }
    }
    function Dx(l, u, p) {
        if (l = u.effects,
        u.effects = null,
        l !== null)
            for (u = 0; u < l.length; u++) {
                var y = l[u]
                  , E = y.callback;
                if (E !== null) {
                    if (y.callback = null,
                    y = p,
                    typeof E != "function")
                        throw Error(o(191, E));
                    E.call(y)
                }
            }
    }
    var Ux = new i.Component().refs;
    function km(l, u, p, y) {
        u = l.memoizedState,
        p = p(y, u),
        p = p == null ? u : s({}, u, p),
        l.memoizedState = p,
        l.lanes === 0 && (l.updateQueue.baseState = p)
    }
    var Bf = {
        isMounted: function(l) {
            return (l = l._reactInternals) ? G(l) === l : !1
        },
        enqueueSetState: function(l, u, p) {
            l = l._reactInternals;
            var y = oi()
              , E = Ds(l)
              , A = $r(y, E);
            A.payload = u,
            p != null && (A.callback = p),
            Ls(l, A),
            u = $i(l, E, y),
            u !== null && kf(u, l, E)
        },
        enqueueReplaceState: function(l, u, p) {
            l = l._reactInternals;
            var y = oi()
              , E = Ds(l)
              , A = $r(y, E);
            A.tag = 1,
            A.payload = u,
            p != null && (A.callback = p),
            Ls(l, A),
            u = $i(l, E, y),
            u !== null && kf(u, l, E)
        },
        enqueueForceUpdate: function(l, u) {
            l = l._reactInternals;
            var p = oi()
              , y = Ds(l)
              , E = $r(p, y);
            E.tag = 2,
            u != null && (E.callback = u),
            Ls(l, E),
            u = $i(l, y, p),
            u !== null && kf(u, l, y)
        }
    };
    function Ox(l, u, p, y, E, A, k) {
        return l = l.stateNode,
        typeof l.shouldComponentUpdate == "function" ? l.shouldComponentUpdate(y, A, k) : u.prototype && u.prototype.isPureReactComponent ? !Uf(p, y) || !Uf(E, A) : !0
    }
    function Fx(l, u, p) {
        var y = !1
          , E = Yi
          , A = u.contextType;
        return typeof A == "object" && A !== null ? A = qi(A) : (E = Rn(u) ? Pr : vt.current,
        y = u.contextTypes,
        A = (y = y != null) ? ji(l, E) : Yi),
        u = new u(p,A),
        l.memoizedState = u.state !== null && u.state !== void 0 ? u.state : null,
        u.updater = Bf,
        l.stateNode = u,
        u._reactInternals = l,
        y && (l = l.stateNode,
        l.__reactInternalMemoizedUnmaskedChildContext = E,
        l.__reactInternalMemoizedMaskedChildContext = A),
        u
    }
    function kx(l, u, p, y) {
        l = u.state,
        typeof u.componentWillReceiveProps == "function" && u.componentWillReceiveProps(p, y),
        typeof u.UNSAFE_componentWillReceiveProps == "function" && u.UNSAFE_componentWillReceiveProps(p, y),
        u.state !== l && Bf.enqueueReplaceState(u, u.state, null)
    }
    function zm(l, u, p, y) {
        var E = l.stateNode;
        E.props = p,
        E.state = l.memoizedState,
        E.refs = Ux,
        Fm(l);
        var A = u.contextType;
        typeof A == "object" && A !== null ? E.context = qi(A) : (A = Rn(u) ? Pr : vt.current,
        E.context = ji(l, A)),
        E.state = l.memoizedState,
        A = u.getDerivedStateFromProps,
        typeof A == "function" && (km(l, u, A, p),
        E.state = l.memoizedState),
        typeof u.getDerivedStateFromProps == "function" || typeof E.getSnapshotBeforeUpdate == "function" || typeof E.UNSAFE_componentWillMount != "function" && typeof E.componentWillMount != "function" || (u = E.state,
        typeof E.componentWillMount == "function" && E.componentWillMount(),
        typeof E.UNSAFE_componentWillMount == "function" && E.UNSAFE_componentWillMount(),
        u !== E.state && Bf.enqueueReplaceState(E, E.state, null),
        zf(l, p, E, y),
        E.state = l.memoizedState),
        typeof E.componentDidMount == "function" && (l.flags |= 4194308)
    }
    var Na = []
      , Da = 0
      , Hf = null
      , Vf = 0
      , Zi = []
      , Ji = 0
      , Eo = null
      , es = 1
      , ts = "";
    function To(l, u) {
        Na[Da++] = Vf,
        Na[Da++] = Hf,
        Hf = l,
        Vf = u
    }
    function zx(l, u, p) {
        Zi[Ji++] = es,
        Zi[Ji++] = ts,
        Zi[Ji++] = Eo,
        Eo = l;
        var y = es;
        l = ts;
        var E = 32 - bi(y) - 1;
        y &= ~(1 << E),
        p += 1;
        var A = 32 - bi(u) + E;
        if (30 < A) {
            var k = E - E % 5;
            A = (y & (1 << k) - 1).toString(32),
            y >>= k,
            E -= k,
            es = 1 << 32 - bi(u) + E | p << E | y,
            ts = A + l
        } else
            es = 1 << A | p << E | y,
            ts = l
    }
    function Bm(l) {
        l.return !== null && (To(l, 1),
        zx(l, 1, 0))
    }
    function Hm(l) {
        for (; l === Hf; )
            Hf = Na[--Da],
            Na[Da] = null,
            Vf = Na[--Da],
            Na[Da] = null;
        for (; l === Eo; )
            Eo = Zi[--Ji],
            Zi[Ji] = null,
            ts = Zi[--Ji],
            Zi[Ji] = null,
            es = Zi[--Ji],
            Zi[Ji] = null
    }
    var Pi = null
      , Li = null
      , Yt = !1
      , pu = !1
      , dr = null;
    function Bx(l, u) {
        var p = er(5, null, null, 0);
        p.elementType = "DELETED",
        p.stateNode = u,
        p.return = l,
        u = l.deletions,
        u === null ? (l.deletions = [p],
        l.flags |= 16) : u.push(p)
    }
    function Hx(l, u) {
        switch (l.tag) {
        case 5:
            return u = Ft(u, l.type, l.pendingProps),
            u !== null ? (l.stateNode = u,
            Pi = l,
            Li = Ra(u),
            !0) : !1;
        case 6:
            return u = On(u, l.pendingProps),
            u !== null ? (l.stateNode = u,
            Pi = l,
            Li = null,
            !0) : !1;
        case 13:
            if (u = Xi(u),
            u !== null) {
                var p = Eo !== null ? {
                    id: es,
                    overflow: ts
                } : null;
                return l.memoizedState = {
                    dehydrated: u,
                    treeContext: p,
                    retryLane: 1073741824
                },
                p = er(18, null, null, 0),
                p.stateNode = u,
                p.return = l,
                l.child = p,
                Pi = l,
                Li = null,
                !0
            }
            return !1;
        default:
            return !1
        }
    }
    function Vm(l) {
        return (l.mode & 1) !== 0 && (l.flags & 128) === 0
    }
    function Gm(l) {
        if (Yt) {
            var u = Li;
            if (u) {
                var p = u;
                if (!Hx(l, u)) {
                    if (Vm(l))
                        throw Error(o(418));
                    u = bs(p);
                    var y = Pi;
                    u && Hx(l, u) ? Bx(y, p) : (l.flags = l.flags & -4097 | 2,
                    Yt = !1,
                    Pi = l)
                }
            } else {
                if (Vm(l))
                    throw Error(o(418));
                l.flags = l.flags & -4097 | 2,
                Yt = !1,
                Pi = l
            }
        }
    }
    function Vx(l) {
        for (l = l.return; l !== null && l.tag !== 5 && l.tag !== 3 && l.tag !== 13; )
            l = l.return;
        Pi = l
    }
    function mu(l) {
        if (!ge || l !== Pi)
            return !1;
        if (!Yt)
            return Vx(l),
            Yt = !0,
            !1;
        if (l.tag !== 3 && (l.tag !== 5 || Ue(l.type) && !de(l.type, l.memoizedProps))) {
            var u = Li;
            if (u) {
                if (Vm(l)) {
                    for (l = Li; l; )
                        l = bs(l);
                    throw Error(o(418))
                }
                for (; u; )
                    Bx(l, u),
                    u = bs(u)
            }
        }
        if (Vx(l),
        l.tag === 13) {
            if (!ge)
                throw Error(o(316));
            if (l = l.memoizedState,
            l = l !== null ? l.dehydrated : null,
            !l)
                throw Error(o(317));
            Li = D(l)
        } else
            Li = Pi ? bs(l.stateNode) : null;
        return !0
    }
    function Ua() {
        ge && (Li = Pi = null,
        pu = Yt = !1)
    }
    function Wm(l) {
        dr === null ? dr = [l] : dr.push(l)
    }
    function gu(l, u, p) {
        if (l = p.ref,
        l !== null && typeof l != "function" && typeof l != "object") {
            if (p._owner) {
                if (p = p._owner,
                p) {
                    if (p.tag !== 1)
                        throw Error(o(309));
                    var y = p.stateNode
                }
                if (!y)
                    throw Error(o(147, l));
                var E = y
                  , A = "" + l;
                return u !== null && u.ref !== null && typeof u.ref == "function" && u.ref._stringRef === A ? u.ref : (u = function(k) {
                    var W = E.refs;
                    W === Ux && (W = E.refs = {}),
                    k === null ? delete W[A] : W[A] = k
                }
                ,
                u._stringRef = A,
                u)
            }
            if (typeof l != "string")
                throw Error(o(284));
            if (!p._owner)
                throw Error(o(290, l))
        }
        return l
    }
    function Gf(l, u) {
        throw l = Object.prototype.toString.call(u),
        Error(o(31, l === "[object Object]" ? "object with keys {" + Object.keys(u).join(", ") + "}" : l))
    }
    function Gx(l) {
        var u = l._init;
        return u(l._payload)
    }
    function Wx(l) {
        function u(Q, Y) {
            if (l) {
                var re = Q.deletions;
                re === null ? (Q.deletions = [Y],
                Q.flags |= 16) : re.push(Y)
            }
        }
        function p(Q, Y) {
            if (!l)
                return null;
            for (; Y !== null; )
                u(Q, Y),
                Y = Y.sibling;
            return null
        }
        function y(Q, Y) {
            for (Q = new Map; Y !== null; )
                Y.key !== null ? Q.set(Y.key, Y) : Q.set(Y.index, Y),
                Y = Y.sibling;
            return Q
        }
        function E(Q, Y) {
            return Q = Os(Q, Y),
            Q.index = 0,
            Q.sibling = null,
            Q
        }
        function A(Q, Y, re) {
            return Q.index = re,
            l ? (re = Q.alternate,
            re !== null ? (re = re.index,
            re < Y ? (Q.flags |= 2,
            Y) : re) : (Q.flags |= 2,
            Y)) : (Q.flags |= 1048576,
            Y)
        }
        function k(Q) {
            return l && Q.alternate === null && (Q.flags |= 2),
            Q
        }
        function W(Q, Y, re, Ie) {
            return Y === null || Y.tag !== 6 ? (Y = Cg(re, Q.mode, Ie),
            Y.return = Q,
            Y) : (Y = E(Y, re),
            Y.return = Q,
            Y)
        }
        function ae(Q, Y, re, Ie) {
            var qe = re.type;
            return qe === h ? Ve(Q, Y, re.props.children, Ie, re.key) : Y !== null && (Y.elementType === qe || typeof qe == "object" && qe !== null && qe.$$typeof === M && Gx(qe) === Y.type) ? (Ie = E(Y, re.props),
            Ie.ref = gu(Q, Y, re),
            Ie.return = Q,
            Ie) : (Ie = xh(re.type, re.key, re.props, null, Q.mode, Ie),
            Ie.ref = gu(Q, Y, re),
            Ie.return = Q,
            Ie)
        }
        function xe(Q, Y, re, Ie) {
            return Y === null || Y.tag !== 4 || Y.stateNode.containerInfo !== re.containerInfo || Y.stateNode.implementation !== re.implementation ? (Y = Rg(re, Q.mode, Ie),
            Y.return = Q,
            Y) : (Y = E(Y, re.children || []),
            Y.return = Q,
            Y)
        }
        function Ve(Q, Y, re, Ie, qe) {
            return Y === null || Y.tag !== 7 ? (Y = Io(re, Q.mode, Ie, qe),
            Y.return = Q,
            Y) : (Y = E(Y, re),
            Y.return = Q,
            Y)
        }
        function dt(Q, Y, re) {
            if (typeof Y == "string" && Y !== "" || typeof Y == "number")
                return Y = Cg("" + Y, Q.mode, re),
                Y.return = Q,
                Y;
            if (typeof Y == "object" && Y !== null) {
                switch (Y.$$typeof) {
                case c:
                    return re = xh(Y.type, Y.key, Y.props, null, Q.mode, re),
                    re.ref = gu(Q, null, Y),
                    re.return = Q,
                    re;
                case f:
                    return Y = Rg(Y, Q.mode, re),
                    Y.return = Q,
                    Y;
                case M:
                    var Ie = Y._init;
                    return dt(Q, Ie(Y._payload), re)
                }
                if (ie(Y) || R(Y))
                    return Y = Io(Y, Q.mode, re, null),
                    Y.return = Q,
                    Y;
                Gf(Q, Y)
            }
            return null
        }
        function Qe(Q, Y, re, Ie) {
            var qe = Y !== null ? Y.key : null;
            if (typeof re == "string" && re !== "" || typeof re == "number")
                return qe !== null ? null : W(Q, Y, "" + re, Ie);
            if (typeof re == "object" && re !== null) {
                switch (re.$$typeof) {
                case c:
                    return re.key === qe ? ae(Q, Y, re, Ie) : null;
                case f:
                    return re.key === qe ? xe(Q, Y, re, Ie) : null;
                case M:
                    return qe = re._init,
                    Qe(Q, Y, qe(re._payload), Ie)
                }
                if (ie(re) || R(re))
                    return qe !== null ? null : Ve(Q, Y, re, Ie, null);
                Gf(Q, re)
            }
            return null
        }
        function kt(Q, Y, re, Ie, qe) {
            if (typeof Ie == "string" && Ie !== "" || typeof Ie == "number")
                return Q = Q.get(re) || null,
                W(Y, Q, "" + Ie, qe);
            if (typeof Ie == "object" && Ie !== null) {
                switch (Ie.$$typeof) {
                case c:
                    return Q = Q.get(Ie.key === null ? re : Ie.key) || null,
                    ae(Y, Q, Ie, qe);
                case f:
                    return Q = Q.get(Ie.key === null ? re : Ie.key) || null,
                    xe(Y, Q, Ie, qe);
                case M:
                    var xt = Ie._init;
                    return kt(Q, Y, re, xt(Ie._payload), qe)
                }
                if (ie(Ie) || R(Ie))
                    return Q = Q.get(re) || null,
                    Ve(Y, Q, Ie, qe, null);
                Gf(Y, Ie)
            }
            return null
        }
        function Je(Q, Y, re, Ie) {
            for (var qe = null, xt = null, pt = Y, Lt = Y = 0, Ln = null; pt !== null && Lt < re.length; Lt++) {
                pt.index > Lt ? (Ln = pt,
                pt = null) : Ln = pt.sibling;
                var It = Qe(Q, pt, re[Lt], Ie);
                if (It === null) {
                    pt === null && (pt = Ln);
                    break
                }
                l && pt && It.alternate === null && u(Q, pt),
                Y = A(It, Y, Lt),
                xt === null ? qe = It : xt.sibling = It,
                xt = It,
                pt = Ln
            }
            if (Lt === re.length)
                return p(Q, pt),
                Yt && To(Q, Lt),
                qe;
            if (pt === null) {
                for (; Lt < re.length; Lt++)
                    pt = dt(Q, re[Lt], Ie),
                    pt !== null && (Y = A(pt, Y, Lt),
                    xt === null ? qe = pt : xt.sibling = pt,
                    xt = pt);
                return Yt && To(Q, Lt),
                qe
            }
            for (pt = y(Q, pt); Lt < re.length; Lt++)
                Ln = kt(pt, Q, Lt, re[Lt], Ie),
                Ln !== null && (l && Ln.alternate !== null && pt.delete(Ln.key === null ? Lt : Ln.key),
                Y = A(Ln, Y, Lt),
                xt === null ? qe = Ln : xt.sibling = Ln,
                xt = Ln);
            return l && pt.forEach(function(Fs) {
                return u(Q, Fs)
            }),
            Yt && To(Q, Lt),
            qe
        }
        function jn(Q, Y, re, Ie) {
            var qe = R(re);
            if (typeof qe != "function")
                throw Error(o(150));
            if (re = qe.call(re),
            re == null)
                throw Error(o(151));
            for (var xt = qe = null, pt = Y, Lt = Y = 0, Ln = null, It = re.next(); pt !== null && !It.done; Lt++,
            It = re.next()) {
                pt.index > Lt ? (Ln = pt,
                pt = null) : Ln = pt.sibling;
                var Fs = Qe(Q, pt, It.value, Ie);
                if (Fs === null) {
                    pt === null && (pt = Ln);
                    break
                }
                l && pt && Fs.alternate === null && u(Q, pt),
                Y = A(Fs, Y, Lt),
                xt === null ? qe = Fs : xt.sibling = Fs,
                xt = Fs,
                pt = Ln
            }
            if (It.done)
                return p(Q, pt),
                Yt && To(Q, Lt),
                qe;
            if (pt === null) {
                for (; !It.done; Lt++,
                It = re.next())
                    It = dt(Q, It.value, Ie),
                    It !== null && (Y = A(It, Y, Lt),
                    xt === null ? qe = It : xt.sibling = It,
                    xt = It);
                return Yt && To(Q, Lt),
                qe
            }
            for (pt = y(Q, pt); !It.done; Lt++,
            It = re.next())
                It = kt(pt, Q, Lt, It.value, Ie),
                It !== null && (l && It.alternate !== null && pt.delete(It.key === null ? Lt : It.key),
                Y = A(It, Y, Lt),
                xt === null ? qe = It : xt.sibling = It,
                xt = It);
            return l && pt.forEach(function(Lb) {
                return u(Q, Lb)
            }),
            Yt && To(Q, Lt),
            qe
        }
        function tr(Q, Y, re, Ie) {
            if (typeof re == "object" && re !== null && re.type === h && re.key === null && (re = re.props.children),
            typeof re == "object" && re !== null) {
                switch (re.$$typeof) {
                case c:
                    e: {
                        for (var qe = re.key, xt = Y; xt !== null; ) {
                            if (xt.key === qe) {
                                if (qe = re.type,
                                qe === h) {
                                    if (xt.tag === 7) {
                                        p(Q, xt.sibling),
                                        Y = E(xt, re.props.children),
                                        Y.return = Q,
                                        Q = Y;
                                        break e
                                    }
                                } else if (xt.elementType === qe || typeof qe == "object" && qe !== null && qe.$$typeof === M && Gx(qe) === xt.type) {
                                    p(Q, xt.sibling),
                                    Y = E(xt, re.props),
                                    Y.ref = gu(Q, xt, re),
                                    Y.return = Q,
                                    Q = Y;
                                    break e
                                }
                                p(Q, xt);
                                break
                            } else
                                u(Q, xt);
                            xt = xt.sibling
                        }
                        re.type === h ? (Y = Io(re.props.children, Q.mode, Ie, re.key),
                        Y.return = Q,
                        Q = Y) : (Ie = xh(re.type, re.key, re.props, null, Q.mode, Ie),
                        Ie.ref = gu(Q, Y, re),
                        Ie.return = Q,
                        Q = Ie)
                    }
                    return k(Q);
                case f:
                    e: {
                        for (xt = re.key; Y !== null; ) {
                            if (Y.key === xt)
                                if (Y.tag === 4 && Y.stateNode.containerInfo === re.containerInfo && Y.stateNode.implementation === re.implementation) {
                                    p(Q, Y.sibling),
                                    Y = E(Y, re.children || []),
                                    Y.return = Q,
                                    Q = Y;
                                    break e
                                } else {
                                    p(Q, Y);
                                    break
                                }
                            else
                                u(Q, Y);
                            Y = Y.sibling
                        }
                        Y = Rg(re, Q.mode, Ie),
                        Y.return = Q,
                        Q = Y
                    }
                    return k(Q);
                case M:
                    return xt = re._init,
                    tr(Q, Y, xt(re._payload), Ie)
                }
                if (ie(re))
                    return Je(Q, Y, re, Ie);
                if (R(re))
                    return jn(Q, Y, re, Ie);
                Gf(Q, re)
            }
            return typeof re == "string" && re !== "" || typeof re == "number" ? (re = "" + re,
            Y !== null && Y.tag === 6 ? (p(Q, Y.sibling),
            Y = E(Y, re),
            Y.return = Q,
            Q = Y) : (p(Q, Y),
            Y = Cg(re, Q.mode, Ie),
            Y.return = Q,
            Q = Y),
            k(Q)) : p(Q, Y)
        }
        return tr
    }
    var Oa = Wx(!0)
      , Xx = Wx(!1)
      , vu = {}
      , Ki = Cn(vu)
      , yu = Cn(vu)
      , Fa = Cn(vu);
    function Or(l) {
        if (l === vu)
            throw Error(o(174));
        return l
    }
    function Xm(l, u) {
        Fe(Fa, u),
        Fe(yu, l),
        Fe(Ki, vu),
        l = ue(u),
        it(Ki),
        Fe(Ki, l)
    }
    function ka() {
        it(Ki),
        it(yu),
        it(Fa)
    }
    function Yx(l) {
        var u = Or(Fa.current)
          , p = Or(Ki.current);
        u = F(p, l.type, u),
        p !== u && (Fe(yu, l),
        Fe(Ki, u))
    }
    function Ym(l) {
        yu.current === l && (it(Ki),
        it(yu))
    }
    var Jt = Cn(0);
    function Wf(l) {
        for (var u = l; u !== null; ) {
            if (u.tag === 13) {
                var p = u.memoizedState;
                if (p !== null && (p = p.dehydrated,
                p === null || cu(p) || fu(p)))
                    return u
            } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
                if (u.flags & 128)
                    return u
            } else if (u.child !== null) {
                u.child.return = u,
                u = u.child;
                continue
            }
            if (u === l)
                break;
            for (; u.sibling === null; ) {
                if (u.return === null || u.return === l)
                    return null;
                u = u.return
            }
            u.sibling.return = u.return,
            u = u.sibling
        }
        return null
    }
    var jm = [];
    function qm() {
        for (var l = 0; l < jm.length; l++) {
            var u = jm[l];
            ut ? u._workInProgressVersionPrimary = null : u._workInProgressVersionSecondary = null
        }
        jm.length = 0
    }
    var Xf = a.ReactCurrentDispatcher
      , Qi = a.ReactCurrentBatchConfig
      , za = 0
      , sn = null
      , Wn = null
      , Pn = null
      , Yf = !1
      , _u = !1
      , xu = 0
      , nb = 0;
    function Xn() {
        throw Error(o(321))
    }
    function Zm(l, u) {
        if (u === null)
            return !1;
        for (var p = 0; p < u.length && p < l.length; p++)
            if (!Nr(l[p], u[p]))
                return !1;
        return !0
    }
    function Jm(l, u, p, y, E, A) {
        if (za = A,
        sn = u,
        u.memoizedState = null,
        u.updateQueue = null,
        u.lanes = 0,
        Xf.current = l === null || l.memoizedState === null ? ob : ab,
        l = p(y, E),
        _u) {
            A = 0;
            do {
                if (_u = !1,
                xu = 0,
                25 <= A)
                    throw Error(o(301));
                A += 1,
                Pn = Wn = null,
                u.updateQueue = null,
                Xf.current = lb,
                l = p(y, E)
            } while (_u)
        }
        if (Xf.current = Kf,
        u = Wn !== null && Wn.next !== null,
        za = 0,
        Pn = Wn = sn = null,
        Yf = !1,
        u)
            throw Error(o(300));
        return l
    }
    function Km() {
        var l = xu !== 0;
        return xu = 0,
        l
    }
    function ns() {
        var l = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return Pn === null ? sn.memoizedState = Pn = l : Pn = Pn.next = l,
        Pn
    }
    function Fr() {
        if (Wn === null) {
            var l = sn.alternate;
            l = l !== null ? l.memoizedState : null
        } else
            l = Wn.next;
        var u = Pn === null ? sn.memoizedState : Pn.next;
        if (u !== null)
            Pn = u,
            Wn = l;
        else {
            if (l === null)
                throw Error(o(310));
            Wn = l,
            l = {
                memoizedState: Wn.memoizedState,
                baseState: Wn.baseState,
                baseQueue: Wn.baseQueue,
                queue: Wn.queue,
                next: null
            },
            Pn === null ? sn.memoizedState = Pn = l : Pn = Pn.next = l
        }
        return Pn
    }
    function Ao(l, u) {
        return typeof u == "function" ? u(l) : u
    }
    function jf(l) {
        var u = Fr()
          , p = u.queue;
        if (p === null)
            throw Error(o(311));
        p.lastRenderedReducer = l;
        var y = Wn
          , E = y.baseQueue
          , A = p.pending;
        if (A !== null) {
            if (E !== null) {
                var k = E.next;
                E.next = A.next,
                A.next = k
            }
            y.baseQueue = E = A,
            p.pending = null
        }
        if (E !== null) {
            A = E.next,
            y = y.baseState;
            var W = k = null
              , ae = null
              , xe = A;
            do {
                var Ve = xe.lane;
                if ((za & Ve) === Ve)
                    ae !== null && (ae = ae.next = {
                        lane: 0,
                        action: xe.action,
                        hasEagerState: xe.hasEagerState,
                        eagerState: xe.eagerState,
                        next: null
                    }),
                    y = xe.hasEagerState ? xe.eagerState : l(y, xe.action);
                else {
                    var dt = {
                        lane: Ve,
                        action: xe.action,
                        hasEagerState: xe.hasEagerState,
                        eagerState: xe.eagerState,
                        next: null
                    };
                    ae === null ? (W = ae = dt,
                    k = y) : ae = ae.next = dt,
                    sn.lanes |= Ve,
                    Ha |= Ve
                }
                xe = xe.next
            } while (xe !== null && xe !== A);
            ae === null ? k = y : ae.next = W,
            Nr(y, u.memoizedState) || (Ii = !0),
            u.memoizedState = y,
            u.baseState = k,
            u.baseQueue = ae,
            p.lastRenderedState = y
        }
        if (l = p.interleaved,
        l !== null) {
            E = l;
            do
                A = E.lane,
                sn.lanes |= A,
                Ha |= A,
                E = E.next;
            while (E !== l)
        } else
            E === null && (p.lanes = 0);
        return [u.memoizedState, p.dispatch]
    }
    function qf(l) {
        var u = Fr()
          , p = u.queue;
        if (p === null)
            throw Error(o(311));
        p.lastRenderedReducer = l;
        var y = p.dispatch
          , E = p.pending
          , A = u.memoizedState;
        if (E !== null) {
            p.pending = null;
            var k = E = E.next;
            do
                A = l(A, k.action),
                k = k.next;
            while (k !== E);
            Nr(A, u.memoizedState) || (Ii = !0),
            u.memoizedState = A,
            u.baseQueue === null && (u.baseState = A),
            p.lastRenderedState = A
        }
        return [A, y]
    }
    function jx() {}
    function qx(l, u) {
        var p = sn
          , y = Fr()
          , E = u()
          , A = !Nr(y.memoizedState, E);
        if (A && (y.memoizedState = E,
        Ii = !0),
        y = y.queue,
        Mu(Kx.bind(null, p, y, l), [l]),
        y.getSnapshot !== u || A || Pn !== null && Pn.memoizedState.tag & 1) {
            if (p.flags |= 2048,
            Su(9, Jx.bind(null, p, y, E, u), void 0, null),
            mn === null)
                throw Error(o(349));
            za & 30 || Zx(p, u, E)
        }
        return E
    }
    function Zx(l, u, p) {
        l.flags |= 16384,
        l = {
            getSnapshot: u,
            value: p
        },
        u = sn.updateQueue,
        u === null ? (u = {
            lastEffect: null,
            stores: null
        },
        sn.updateQueue = u,
        u.stores = [l]) : (p = u.stores,
        p === null ? u.stores = [l] : p.push(l))
    }
    function Jx(l, u, p, y) {
        u.value = p,
        u.getSnapshot = y,
        Qx(u) && $i(l, 1, -1)
    }
    function Kx(l, u, p) {
        return p(function() {
            Qx(u) && $i(l, 1, -1)
        })
    }
    function Qx(l) {
        var u = l.getSnapshot;
        l = l.value;
        try {
            var p = u();
            return !Nr(l, p)
        } catch {
            return !0
        }
    }
    function Qm(l) {
        var u = ns();
        return typeof l == "function" && (l = l()),
        u.memoizedState = u.baseState = l,
        l = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Ao,
            lastRenderedState: l
        },
        u.queue = l,
        l = l.dispatch = sb.bind(null, sn, l),
        [u.memoizedState, l]
    }
    function Su(l, u, p, y) {
        return l = {
            tag: l,
            create: u,
            destroy: p,
            deps: y,
            next: null
        },
        u = sn.updateQueue,
        u === null ? (u = {
            lastEffect: null,
            stores: null
        },
        sn.updateQueue = u,
        u.lastEffect = l.next = l) : (p = u.lastEffect,
        p === null ? u.lastEffect = l.next = l : (y = p.next,
        p.next = l,
        l.next = y,
        u.lastEffect = l)),
        l
    }
    function $x() {
        return Fr().memoizedState
    }
    function Zf(l, u, p, y) {
        var E = ns();
        sn.flags |= l,
        E.memoizedState = Su(1 | u, p, void 0, y === void 0 ? null : y)
    }
    function Jf(l, u, p, y) {
        var E = Fr();
        y = y === void 0 ? null : y;
        var A = void 0;
        if (Wn !== null) {
            var k = Wn.memoizedState;
            if (A = k.destroy,
            y !== null && Zm(y, k.deps)) {
                E.memoizedState = Su(u, p, A, y);
                return
            }
        }
        sn.flags |= l,
        E.memoizedState = Su(1 | u, p, A, y)
    }
    function $m(l, u) {
        return Zf(8390656, 8, l, u)
    }
    function Mu(l, u) {
        return Jf(2048, 8, l, u)
    }
    function e1(l, u) {
        return Jf(4, 2, l, u)
    }
    function t1(l, u) {
        return Jf(4, 4, l, u)
    }
    function n1(l, u) {
        if (typeof u == "function")
            return l = l(),
            u(l),
            function() {
                u(null)
            }
            ;
        if (u != null)
            return l = l(),
            u.current = l,
            function() {
                u.current = null
            }
    }
    function i1(l, u, p) {
        return p = p != null ? p.concat([l]) : null,
        Jf(4, 4, n1.bind(null, u, l), p)
    }
    function eg() {}
    function r1(l, u) {
        var p = Fr();
        u = u === void 0 ? null : u;
        var y = p.memoizedState;
        return y !== null && u !== null && Zm(u, y[1]) ? y[0] : (p.memoizedState = [l, u],
        l)
    }
    function s1(l, u) {
        var p = Fr();
        u = u === void 0 ? null : u;
        var y = p.memoizedState;
        return y !== null && u !== null && Zm(u, y[1]) ? y[0] : (l = l(),
        p.memoizedState = [l, u],
        l)
    }
    function ib(l, u) {
        var p = Pt;
        Pt = p !== 0 && 4 > p ? p : 4,
        l(!0);
        var y = Qi.transition;
        Qi.transition = {};
        try {
            l(!1),
            u()
        } finally {
            Pt = p,
            Qi.transition = y
        }
    }
    function o1() {
        return Fr().memoizedState
    }
    function rb(l, u, p) {
        var y = Ds(l);
        p = {
            lane: y,
            action: p,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        a1(l) ? l1(u, p) : (u1(l, u, p),
        p = oi(),
        l = $i(l, y, p),
        l !== null && c1(l, u, y))
    }
    function sb(l, u, p) {
        var y = Ds(l)
          , E = {
            lane: y,
            action: p,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (a1(l))
            l1(u, E);
        else {
            u1(l, u, E);
            var A = l.alternate;
            if (l.lanes === 0 && (A === null || A.lanes === 0) && (A = u.lastRenderedReducer,
            A !== null))
                try {
                    var k = u.lastRenderedState
                      , W = A(k, p);
                    if (E.hasEagerState = !0,
                    E.eagerState = W,
                    Nr(W, k))
                        return
                } catch {} finally {}
            p = oi(),
            l = $i(l, y, p),
            l !== null && c1(l, u, y)
        }
    }
    function a1(l) {
        var u = l.alternate;
        return l === sn || u !== null && u === sn
    }
    function l1(l, u) {
        _u = Yf = !0;
        var p = l.pending;
        p === null ? u.next = u : (u.next = p.next,
        p.next = u),
        l.pending = u
    }
    function u1(l, u, p) {
        mn !== null && l.mode & 1 && !(Mt & 2) ? (l = u.interleaved,
        l === null ? (p.next = p,
        Ur === null ? Ur = [u] : Ur.push(u)) : (p.next = l.next,
        l.next = p),
        u.interleaved = p) : (l = u.pending,
        l === null ? p.next = p : (p.next = l.next,
        l.next = p),
        u.pending = p)
    }
    function c1(l, u, p) {
        if (p & 4194240) {
            var y = u.lanes;
            y &= l.pendingLanes,
            p |= y,
            u.lanes = p,
            Rm(l, p)
        }
    }
    var Kf = {
        readContext: qi,
        useCallback: Xn,
        useContext: Xn,
        useEffect: Xn,
        useImperativeHandle: Xn,
        useInsertionEffect: Xn,
        useLayoutEffect: Xn,
        useMemo: Xn,
        useReducer: Xn,
        useRef: Xn,
        useState: Xn,
        useDebugValue: Xn,
        useDeferredValue: Xn,
        useTransition: Xn,
        useMutableSource: Xn,
        useSyncExternalStore: Xn,
        useId: Xn,
        unstable_isNewReconciler: !1
    }
      , ob = {
        readContext: qi,
        useCallback: function(l, u) {
            return ns().memoizedState = [l, u === void 0 ? null : u],
            l
        },
        useContext: qi,
        useEffect: $m,
        useImperativeHandle: function(l, u, p) {
            return p = p != null ? p.concat([l]) : null,
            Zf(4194308, 4, n1.bind(null, u, l), p)
        },
        useLayoutEffect: function(l, u) {
            return Zf(4194308, 4, l, u)
        },
        useInsertionEffect: function(l, u) {
            return Zf(4, 2, l, u)
        },
        useMemo: function(l, u) {
            var p = ns();
            return u = u === void 0 ? null : u,
            l = l(),
            p.memoizedState = [l, u],
            l
        },
        useReducer: function(l, u, p) {
            var y = ns();
            return u = p !== void 0 ? p(u) : u,
            y.memoizedState = y.baseState = u,
            l = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: l,
                lastRenderedState: u
            },
            y.queue = l,
            l = l.dispatch = rb.bind(null, sn, l),
            [y.memoizedState, l]
        },
        useRef: function(l) {
            var u = ns();
            return l = {
                current: l
            },
            u.memoizedState = l
        },
        useState: Qm,
        useDebugValue: eg,
        useDeferredValue: function(l) {
            var u = Qm(l)
              , p = u[0]
              , y = u[1];
            return $m(function() {
                var E = Qi.transition;
                Qi.transition = {};
                try {
                    y(l)
                } finally {
                    Qi.transition = E
                }
            }, [l]),
            p
        },
        useTransition: function() {
            var l = Qm(!1)
              , u = l[0];
            return l = ib.bind(null, l[1]),
            ns().memoizedState = l,
            [u, l]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(l, u, p) {
            var y = sn
              , E = ns();
            if (Yt) {
                if (p === void 0)
                    throw Error(o(407));
                p = p()
            } else {
                if (p = u(),
                mn === null)
                    throw Error(o(349));
                za & 30 || Zx(y, u, p)
            }
            E.memoizedState = p;
            var A = {
                value: p,
                getSnapshot: u
            };
            return E.queue = A,
            $m(Kx.bind(null, y, A, l), [l]),
            y.flags |= 2048,
            Su(9, Jx.bind(null, y, A, p, u), void 0, null),
            p
        },
        useId: function() {
            var l = ns()
              , u = mn.identifierPrefix;
            if (Yt) {
                var p = ts
                  , y = es;
                p = (y & ~(1 << 32 - bi(y) - 1)).toString(32) + p,
                u = ":" + u + "R" + p,
                p = xu++,
                0 < p && (u += "H" + p.toString(32)),
                u += ":"
            } else
                p = nb++,
                u = ":" + u + "r" + p.toString(32) + ":";
            return l.memoizedState = u
        },
        unstable_isNewReconciler: !1
    }
      , ab = {
        readContext: qi,
        useCallback: r1,
        useContext: qi,
        useEffect: Mu,
        useImperativeHandle: i1,
        useInsertionEffect: e1,
        useLayoutEffect: t1,
        useMemo: s1,
        useReducer: jf,
        useRef: $x,
        useState: function() {
            return jf(Ao)
        },
        useDebugValue: eg,
        useDeferredValue: function(l) {
            var u = jf(Ao)
              , p = u[0]
              , y = u[1];
            return Mu(function() {
                var E = Qi.transition;
                Qi.transition = {};
                try {
                    y(l)
                } finally {
                    Qi.transition = E
                }
            }, [l]),
            p
        },
        useTransition: function() {
            var l = jf(Ao)[0]
              , u = Fr().memoizedState;
            return [l, u]
        },
        useMutableSource: jx,
        useSyncExternalStore: qx,
        useId: o1,
        unstable_isNewReconciler: !1
    }
      , lb = {
        readContext: qi,
        useCallback: r1,
        useContext: qi,
        useEffect: Mu,
        useImperativeHandle: i1,
        useInsertionEffect: e1,
        useLayoutEffect: t1,
        useMemo: s1,
        useReducer: qf,
        useRef: $x,
        useState: function() {
            return qf(Ao)
        },
        useDebugValue: eg,
        useDeferredValue: function(l) {
            var u = qf(Ao)
              , p = u[0]
              , y = u[1];
            return Mu(function() {
                var E = Qi.transition;
                Qi.transition = {};
                try {
                    y(l)
                } finally {
                    Qi.transition = E
                }
            }, [l]),
            p
        },
        useTransition: function() {
            var l = qf(Ao)[0]
              , u = Fr().memoizedState;
            return [l, u]
        },
        useMutableSource: jx,
        useSyncExternalStore: qx,
        useId: o1,
        unstable_isNewReconciler: !1
    };
    function tg(l, u) {
        try {
            var p = ""
              , y = u;
            do
                p += tb(y),
                y = y.return;
            while (y);
            var E = p
        } catch (A) {
            E = `
Error generating stack: ` + A.message + `
` + A.stack
        }
        return {
            value: l,
            source: u,
            stack: E
        }
    }
    function ng(l, u) {
        try {
            console.error(u.value)
        } catch (p) {
            setTimeout(function() {
                throw p
            })
        }
    }
    var ub = typeof WeakMap == "function" ? WeakMap : Map;
    function f1(l, u, p) {
        p = $r(-1, p),
        p.tag = 3,
        p.payload = {
            element: null
        };
        var y = u.value;
        return p.callback = function() {
            dh || (dh = !0,
            xg = y),
            ng(l, u)
        }
        ,
        p
    }
    function h1(l, u, p) {
        p = $r(-1, p),
        p.tag = 3;
        var y = l.type.getDerivedStateFromError;
        if (typeof y == "function") {
            var E = u.value;
            p.payload = function() {
                return y(E)
            }
            ,
            p.callback = function() {
                ng(l, u)
            }
        }
        var A = l.stateNode;
        return A !== null && typeof A.componentDidCatch == "function" && (p.callback = function() {
            ng(l, u),
            typeof y != "function" && (Is === null ? Is = new Set([this]) : Is.add(this));
            var k = u.stack;
            this.componentDidCatch(u.value, {
                componentStack: k !== null ? k : ""
            })
        }
        ),
        p
    }
    function d1(l, u, p) {
        var y = l.pingCache;
        if (y === null) {
            y = l.pingCache = new ub;
            var E = new Set;
            y.set(u, E)
        } else
            E = y.get(u),
            E === void 0 && (E = new Set,
            y.set(u, E));
        E.has(p) || (E.add(p),
        l = wb.bind(null, l, u, p),
        u.then(l, l))
    }
    function p1(l) {
        do {
            var u;
            if ((u = l.tag === 13) && (u = l.memoizedState,
            u = u !== null ? u.dehydrated !== null : !0),
            u)
                return l;
            l = l.return
        } while (l !== null);
        return null
    }
    function m1(l, u, p, y, E) {
        return l.mode & 1 ? (l.flags |= 65536,
        l.lanes = E,
        l) : (l === u ? l.flags |= 65536 : (l.flags |= 128,
        p.flags |= 131072,
        p.flags &= -52805,
        p.tag === 1 && (p.alternate === null ? p.tag = 17 : (u = $r(-1, 1),
        u.tag = 2,
        Ls(p, u))),
        p.lanes |= 1),
        l)
    }
    function kr(l) {
        l.flags |= 4
    }
    function g1(l, u) {
        if (l !== null && l.child === u.child)
            return !0;
        if (u.flags & 16)
            return !1;
        for (l = u.child; l !== null; ) {
            if (l.flags & 12854 || l.subtreeFlags & 12854)
                return !1;
            l = l.sibling
        }
        return !0
    }
    var wu, Eu, Qf, $f;
    if (He)
        wu = function(l, u) {
            for (var p = u.child; p !== null; ) {
                if (p.tag === 5 || p.tag === 6)
                    ce(l, p.stateNode);
                else if (p.tag !== 4 && p.child !== null) {
                    p.child.return = p,
                    p = p.child;
                    continue
                }
                if (p === u)
                    break;
                for (; p.sibling === null; ) {
                    if (p.return === null || p.return === u)
                        return;
                    p = p.return
                }
                p.sibling.return = p.return,
                p = p.sibling
            }
        }
        ,
        Eu = function() {}
        ,
        Qf = function(l, u, p, y, E) {
            if (l = l.memoizedProps,
            l !== y) {
                var A = u.stateNode
                  , k = Or(Ki.current);
                p = Z(A, p, l, y, E, k),
                (u.updateQueue = p) && kr(u)
            }
        }
        ,
        $f = function(l, u, p, y) {
            p !== y && kr(u)
        }
        ;
    else if (z) {
        wu = function(l, u, p, y) {
            for (var E = u.child; E !== null; ) {
                if (E.tag === 5) {
                    var A = E.stateNode;
                    p && y && (A = pn(A, E.type, E.memoizedProps, E)),
                    ce(l, A)
                } else if (E.tag === 6)
                    A = E.stateNode,
                    p && y && (A = ri(A, E.memoizedProps, E)),
                    ce(l, A);
                else if (E.tag !== 4) {
                    if (E.tag === 22 && E.memoizedState !== null)
                        A = E.child,
                        A !== null && (A.return = E),
                        wu(l, E, !0, !0);
                    else if (E.child !== null) {
                        E.child.return = E,
                        E = E.child;
                        continue
                    }
                }
                if (E === u)
                    break;
                for (; E.sibling === null; ) {
                    if (E.return === null || E.return === u)
                        return;
                    E = E.return
                }
                E.sibling.return = E.return,
                E = E.sibling
            }
        }
        ;
        var v1 = function(l, u, p, y) {
            for (var E = u.child; E !== null; ) {
                if (E.tag === 5) {
                    var A = E.stateNode;
                    p && y && (A = pn(A, E.type, E.memoizedProps, E)),
                    Pe(l, A)
                } else if (E.tag === 6)
                    A = E.stateNode,
                    p && y && (A = ri(A, E.memoizedProps, E)),
                    Pe(l, A);
                else if (E.tag !== 4) {
                    if (E.tag === 22 && E.memoizedState !== null)
                        A = E.child,
                        A !== null && (A.return = E),
                        v1(l, E, !0, !0);
                    else if (E.child !== null) {
                        E.child.return = E,
                        E = E.child;
                        continue
                    }
                }
                if (E === u)
                    break;
                for (; E.sibling === null; ) {
                    if (E.return === null || E.return === u)
                        return;
                    E = E.return
                }
                E.sibling.return = E.return,
                E = E.sibling
            }
        };
        Eu = function(l, u) {
            var p = u.stateNode;
            if (!g1(l, u)) {
                l = p.containerInfo;
                var y = Ee(l);
                v1(y, u, !1, !1),
                p.pendingChildren = y,
                kr(u),
                wt(l, y)
            }
        }
        ,
        Qf = function(l, u, p, y, E) {
            var A = l.stateNode
              , k = l.memoizedProps;
            if ((l = g1(l, u)) && k === y)
                u.stateNode = A;
            else {
                var W = u.stateNode
                  , ae = Or(Ki.current)
                  , xe = null;
                k !== y && (xe = Z(W, p, k, y, E, ae)),
                l && xe === null ? u.stateNode = A : (A = ee(A, xe, p, k, y, u, l, W),
                Ce(A, p, y, E, ae) && kr(u),
                u.stateNode = A,
                l ? kr(u) : wu(A, u, !1, !1))
            }
        }
        ,
        $f = function(l, u, p, y) {
            p !== y ? (l = Or(Fa.current),
            p = Or(Ki.current),
            u.stateNode = Se(y, l, p, u),
            kr(u)) : u.stateNode = l.stateNode
        }
    } else
        Eu = function() {}
        ,
        Qf = function() {}
        ,
        $f = function() {}
        ;
    function Tu(l, u) {
        if (!Yt)
            switch (l.tailMode) {
            case "hidden":
                u = l.tail;
                for (var p = null; u !== null; )
                    u.alternate !== null && (p = u),
                    u = u.sibling;
                p === null ? l.tail = null : p.sibling = null;
                break;
            case "collapsed":
                p = l.tail;
                for (var y = null; p !== null; )
                    p.alternate !== null && (y = p),
                    p = p.sibling;
                y === null ? u || l.tail === null ? l.tail = null : l.tail.sibling = null : y.sibling = null
            }
    }
    function Yn(l) {
        var u = l.alternate !== null && l.alternate.child === l.child
          , p = 0
          , y = 0;
        if (u)
            for (var E = l.child; E !== null; )
                p |= E.lanes | E.childLanes,
                y |= E.subtreeFlags & 14680064,
                y |= E.flags & 14680064,
                E.return = l,
                E = E.sibling;
        else
            for (E = l.child; E !== null; )
                p |= E.lanes | E.childLanes,
                y |= E.subtreeFlags,
                y |= E.flags,
                E.return = l,
                E = E.sibling;
        return l.subtreeFlags |= y,
        l.childLanes = p,
        u
    }
    function cb(l, u, p) {
        var y = u.pendingProps;
        switch (Hm(u),
        u.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return Yn(u),
            null;
        case 1:
            return Rn(u.type) && un(),
            Yn(u),
            null;
        case 3:
            return y = u.stateNode,
            ka(),
            it(rn),
            it(vt),
            qm(),
            y.pendingContext && (y.context = y.pendingContext,
            y.pendingContext = null),
            (l === null || l.child === null) && (mu(u) ? kr(u) : l === null || l.memoizedState.isDehydrated && !(u.flags & 256) || (u.flags |= 1024,
            dr !== null && (wg(dr),
            dr = null))),
            Eu(l, u),
            Yn(u),
            null;
        case 5:
            Ym(u),
            p = Or(Fa.current);
            var E = u.type;
            if (l !== null && u.stateNode != null)
                Qf(l, u, E, y, p),
                l.ref !== u.ref && (u.flags |= 512,
                u.flags |= 2097152);
            else {
                if (!y) {
                    if (u.stateNode === null)
                        throw Error(o(166));
                    return Yn(u),
                    null
                }
                if (l = Or(Ki.current),
                mu(u)) {
                    if (!ge)
                        throw Error(o(175));
                    l = wm(u.stateNode, u.type, u.memoizedProps, p, l, u, !pu),
                    u.updateQueue = l,
                    l !== null && kr(u)
                } else {
                    var A = q(E, y, p, l, u);
                    wu(A, u, !1, !1),
                    u.stateNode = A,
                    Ce(A, E, y, p, l) && kr(u)
                }
                u.ref !== null && (u.flags |= 512,
                u.flags |= 2097152)
            }
            return Yn(u),
            null;
        case 6:
            if (l && u.stateNode != null)
                $f(l, u, l.memoizedProps, y);
            else {
                if (typeof y != "string" && u.stateNode === null)
                    throw Error(o(166));
                if (l = Or(Fa.current),
                p = Or(Ki.current),
                mu(u)) {
                    if (!ge)
                        throw Error(o(176));
                    if (l = u.stateNode,
                    y = u.memoizedProps,
                    (p = Em(l, y, u, !pu)) && (E = Pi,
                    E !== null))
                        switch (A = (E.mode & 1) !== 0,
                        E.tag) {
                        case 3:
                            Ze(E.stateNode.containerInfo, l, y, A);
                            break;
                        case 5:
                            tt(E.type, E.memoizedProps, E.stateNode, l, y, A)
                        }
                    p && kr(u)
                } else
                    u.stateNode = Se(y, l, p, u)
            }
            return Yn(u),
            null;
        case 13:
            if (it(Jt),
            y = u.memoizedState,
            Yt && Li !== null && u.mode & 1 && !(u.flags & 128)) {
                for (l = Li; l; )
                    l = bs(l);
                return Ua(),
                u.flags |= 98560,
                u
            }
            if (y !== null && y.dehydrated !== null) {
                if (y = mu(u),
                l === null) {
                    if (!y)
                        throw Error(o(318));
                    if (!ge)
                        throw Error(o(344));
                    if (l = u.memoizedState,
                    l = l !== null ? l.dehydrated : null,
                    !l)
                        throw Error(o(317));
                    Tm(l, u)
                } else
                    Ua(),
                    !(u.flags & 128) && (u.memoizedState = null),
                    u.flags |= 4;
                return Yn(u),
                null
            }
            return dr !== null && (wg(dr),
            dr = null),
            u.flags & 128 ? (u.lanes = p,
            u) : (y = y !== null,
            p = !1,
            l === null ? mu(u) : p = l.memoizedState !== null,
            y && !p && (u.child.flags |= 8192,
            u.mode & 1 && (l === null || Jt.current & 1 ? xn === 0 && (xn = 3) : Tg())),
            u.updateQueue !== null && (u.flags |= 4),
            Yn(u),
            null);
        case 4:
            return ka(),
            Eu(l, u),
            l === null && Me(u.stateNode.containerInfo),
            Yn(u),
            null;
        case 10:
            return Um(u.type._context),
            Yn(u),
            null;
        case 17:
            return Rn(u.type) && un(),
            Yn(u),
            null;
        case 19:
            if (it(Jt),
            E = u.memoizedState,
            E === null)
                return Yn(u),
                null;
            if (y = (u.flags & 128) !== 0,
            A = E.rendering,
            A === null)
                if (y)
                    Tu(E, !1);
                else {
                    if (xn !== 0 || l !== null && l.flags & 128)
                        for (l = u.child; l !== null; ) {
                            if (A = Wf(l),
                            A !== null) {
                                for (u.flags |= 128,
                                Tu(E, !1),
                                l = A.updateQueue,
                                l !== null && (u.updateQueue = l,
                                u.flags |= 4),
                                u.subtreeFlags = 0,
                                l = p,
                                y = u.child; y !== null; )
                                    p = y,
                                    E = l,
                                    p.flags &= 14680066,
                                    A = p.alternate,
                                    A === null ? (p.childLanes = 0,
                                    p.lanes = E,
                                    p.child = null,
                                    p.subtreeFlags = 0,
                                    p.memoizedProps = null,
                                    p.memoizedState = null,
                                    p.updateQueue = null,
                                    p.dependencies = null,
                                    p.stateNode = null) : (p.childLanes = A.childLanes,
                                    p.lanes = A.lanes,
                                    p.child = A.child,
                                    p.subtreeFlags = 0,
                                    p.deletions = null,
                                    p.memoizedProps = A.memoizedProps,
                                    p.memoizedState = A.memoizedState,
                                    p.updateQueue = A.updateQueue,
                                    p.type = A.type,
                                    E = A.dependencies,
                                    p.dependencies = E === null ? null : {
                                        lanes: E.lanes,
                                        firstContext: E.firstContext
                                    }),
                                    y = y.sibling;
                                return Fe(Jt, Jt.current & 1 | 2),
                                u.child
                            }
                            l = l.sibling
                        }
                    E.tail !== null && bn() > _g && (u.flags |= 128,
                    y = !0,
                    Tu(E, !1),
                    u.lanes = 4194304)
                }
            else {
                if (!y)
                    if (l = Wf(A),
                    l !== null) {
                        if (u.flags |= 128,
                        y = !0,
                        l = l.updateQueue,
                        l !== null && (u.updateQueue = l,
                        u.flags |= 4),
                        Tu(E, !0),
                        E.tail === null && E.tailMode === "hidden" && !A.alternate && !Yt)
                            return Yn(u),
                            null
                    } else
                        2 * bn() - E.renderingStartTime > _g && p !== 1073741824 && (u.flags |= 128,
                        y = !0,
                        Tu(E, !1),
                        u.lanes = 4194304);
                E.isBackwards ? (A.sibling = u.child,
                u.child = A) : (l = E.last,
                l !== null ? l.sibling = A : u.child = A,
                E.last = A)
            }
            return E.tail !== null ? (u = E.tail,
            E.rendering = u,
            E.tail = u.sibling,
            E.renderingStartTime = bn(),
            u.sibling = null,
            l = Jt.current,
            Fe(Jt, y ? l & 1 | 2 : l & 1),
            u) : (Yn(u),
            null);
        case 22:
        case 23:
            return Eg(),
            y = u.memoizedState !== null,
            l !== null && l.memoizedState !== null !== y && (u.flags |= 8192),
            y && u.mode & 1 ? Ni & 1073741824 && (Yn(u),
            He && u.subtreeFlags & 6 && (u.flags |= 8192)) : Yn(u),
            null;
        case 24:
            return null;
        case 25:
            return null
        }
        throw Error(o(156, u.tag))
    }
    var fb = a.ReactCurrentOwner
      , Ii = !1;
    function si(l, u, p, y) {
        u.child = l === null ? Xx(u, null, p, y) : Oa(u, l.child, p, y)
    }
    function y1(l, u, p, y, E) {
        p = p.render;
        var A = u.ref;
        return Ia(u, E),
        y = Jm(l, u, p, y, A, E),
        p = Km(),
        l !== null && !Ii ? (u.updateQueue = l.updateQueue,
        u.flags &= -2053,
        l.lanes &= ~E,
        is(l, u, E)) : (Yt && p && Bm(u),
        u.flags |= 1,
        si(l, u, y, E),
        u.child)
    }
    function _1(l, u, p, y, E) {
        if (l === null) {
            var A = p.type;
            return typeof A == "function" && !Ag(A) && A.defaultProps === void 0 && p.compare === null && p.defaultProps === void 0 ? (u.tag = 15,
            u.type = A,
            x1(l, u, A, y, E)) : (l = xh(p.type, null, y, u, u.mode, E),
            l.ref = u.ref,
            l.return = u,
            u.child = l)
        }
        if (A = l.child,
        !(l.lanes & E)) {
            var k = A.memoizedProps;
            if (p = p.compare,
            p = p !== null ? p : Uf,
            p(k, y) && l.ref === u.ref)
                return is(l, u, E)
        }
        return u.flags |= 1,
        l = Os(A, y),
        l.ref = u.ref,
        l.return = u,
        u.child = l
    }
    function x1(l, u, p, y, E) {
        if (l !== null && Uf(l.memoizedProps, y) && l.ref === u.ref)
            if (Ii = !1,
            (l.lanes & E) !== 0)
                l.flags & 131072 && (Ii = !0);
            else
                return u.lanes = l.lanes,
                is(l, u, E);
        return ig(l, u, p, y, E)
    }
    function S1(l, u, p) {
        var y = u.pendingProps
          , E = y.children
          , A = l !== null ? l.memoizedState : null;
        if (y.mode === "hidden")
            if (!(u.mode & 1))
                u.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                Fe(Ba, Ni),
                Ni |= p;
            else if (p & 1073741824)
                u.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                y = A !== null ? A.baseLanes : p,
                Fe(Ba, Ni),
                Ni |= y;
            else
                return l = A !== null ? A.baseLanes | p : p,
                u.lanes = u.childLanes = 1073741824,
                u.memoizedState = {
                    baseLanes: l,
                    cachePool: null
                },
                u.updateQueue = null,
                Fe(Ba, Ni),
                Ni |= l,
                null;
        else
            A !== null ? (y = A.baseLanes | p,
            u.memoizedState = null) : y = p,
            Fe(Ba, Ni),
            Ni |= y;
        return si(l, u, E, p),
        u.child
    }
    function M1(l, u) {
        var p = u.ref;
        (l === null && p !== null || l !== null && l.ref !== p) && (u.flags |= 512,
        u.flags |= 2097152)
    }
    function ig(l, u, p, y, E) {
        var A = Rn(p) ? Pr : vt.current;
        return A = ji(u, A),
        Ia(u, E),
        p = Jm(l, u, p, y, A, E),
        y = Km(),
        l !== null && !Ii ? (u.updateQueue = l.updateQueue,
        u.flags &= -2053,
        l.lanes &= ~E,
        is(l, u, E)) : (Yt && y && Bm(u),
        u.flags |= 1,
        si(l, u, p, E),
        u.child)
    }
    function w1(l, u, p, y, E) {
        if (Rn(p)) {
            var A = !0;
            kn(u)
        } else
            A = !1;
        if (Ia(u, E),
        u.stateNode === null)
            l !== null && (l.alternate = null,
            u.alternate = null,
            u.flags |= 2),
            Fx(u, p, y),
            zm(u, p, y, E),
            y = !0;
        else if (l === null) {
            var k = u.stateNode
              , W = u.memoizedProps;
            k.props = W;
            var ae = k.context
              , xe = p.contextType;
            typeof xe == "object" && xe !== null ? xe = qi(xe) : (xe = Rn(p) ? Pr : vt.current,
            xe = ji(u, xe));
            var Ve = p.getDerivedStateFromProps
              , dt = typeof Ve == "function" || typeof k.getSnapshotBeforeUpdate == "function";
            dt || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (W !== y || ae !== xe) && kx(u, k, y, xe),
            Ps = !1;
            var Qe = u.memoizedState;
            k.state = Qe,
            zf(u, y, k, E),
            ae = u.memoizedState,
            W !== y || Qe !== ae || rn.current || Ps ? (typeof Ve == "function" && (km(u, p, Ve, y),
            ae = u.memoizedState),
            (W = Ps || Ox(u, p, W, y, Qe, ae, xe)) ? (dt || typeof k.UNSAFE_componentWillMount != "function" && typeof k.componentWillMount != "function" || (typeof k.componentWillMount == "function" && k.componentWillMount(),
            typeof k.UNSAFE_componentWillMount == "function" && k.UNSAFE_componentWillMount()),
            typeof k.componentDidMount == "function" && (u.flags |= 4194308)) : (typeof k.componentDidMount == "function" && (u.flags |= 4194308),
            u.memoizedProps = y,
            u.memoizedState = ae),
            k.props = y,
            k.state = ae,
            k.context = xe,
            y = W) : (typeof k.componentDidMount == "function" && (u.flags |= 4194308),
            y = !1)
        } else {
            k = u.stateNode,
            Ix(l, u),
            W = u.memoizedProps,
            xe = u.type === u.elementType ? W : hr(u.type, W),
            k.props = xe,
            dt = u.pendingProps,
            Qe = k.context,
            ae = p.contextType,
            typeof ae == "object" && ae !== null ? ae = qi(ae) : (ae = Rn(p) ? Pr : vt.current,
            ae = ji(u, ae));
            var kt = p.getDerivedStateFromProps;
            (Ve = typeof kt == "function" || typeof k.getSnapshotBeforeUpdate == "function") || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (W !== dt || Qe !== ae) && kx(u, k, y, ae),
            Ps = !1,
            Qe = u.memoizedState,
            k.state = Qe,
            zf(u, y, k, E);
            var Je = u.memoizedState;
            W !== dt || Qe !== Je || rn.current || Ps ? (typeof kt == "function" && (km(u, p, kt, y),
            Je = u.memoizedState),
            (xe = Ps || Ox(u, p, xe, y, Qe, Je, ae) || !1) ? (Ve || typeof k.UNSAFE_componentWillUpdate != "function" && typeof k.componentWillUpdate != "function" || (typeof k.componentWillUpdate == "function" && k.componentWillUpdate(y, Je, ae),
            typeof k.UNSAFE_componentWillUpdate == "function" && k.UNSAFE_componentWillUpdate(y, Je, ae)),
            typeof k.componentDidUpdate == "function" && (u.flags |= 4),
            typeof k.getSnapshotBeforeUpdate == "function" && (u.flags |= 1024)) : (typeof k.componentDidUpdate != "function" || W === l.memoizedProps && Qe === l.memoizedState || (u.flags |= 4),
            typeof k.getSnapshotBeforeUpdate != "function" || W === l.memoizedProps && Qe === l.memoizedState || (u.flags |= 1024),
            u.memoizedProps = y,
            u.memoizedState = Je),
            k.props = y,
            k.state = Je,
            k.context = ae,
            y = xe) : (typeof k.componentDidUpdate != "function" || W === l.memoizedProps && Qe === l.memoizedState || (u.flags |= 4),
            typeof k.getSnapshotBeforeUpdate != "function" || W === l.memoizedProps && Qe === l.memoizedState || (u.flags |= 1024),
            y = !1)
        }
        return rg(l, u, p, y, A, E)
    }
    function rg(l, u, p, y, E, A) {
        M1(l, u);
        var k = (u.flags & 128) !== 0;
        if (!y && !k)
            return E && Pa(u, p, !1),
            is(l, u, A);
        y = u.stateNode,
        fb.current = u;
        var W = k && typeof p.getDerivedStateFromError != "function" ? null : y.render();
        return u.flags |= 1,
        l !== null && k ? (u.child = Oa(u, l.child, null, A),
        u.child = Oa(u, null, W, A)) : si(l, u, W, A),
        u.memoizedState = y.state,
        E && Pa(u, p, !0),
        u.child
    }
    function E1(l) {
        var u = l.stateNode;
        u.pendingContext ? Lr(l, u.pendingContext, u.pendingContext !== u.context) : u.context && Lr(l, u.context, !1),
        Xm(l, u.containerInfo)
    }
    function T1(l, u, p, y, E) {
        return Ua(),
        Wm(E),
        u.flags |= 256,
        si(l, u, p, y),
        u.child
    }
    var eh = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };
    function th(l) {
        return {
            baseLanes: l,
            cachePool: null
        }
    }
    function A1(l, u, p) {
        var y = u.pendingProps, E = Jt.current, A = !1, k = (u.flags & 128) !== 0, W;
        if ((W = k) || (W = l !== null && l.memoizedState === null ? !1 : (E & 2) !== 0),
        W ? (A = !0,
        u.flags &= -129) : (l === null || l.memoizedState !== null) && (E |= 1),
        Fe(Jt, E & 1),
        l === null)
            return Gm(u),
            l = u.memoizedState,
            l !== null && (l = l.dehydrated,
            l !== null) ? (u.mode & 1 ? fu(l) ? u.lanes = 8 : u.lanes = 1073741824 : u.lanes = 1,
            null) : (E = y.children,
            l = y.fallback,
            A ? (y = u.mode,
            A = u.child,
            E = {
                mode: "hidden",
                children: E
            },
            !(y & 1) && A !== null ? (A.childLanes = 0,
            A.pendingProps = E) : A = Sh(E, y, 0, null),
            l = Io(l, y, p, null),
            A.return = u,
            l.return = u,
            A.sibling = l,
            u.child = A,
            u.child.memoizedState = th(p),
            u.memoizedState = eh,
            l) : sg(u, E));
        if (E = l.memoizedState,
        E !== null) {
            if (W = E.dehydrated,
            W !== null) {
                if (k)
                    return u.flags & 256 ? (u.flags &= -257,
                    nh(l, u, p, Error(o(422)))) : u.memoizedState !== null ? (u.child = l.child,
                    u.flags |= 128,
                    null) : (A = y.fallback,
                    E = u.mode,
                    y = Sh({
                        mode: "visible",
                        children: y.children
                    }, E, 0, null),
                    A = Io(A, E, p, null),
                    A.flags |= 2,
                    y.return = u,
                    A.return = u,
                    y.sibling = A,
                    u.child = y,
                    u.mode & 1 && Oa(u, l.child, null, p),
                    u.child.memoizedState = th(p),
                    u.memoizedState = eh,
                    A);
                if (!(u.mode & 1))
                    u = nh(l, u, p, null);
                else if (fu(W))
                    u = nh(l, u, p, Error(o(419)));
                else if (y = (p & l.childLanes) !== 0,
                Ii || y) {
                    if (y = mn,
                    y !== null) {
                        switch (p & -p) {
                        case 4:
                            A = 2;
                            break;
                        case 16:
                            A = 8;
                            break;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            A = 32;
                            break;
                        case 536870912:
                            A = 268435456;
                            break;
                        default:
                            A = 0
                        }
                        y = A & (y.suspendedLanes | p) ? 0 : A,
                        y !== 0 && y !== E.retryLane && (E.retryLane = y,
                        $i(l, y, -1))
                    }
                    Tg(),
                    u = nh(l, u, p, Error(o(421)))
                } else
                    cu(W) ? (u.flags |= 128,
                    u.child = l.child,
                    u = Eb.bind(null, l),
                    Ca(W, u),
                    u = null) : (p = E.treeContext,
                    ge && (Li = Rf(W),
                    Pi = u,
                    Yt = !0,
                    dr = null,
                    pu = !1,
                    p !== null && (Zi[Ji++] = es,
                    Zi[Ji++] = ts,
                    Zi[Ji++] = Eo,
                    es = p.id,
                    ts = p.overflow,
                    Eo = u)),
                    u = sg(u, u.pendingProps.children),
                    u.flags |= 4096);
                return u
            }
            return A ? (y = R1(l, u, y.children, y.fallback, p),
            A = u.child,
            E = l.child.memoizedState,
            A.memoizedState = E === null ? th(p) : {
                baseLanes: E.baseLanes | p,
                cachePool: null
            },
            A.childLanes = l.childLanes & ~p,
            u.memoizedState = eh,
            y) : (p = C1(l, u, y.children, p),
            u.memoizedState = null,
            p)
        }
        return A ? (y = R1(l, u, y.children, y.fallback, p),
        A = u.child,
        E = l.child.memoizedState,
        A.memoizedState = E === null ? th(p) : {
            baseLanes: E.baseLanes | p,
            cachePool: null
        },
        A.childLanes = l.childLanes & ~p,
        u.memoizedState = eh,
        y) : (p = C1(l, u, y.children, p),
        u.memoizedState = null,
        p)
    }
    function sg(l, u) {
        return u = Sh({
            mode: "visible",
            children: u
        }, l.mode, 0, null),
        u.return = l,
        l.child = u
    }
    function C1(l, u, p, y) {
        var E = l.child;
        return l = E.sibling,
        p = Os(E, {
            mode: "visible",
            children: p
        }),
        !(u.mode & 1) && (p.lanes = y),
        p.return = u,
        p.sibling = null,
        l !== null && (y = u.deletions,
        y === null ? (u.deletions = [l],
        u.flags |= 16) : y.push(l)),
        u.child = p
    }
    function R1(l, u, p, y, E) {
        var A = u.mode;
        l = l.child;
        var k = l.sibling
          , W = {
            mode: "hidden",
            children: p
        };
        return !(A & 1) && u.child !== l ? (p = u.child,
        p.childLanes = 0,
        p.pendingProps = W,
        u.deletions = null) : (p = Os(l, W),
        p.subtreeFlags = l.subtreeFlags & 14680064),
        k !== null ? y = Os(k, y) : (y = Io(y, A, E, null),
        y.flags |= 2),
        y.return = u,
        p.return = u,
        p.sibling = y,
        u.child = p,
        y
    }
    function nh(l, u, p, y) {
        return y !== null && Wm(y),
        Oa(u, l.child, null, p),
        l = sg(u, u.pendingProps.children),
        l.flags |= 2,
        u.memoizedState = null,
        l
    }
    function b1(l, u, p) {
        l.lanes |= u;
        var y = l.alternate;
        y !== null && (y.lanes |= u),
        Om(l.return, u, p)
    }
    function og(l, u, p, y, E) {
        var A = l.memoizedState;
        A === null ? l.memoizedState = {
            isBackwards: u,
            rendering: null,
            renderingStartTime: 0,
            last: y,
            tail: p,
            tailMode: E
        } : (A.isBackwards = u,
        A.rendering = null,
        A.renderingStartTime = 0,
        A.last = y,
        A.tail = p,
        A.tailMode = E)
    }
    function P1(l, u, p) {
        var y = u.pendingProps
          , E = y.revealOrder
          , A = y.tail;
        if (si(l, u, y.children, p),
        y = Jt.current,
        y & 2)
            y = y & 1 | 2,
            u.flags |= 128;
        else {
            if (l !== null && l.flags & 128)
                e: for (l = u.child; l !== null; ) {
                    if (l.tag === 13)
                        l.memoizedState !== null && b1(l, p, u);
                    else if (l.tag === 19)
                        b1(l, p, u);
                    else if (l.child !== null) {
                        l.child.return = l,
                        l = l.child;
                        continue
                    }
                    if (l === u)
                        break e;
                    for (; l.sibling === null; ) {
                        if (l.return === null || l.return === u)
                            break e;
                        l = l.return
                    }
                    l.sibling.return = l.return,
                    l = l.sibling
                }
            y &= 1
        }
        if (Fe(Jt, y),
        !(u.mode & 1))
            u.memoizedState = null;
        else
            switch (E) {
            case "forwards":
                for (p = u.child,
                E = null; p !== null; )
                    l = p.alternate,
                    l !== null && Wf(l) === null && (E = p),
                    p = p.sibling;
                p = E,
                p === null ? (E = u.child,
                u.child = null) : (E = p.sibling,
                p.sibling = null),
                og(u, !1, E, p, A);
                break;
            case "backwards":
                for (p = null,
                E = u.child,
                u.child = null; E !== null; ) {
                    if (l = E.alternate,
                    l !== null && Wf(l) === null) {
                        u.child = E;
                        break
                    }
                    l = E.sibling,
                    E.sibling = p,
                    p = E,
                    E = l
                }
                og(u, !0, p, null, A);
                break;
            case "together":
                og(u, !1, null, null, void 0);
                break;
            default:
                u.memoizedState = null
            }
        return u.child
    }
    function is(l, u, p) {
        if (l !== null && (u.dependencies = l.dependencies),
        Ha |= u.lanes,
        !(p & u.childLanes))
            return null;
        if (l !== null && u.child !== l.child)
            throw Error(o(153));
        if (u.child !== null) {
            for (l = u.child,
            p = Os(l, l.pendingProps),
            u.child = p,
            p.return = u; l.sibling !== null; )
                l = l.sibling,
                p = p.sibling = Os(l, l.pendingProps),
                p.return = u;
            p.sibling = null
        }
        return u.child
    }
    function hb(l, u, p) {
        switch (u.tag) {
        case 3:
            E1(u),
            Ua();
            break;
        case 5:
            Yx(u);
            break;
        case 1:
            Rn(u.type) && kn(u);
            break;
        case 4:
            Xm(u, u.stateNode.containerInfo);
            break;
        case 10:
            Lx(u, u.type._context, u.memoizedProps.value);
            break;
        case 13:
            var y = u.memoizedState;
            if (y !== null)
                return y.dehydrated !== null ? (Fe(Jt, Jt.current & 1),
                u.flags |= 128,
                null) : p & u.child.childLanes ? A1(l, u, p) : (Fe(Jt, Jt.current & 1),
                l = is(l, u, p),
                l !== null ? l.sibling : null);
            Fe(Jt, Jt.current & 1);
            break;
        case 19:
            if (y = (p & u.childLanes) !== 0,
            l.flags & 128) {
                if (y)
                    return P1(l, u, p);
                u.flags |= 128
            }
            var E = u.memoizedState;
            if (E !== null && (E.rendering = null,
            E.tail = null,
            E.lastEffect = null),
            Fe(Jt, Jt.current),
            y)
                break;
            return null;
        case 22:
        case 23:
            return u.lanes = 0,
            S1(l, u, p)
        }
        return is(l, u, p)
    }
    function db(l, u) {
        switch (Hm(u),
        u.tag) {
        case 1:
            return Rn(u.type) && un(),
            l = u.flags,
            l & 65536 ? (u.flags = l & -65537 | 128,
            u) : null;
        case 3:
            return ka(),
            it(rn),
            it(vt),
            qm(),
            l = u.flags,
            l & 65536 && !(l & 128) ? (u.flags = l & -65537 | 128,
            u) : null;
        case 5:
            return Ym(u),
            null;
        case 13:
            if (it(Jt),
            l = u.memoizedState,
            l !== null && l.dehydrated !== null) {
                if (u.alternate === null)
                    throw Error(o(340));
                Ua()
            }
            return l = u.flags,
            l & 65536 ? (u.flags = l & -65537 | 128,
            u) : null;
        case 19:
            return it(Jt),
            null;
        case 4:
            return ka(),
            null;
        case 10:
            return Um(u.type._context),
            null;
        case 22:
        case 23:
            return Eg(),
            null;
        case 24:
            return null;
        default:
            return null
        }
    }
    var ih = !1
      , Co = !1
      , pb = typeof WeakSet == "function" ? WeakSet : Set
      , Le = null;
    function rh(l, u) {
        var p = l.ref;
        if (p !== null)
            if (typeof p == "function")
                try {
                    p(null)
                } catch (y) {
                    xi(l, u, y)
                }
            else
                p.current = null
    }
    function ag(l, u, p) {
        try {
            p()
        } catch (y) {
            xi(l, u, y)
        }
    }
    var L1 = !1;
    function mb(l, u) {
        for (H(l.containerInfo),
        Le = u; Le !== null; )
            if (l = Le,
            u = l.child,
            (l.subtreeFlags & 1028) !== 0 && u !== null)
                u.return = l,
                Le = u;
            else
                for (; Le !== null; ) {
                    l = Le;
                    try {
                        var p = l.alternate;
                        if (l.flags & 1024)
                            switch (l.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (p !== null) {
                                    var y = p.memoizedProps
                                      , E = p.memoizedState
                                      , A = l.stateNode
                                      , k = A.getSnapshotBeforeUpdate(l.elementType === l.type ? y : hr(l.type, y), E);
                                    A.__reactInternalSnapshotBeforeUpdate = k
                                }
                                break;
                            case 3:
                                He && be(l.stateNode.containerInfo);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(o(163))
                            }
                    } catch (W) {
                        xi(l, l.return, W)
                    }
                    if (u = l.sibling,
                    u !== null) {
                        u.return = l.return,
                        Le = u;
                        break
                    }
                    Le = l.return
                }
        return p = L1,
        L1 = !1,
        p
    }
    function Ro(l, u, p) {
        var y = u.updateQueue;
        if (y = y !== null ? y.lastEffect : null,
        y !== null) {
            var E = y = y.next;
            do {
                if ((E.tag & l) === l) {
                    var A = E.destroy;
                    E.destroy = void 0,
                    A !== void 0 && ag(u, p, A)
                }
                E = E.next
            } while (E !== y)
        }
    }
    function Au(l, u) {
        if (u = u.updateQueue,
        u = u !== null ? u.lastEffect : null,
        u !== null) {
            var p = u = u.next;
            do {
                if ((p.tag & l) === l) {
                    var y = p.create;
                    p.destroy = y()
                }
                p = p.next
            } while (p !== u)
        }
    }
    function lg(l) {
        var u = l.ref;
        if (u !== null) {
            var p = l.stateNode;
            switch (l.tag) {
            case 5:
                l = J(p);
                break;
            default:
                l = p
            }
            typeof u == "function" ? u(l) : u.current = l
        }
    }
    function I1(l, u, p) {
        if (Ir && typeof Ir.onCommitFiberUnmount == "function")
            try {
                Ir.onCommitFiberUnmount(Nf, u)
            } catch {}
        switch (u.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (l = u.updateQueue,
            l !== null && (l = l.lastEffect,
            l !== null)) {
                var y = l = l.next;
                do {
                    var E = y
                      , A = E.destroy;
                    E = E.tag,
                    A !== void 0 && (E & 2 || E & 4) && ag(u, p, A),
                    y = y.next
                } while (y !== l)
            }
            break;
        case 1:
            if (rh(u, p),
            l = u.stateNode,
            typeof l.componentWillUnmount == "function")
                try {
                    l.props = u.memoizedProps,
                    l.state = u.memoizedState,
                    l.componentWillUnmount()
                } catch (k) {
                    xi(u, p, k)
                }
            break;
        case 5:
            rh(u, p);
            break;
        case 4:
            He ? k1(l, u, p) : z && z && (u = u.stateNode.containerInfo,
            p = Ee(u),
            Dt(u, p))
        }
    }
    function N1(l, u, p) {
        for (var y = u; ; )
            if (I1(l, y, p),
            y.child === null || He && y.tag === 4) {
                if (y === u)
                    break;
                for (; y.sibling === null; ) {
                    if (y.return === null || y.return === u)
                        return;
                    y = y.return
                }
                y.sibling.return = y.return,
                y = y.sibling
            } else
                y.child.return = y,
                y = y.child
    }
    function D1(l) {
        var u = l.alternate;
        u !== null && (l.alternate = null,
        D1(u)),
        l.child = null,
        l.deletions = null,
        l.sibling = null,
        l.tag === 5 && (u = l.stateNode,
        u !== null && Oe(u)),
        l.stateNode = null,
        l.return = null,
        l.dependencies = null,
        l.memoizedProps = null,
        l.memoizedState = null,
        l.pendingProps = null,
        l.stateNode = null,
        l.updateQueue = null
    }
    function U1(l) {
        return l.tag === 5 || l.tag === 3 || l.tag === 4
    }
    function O1(l) {
        e: for (; ; ) {
            for (; l.sibling === null; ) {
                if (l.return === null || U1(l.return))
                    return null;
                l = l.return
            }
            for (l.sibling.return = l.return,
            l = l.sibling; l.tag !== 5 && l.tag !== 6 && l.tag !== 18; ) {
                if (l.flags & 2 || l.child === null || l.tag === 4)
                    continue e;
                l.child.return = l,
                l = l.child
            }
            if (!(l.flags & 2))
                return l.stateNode
        }
    }
    function F1(l) {
        if (He) {
            e: {
                for (var u = l.return; u !== null; ) {
                    if (U1(u))
                        break e;
                    u = u.return
                }
                throw Error(o(160))
            }
            var p = u;
            switch (p.tag) {
            case 5:
                u = p.stateNode,
                p.flags & 32 && (je(u),
                p.flags &= -33),
                p = O1(l),
                cg(l, p, u);
                break;
            case 3:
            case 4:
                u = p.stateNode.containerInfo,
                p = O1(l),
                ug(l, p, u);
                break;
            default:
                throw Error(o(161))
            }
        }
    }
    function ug(l, u, p) {
        var y = l.tag;
        if (y === 5 || y === 6)
            l = l.stateNode,
            u ? St(p, l, u) : Te(p, l);
        else if (y !== 4 && (l = l.child,
        l !== null))
            for (ug(l, u, p),
            l = l.sibling; l !== null; )
                ug(l, u, p),
                l = l.sibling
    }
    function cg(l, u, p) {
        var y = l.tag;
        if (y === 5 || y === 6)
            l = l.stateNode,
            u ? nn(p, l, u) : et(p, l);
        else if (y !== 4 && (l = l.child,
        l !== null))
            for (cg(l, u, p),
            l = l.sibling; l !== null; )
                cg(l, u, p),
                l = l.sibling
    }
    function k1(l, u, p) {
        for (var y = u, E = !1, A, k; ; ) {
            if (!E) {
                E = y.return;
                e: for (; ; ) {
                    if (E === null)
                        throw Error(o(160));
                    switch (A = E.stateNode,
                    E.tag) {
                    case 5:
                        k = !1;
                        break e;
                    case 3:
                        A = A.containerInfo,
                        k = !0;
                        break e;
                    case 4:
                        A = A.containerInfo,
                        k = !0;
                        break e
                    }
                    E = E.return
                }
                E = !0
            }
            if (y.tag === 5 || y.tag === 6)
                N1(l, y, p),
                k ? Ye(A, y.stateNode) : Ke(A, y.stateNode);
            else if (y.tag === 18)
                k ? $(A, y.stateNode) : ne(A, y.stateNode);
            else if (y.tag === 4) {
                if (y.child !== null) {
                    A = y.stateNode.containerInfo,
                    k = !0,
                    y.child.return = y,
                    y = y.child;
                    continue
                }
            } else if (I1(l, y, p),
            y.child !== null) {
                y.child.return = y,
                y = y.child;
                continue
            }
            if (y === u)
                break;
            for (; y.sibling === null; ) {
                if (y.return === null || y.return === u)
                    return;
                y = y.return,
                y.tag === 4 && (E = !1)
            }
            y.sibling.return = y.return,
            y = y.sibling
        }
    }
    function fg(l, u) {
        if (He) {
            switch (u.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                Ro(3, u, u.return),
                Au(3, u),
                Ro(5, u, u.return);
                return;
            case 1:
                return;
            case 5:
                var p = u.stateNode;
                if (p != null) {
                    var y = u.memoizedProps;
                    l = l !== null ? l.memoizedProps : y;
                    var E = u.type
                      , A = u.updateQueue;
                    u.updateQueue = null,
                    A !== null && we(p, A, E, l, y, u)
                }
                return;
            case 6:
                if (u.stateNode === null)
                    throw Error(o(162));
                p = u.memoizedProps,
                Re(u.stateNode, l !== null ? l.memoizedProps : p, p);
                return;
            case 3:
                ge && l !== null && l.memoizedState.isDehydrated && j(u.stateNode.containerInfo);
                return;
            case 12:
                return;
            case 13:
                sh(u);
                return;
            case 19:
                sh(u);
                return;
            case 17:
                return
            }
            throw Error(o(163))
        }
        switch (u.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            Ro(3, u, u.return),
            Au(3, u),
            Ro(5, u, u.return);
            return;
        case 12:
            return;
        case 13:
            sh(u);
            return;
        case 19:
            sh(u);
            return;
        case 3:
            ge && l !== null && l.memoizedState.isDehydrated && j(u.stateNode.containerInfo);
            break;
        case 22:
        case 23:
            return
        }
        e: if (z) {
            switch (u.tag) {
            case 1:
            case 5:
            case 6:
                break e;
            case 3:
            case 4:
                u = u.stateNode,
                Dt(u.containerInfo, u.pendingChildren);
                break e
            }
            throw Error(o(163))
        }
    }
    function sh(l) {
        var u = l.updateQueue;
        if (u !== null) {
            l.updateQueue = null;
            var p = l.stateNode;
            p === null && (p = l.stateNode = new pb),
            u.forEach(function(y) {
                var E = Tb.bind(null, l, y);
                p.has(y) || (p.add(y),
                y.then(E, E))
            })
        }
    }
    function gb(l, u) {
        for (Le = u; Le !== null; ) {
            u = Le;
            var p = u.deletions;
            if (p !== null)
                for (var y = 0; y < p.length; y++) {
                    var E = p[y];
                    try {
                        var A = l;
                        He ? k1(A, E, u) : N1(A, E, u);
                        var k = E.alternate;
                        k !== null && (k.return = null),
                        E.return = null
                    } catch (qe) {
                        xi(E, u, qe)
                    }
                }
            if (p = u.child,
            u.subtreeFlags & 12854 && p !== null)
                p.return = u,
                Le = p;
            else
                for (; Le !== null; ) {
                    u = Le;
                    try {
                        var W = u.flags;
                        if (W & 32 && He && je(u.stateNode),
                        W & 512) {
                            var ae = u.alternate;
                            if (ae !== null) {
                                var xe = ae.ref;
                                xe !== null && (typeof xe == "function" ? xe(null) : xe.current = null)
                            }
                        }
                        if (W & 8192)
                            switch (u.tag) {
                            case 13:
                                if (u.memoizedState !== null) {
                                    var Ve = u.alternate;
                                    (Ve === null || Ve.memoizedState === null) && (yg = bn())
                                }
                                break;
                            case 22:
                                var dt = u.memoizedState !== null
                                  , Qe = u.alternate
                                  , kt = Qe !== null && Qe.memoizedState !== null;
                                if (p = u,
                                He) {
                                    e: if (y = p,
                                    E = dt,
                                    A = null,
                                    He)
                                        for (var Je = y; ; ) {
                                            if (Je.tag === 5) {
                                                if (A === null) {
                                                    A = Je;
                                                    var jn = Je.stateNode;
                                                    E ? Tt(jn) : zt(Je.stateNode, Je.memoizedProps)
                                                }
                                            } else if (Je.tag === 6) {
                                                if (A === null) {
                                                    var tr = Je.stateNode;
                                                    E ? ht(tr) : X(tr, Je.memoizedProps)
                                                }
                                            } else if ((Je.tag !== 22 && Je.tag !== 23 || Je.memoizedState === null || Je === y) && Je.child !== null) {
                                                Je.child.return = Je,
                                                Je = Je.child;
                                                continue
                                            }
                                            if (Je === y)
                                                break;
                                            for (; Je.sibling === null; ) {
                                                if (Je.return === null || Je.return === y)
                                                    break e;
                                                A === Je && (A = null),
                                                Je = Je.return
                                            }
                                            A === Je && (A = null),
                                            Je.sibling.return = Je.return,
                                            Je = Je.sibling
                                        }
                                }
                                if (dt && !kt && p.mode & 1) {
                                    Le = p;
                                    for (var Q = p.child; Q !== null; ) {
                                        for (p = Le = Q; Le !== null; ) {
                                            y = Le;
                                            var Y = y.child;
                                            switch (y.tag) {
                                            case 0:
                                            case 11:
                                            case 14:
                                            case 15:
                                                Ro(4, y, y.return);
                                                break;
                                            case 1:
                                                rh(y, y.return);
                                                var re = y.stateNode;
                                                if (typeof re.componentWillUnmount == "function") {
                                                    var Ie = y.return;
                                                    try {
                                                        re.props = y.memoizedProps,
                                                        re.state = y.memoizedState,
                                                        re.componentWillUnmount()
                                                    } catch (qe) {
                                                        xi(y, Ie, qe)
                                                    }
                                                }
                                                break;
                                            case 5:
                                                rh(y, y.return);
                                                break;
                                            case 22:
                                                if (y.memoizedState !== null) {
                                                    H1(p);
                                                    continue
                                                }
                                            }
                                            Y !== null ? (Y.return = y,
                                            Le = Y) : H1(p)
                                        }
                                        Q = Q.sibling
                                    }
                                }
                            }
                        switch (W & 4102) {
                        case 2:
                            F1(u),
                            u.flags &= -3;
                            break;
                        case 6:
                            F1(u),
                            u.flags &= -3,
                            fg(u.alternate, u);
                            break;
                        case 4096:
                            u.flags &= -4097;
                            break;
                        case 4100:
                            u.flags &= -4097,
                            fg(u.alternate, u);
                            break;
                        case 4:
                            fg(u.alternate, u)
                        }
                    } catch (qe) {
                        xi(u, u.return, qe)
                    }
                    if (p = u.sibling,
                    p !== null) {
                        p.return = u.return,
                        Le = p;
                        break
                    }
                    Le = u.return
                }
        }
    }
    function vb(l, u, p) {
        Le = l,
        z1(l)
    }
    function z1(l, u, p) {
        for (var y = (l.mode & 1) !== 0; Le !== null; ) {
            var E = Le
              , A = E.child;
            if (E.tag === 22 && y) {
                var k = E.memoizedState !== null || ih;
                if (!k) {
                    var W = E.alternate
                      , ae = W !== null && W.memoizedState !== null || Co;
                    W = ih;
                    var xe = Co;
                    if (ih = k,
                    (Co = ae) && !xe)
                        for (Le = E; Le !== null; )
                            k = Le,
                            ae = k.child,
                            k.tag === 22 && k.memoizedState !== null ? V1(E) : ae !== null ? (ae.return = k,
                            Le = ae) : V1(E);
                    for (; A !== null; )
                        Le = A,
                        z1(A),
                        A = A.sibling;
                    Le = E,
                    ih = W,
                    Co = xe
                }
                B1(l)
            } else
                E.subtreeFlags & 8772 && A !== null ? (A.return = E,
                Le = A) : B1(l)
        }
    }
    function B1(l) {
        for (; Le !== null; ) {
            var u = Le;
            if (u.flags & 8772) {
                var p = u.alternate;
                try {
                    if (u.flags & 8772)
                        switch (u.tag) {
                        case 0:
                        case 11:
                        case 15:
                            Co || Au(5, u);
                            break;
                        case 1:
                            var y = u.stateNode;
                            if (u.flags & 4 && !Co)
                                if (p === null)
                                    y.componentDidMount();
                                else {
                                    var E = u.elementType === u.type ? p.memoizedProps : hr(u.type, p.memoizedProps);
                                    y.componentDidUpdate(E, p.memoizedState, y.__reactInternalSnapshotBeforeUpdate)
                                }
                            var A = u.updateQueue;
                            A !== null && Dx(u, A, y);
                            break;
                        case 3:
                            var k = u.updateQueue;
                            if (k !== null) {
                                if (p = null,
                                u.child !== null)
                                    switch (u.child.tag) {
                                    case 5:
                                        p = J(u.child.stateNode);
                                        break;
                                    case 1:
                                        p = u.child.stateNode
                                    }
                                Dx(u, k, p)
                            }
                            break;
                        case 5:
                            var W = u.stateNode;
                            p === null && u.flags & 4 && ot(W, u.type, u.memoizedProps, u);
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (ge && u.memoizedState === null) {
                                var ae = u.alternate;
                                if (ae !== null) {
                                    var xe = ae.memoizedState;
                                    if (xe !== null) {
                                        var Ve = xe.dehydrated;
                                        Ve !== null && te(Ve)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                            break;
                        default:
                            throw Error(o(163))
                        }
                    Co || u.flags & 512 && lg(u)
                } catch (dt) {
                    xi(u, u.return, dt)
                }
            }
            if (u === l) {
                Le = null;
                break
            }
            if (p = u.sibling,
            p !== null) {
                p.return = u.return,
                Le = p;
                break
            }
            Le = u.return
        }
    }
    function H1(l) {
        for (; Le !== null; ) {
            var u = Le;
            if (u === l) {
                Le = null;
                break
            }
            var p = u.sibling;
            if (p !== null) {
                p.return = u.return,
                Le = p;
                break
            }
            Le = u.return
        }
    }
    function V1(l) {
        for (; Le !== null; ) {
            var u = Le;
            try {
                switch (u.tag) {
                case 0:
                case 11:
                case 15:
                    var p = u.return;
                    try {
                        Au(4, u)
                    } catch (ae) {
                        xi(u, p, ae)
                    }
                    break;
                case 1:
                    var y = u.stateNode;
                    if (typeof y.componentDidMount == "function") {
                        var E = u.return;
                        try {
                            y.componentDidMount()
                        } catch (ae) {
                            xi(u, E, ae)
                        }
                    }
                    var A = u.return;
                    try {
                        lg(u)
                    } catch (ae) {
                        xi(u, A, ae)
                    }
                    break;
                case 5:
                    var k = u.return;
                    try {
                        lg(u)
                    } catch (ae) {
                        xi(u, k, ae)
                    }
                }
            } catch (ae) {
                xi(u, u.return, ae)
            }
            if (u === l) {
                Le = null;
                break
            }
            var W = u.sibling;
            if (W !== null) {
                W.return = u.return,
                Le = W;
                break
            }
            Le = u.return
        }
    }
    var oh = 0
      , ah = 1
      , lh = 2
      , uh = 3
      , ch = 4;
    if (typeof Symbol == "function" && Symbol.for) {
        var Cu = Symbol.for;
        oh = Cu("selector.component"),
        ah = Cu("selector.has_pseudo_class"),
        lh = Cu("selector.role"),
        uh = Cu("selector.test_id"),
        ch = Cu("selector.text")
    }
    function hg(l) {
        var u = fe(l);
        if (u != null) {
            if (typeof u.memoizedProps["data-testname"] != "string")
                throw Error(o(364));
            return u
        }
        if (l = O(l),
        l === null)
            throw Error(o(362));
        return l.stateNode.current
    }
    function dg(l, u) {
        switch (u.$$typeof) {
        case oh:
            if (l.type === u.value)
                return !0;
            break;
        case ah:
            e: {
                u = u.value,
                l = [l, 0];
                for (var p = 0; p < l.length; ) {
                    var y = l[p++]
                      , E = l[p++]
                      , A = u[E];
                    if (y.tag !== 5 || !le(y)) {
                        for (; A != null && dg(y, A); )
                            E++,
                            A = u[E];
                        if (E === u.length) {
                            u = !0;
                            break e
                        } else
                            for (y = y.child; y !== null; )
                                l.push(y, E),
                                y = y.sibling
                    }
                }
                u = !1
            }
            return u;
        case lh:
            if (l.tag === 5 && ye(l.stateNode, u.value))
                return !0;
            break;
        case ch:
            if ((l.tag === 5 || l.tag === 6) && (l = oe(l),
            l !== null && 0 <= l.indexOf(u.value)))
                return !0;
            break;
        case uh:
            if (l.tag === 5 && (l = l.memoizedProps["data-testname"],
            typeof l == "string" && l.toLowerCase() === u.value.toLowerCase()))
                return !0;
            break;
        default:
            throw Error(o(365))
        }
        return !1
    }
    function pg(l) {
        switch (l.$$typeof) {
        case oh:
            return "<" + (b(l.value) || "Unknown") + ">";
        case ah:
            return ":has(" + (pg(l) || "") + ")";
        case lh:
            return '[role="' + l.value + '"]';
        case ch:
            return '"' + l.value + '"';
        case uh:
            return '[data-testname="' + l.value + '"]';
        default:
            throw Error(o(365))
        }
    }
    function G1(l, u) {
        var p = [];
        l = [l, 0];
        for (var y = 0; y < l.length; ) {
            var E = l[y++]
              , A = l[y++]
              , k = u[A];
            if (E.tag !== 5 || !le(E)) {
                for (; k != null && dg(E, k); )
                    A++,
                    k = u[A];
                if (A === u.length)
                    p.push(E);
                else
                    for (E = E.child; E !== null; )
                        l.push(E, A),
                        E = E.sibling
            }
        }
        return p
    }
    function mg(l, u) {
        if (!ft)
            throw Error(o(363));
        l = hg(l),
        l = G1(l, u),
        u = [],
        l = Array.from(l);
        for (var p = 0; p < l.length; ) {
            var y = l[p++];
            if (y.tag === 5)
                le(y) || u.push(y.stateNode);
            else
                for (y = y.child; y !== null; )
                    l.push(y),
                    y = y.sibling
        }
        return u
    }
    var yb = Math.ceil
      , fh = a.ReactCurrentDispatcher
      , gg = a.ReactCurrentOwner
      , cn = a.ReactCurrentBatchConfig
      , Mt = 0
      , mn = null
      , gn = null
      , zn = 0
      , Ni = 0
      , Ba = Cn(0)
      , xn = 0
      , Ru = null
      , Ha = 0
      , hh = 0
      , vg = 0
      , bu = null
      , yi = null
      , yg = 0
      , _g = 1 / 0;
    function Va() {
        _g = bn() + 500
    }
    var dh = !1
      , xg = null
      , Is = null
      , ph = !1
      , Ns = null
      , mh = 0
      , Pu = 0
      , Sg = null
      , gh = -1
      , vh = 0;
    function oi() {
        return Mt & 6 ? bn() : gh !== -1 ? gh : gh = bn()
    }
    function Ds(l) {
        return l.mode & 1 ? Mt & 2 && zn !== 0 ? zn & -zn : eb.transition !== null ? (vh === 0 && (l = Pf,
        Pf <<= 1,
        !(Pf & 4194240) && (Pf = 64),
        vh = l),
        vh) : (l = Pt,
        l !== 0 ? l : pe()) : 1
    }
    function $i(l, u, p) {
        if (50 < Pu)
            throw Pu = 0,
            Sg = null,
            Error(o(185));
        var y = yh(l, u);
        return y === null ? null : (du(y, u, p),
        (!(Mt & 2) || y !== mn) && (y === mn && (!(Mt & 2) && (hh |= u),
        xn === 4 && Us(y, zn)),
        _i(y, p),
        u === 1 && Mt === 0 && !(l.mode & 1) && (Va(),
        Df && Dr())),
        y)
    }
    function yh(l, u) {
        l.lanes |= u;
        var p = l.alternate;
        for (p !== null && (p.lanes |= u),
        p = l,
        l = l.return; l !== null; )
            l.childLanes |= u,
            p = l.alternate,
            p !== null && (p.childLanes |= u),
            p = l,
            l = l.return;
        return p.tag === 3 ? p.stateNode : null
    }
    function _i(l, u) {
        var p = l.callbackNode;
        XR(l, u);
        var y = If(l, l === mn ? zn : 0);
        if (y === 0)
            p !== null && bx(p),
            l.callbackNode = null,
            l.callbackPriority = 0;
        else if (u = y & -y,
        l.callbackPriority !== u) {
            if (p != null && bx(p),
            u === 1)
                l.tag === 0 ? $R(X1.bind(null, l)) : Px(X1.bind(null, l)),
                De ? Ge(function() {
                    Mt === 0 && Dr()
                }) : bm(Pm, Dr),
                p = null;
            else {
                switch (Rx(y)) {
                case 1:
                    p = Pm;
                    break;
                case 4:
                    p = ZR;
                    break;
                case 16:
                    p = Lm;
                    break;
                case 536870912:
                    p = JR;
                    break;
                default:
                    p = Lm
                }
                p = eS(p, W1.bind(null, l))
            }
            l.callbackPriority = u,
            l.callbackNode = p
        }
    }
    function W1(l, u) {
        if (gh = -1,
        vh = 0,
        Mt & 6)
            throw Error(o(327));
        var p = l.callbackNode;
        if (Lo() && l.callbackNode !== p)
            return null;
        var y = If(l, l === mn ? zn : 0);
        if (y === 0)
            return null;
        if (y & 30 || y & l.expiredLanes || u)
            u = _h(l, y);
        else {
            u = y;
            var E = Mt;
            Mt |= 2;
            var A = q1();
            (mn !== l || zn !== u) && (Va(),
            bo(l, u));
            do
                try {
                    Sb();
                    break
                } catch (W) {
                    j1(l, W)
                }
            while (!0);
            Dm(),
            fh.current = A,
            Mt = E,
            gn !== null ? u = 0 : (mn = null,
            zn = 0,
            u = xn)
        }
        if (u !== 0) {
            if (u === 2 && (E = Am(l),
            E !== 0 && (y = E,
            u = Mg(l, E))),
            u === 1)
                throw p = Ru,
                bo(l, 0),
                Us(l, y),
                _i(l, bn()),
                p;
            if (u === 6)
                Us(l, y);
            else {
                if (E = l.current.alternate,
                !(y & 30) && !_b(E) && (u = _h(l, y),
                u === 2 && (A = Am(l),
                A !== 0 && (y = A,
                u = Mg(l, A))),
                u === 1))
                    throw p = Ru,
                    bo(l, 0),
                    Us(l, y),
                    _i(l, bn()),
                    p;
                switch (l.finishedWork = E,
                l.finishedLanes = y,
                u) {
                case 0:
                case 1:
                    throw Error(o(345));
                case 2:
                    Po(l, yi);
                    break;
                case 3:
                    if (Us(l, y),
                    (y & 130023424) === y && (u = yg + 500 - bn(),
                    10 < u)) {
                        if (If(l, 0) !== 0)
                            break;
                        if (E = l.suspendedLanes,
                        (E & y) !== y) {
                            oi(),
                            l.pingedLanes |= l.suspendedLanes & E;
                            break
                        }
                        l.timeoutHandle = ke(Po.bind(null, l, yi), u);
                        break
                    }
                    Po(l, yi);
                    break;
                case 4:
                    if (Us(l, y),
                    (y & 4194240) === y)
                        break;
                    for (u = l.eventTimes,
                    E = -1; 0 < y; ) {
                        var k = 31 - bi(y);
                        A = 1 << k,
                        k = u[k],
                        k > E && (E = k),
                        y &= ~A
                    }
                    if (y = E,
                    y = bn() - y,
                    y = (120 > y ? 120 : 480 > y ? 480 : 1080 > y ? 1080 : 1920 > y ? 1920 : 3e3 > y ? 3e3 : 4320 > y ? 4320 : 1960 * yb(y / 1960)) - y,
                    10 < y) {
                        l.timeoutHandle = ke(Po.bind(null, l, yi), y);
                        break
                    }
                    Po(l, yi);
                    break;
                case 5:
                    Po(l, yi);
                    break;
                default:
                    throw Error(o(329))
                }
            }
        }
        return _i(l, bn()),
        l.callbackNode === p ? W1.bind(null, l) : null
    }
    function Mg(l, u) {
        var p = bu;
        return l.current.memoizedState.isDehydrated && (bo(l, u).flags |= 256),
        l = _h(l, u),
        l !== 2 && (u = yi,
        yi = p,
        u !== null && wg(u)),
        l
    }
    function wg(l) {
        yi === null ? yi = l : yi.push.apply(yi, l)
    }
    function _b(l) {
        for (var u = l; ; ) {
            if (u.flags & 16384) {
                var p = u.updateQueue;
                if (p !== null && (p = p.stores,
                p !== null))
                    for (var y = 0; y < p.length; y++) {
                        var E = p[y]
                          , A = E.getSnapshot;
                        E = E.value;
                        try {
                            if (!Nr(A(), E))
                                return !1
                        } catch {
                            return !1
                        }
                    }
            }
            if (p = u.child,
            u.subtreeFlags & 16384 && p !== null)
                p.return = u,
                u = p;
            else {
                if (u === l)
                    break;
                for (; u.sibling === null; ) {
                    if (u.return === null || u.return === l)
                        return !0;
                    u = u.return
                }
                u.sibling.return = u.return,
                u = u.sibling
            }
        }
        return !0
    }
    function Us(l, u) {
        for (u &= ~vg,
        u &= ~hh,
        l.suspendedLanes |= u,
        l.pingedLanes &= ~u,
        l = l.expirationTimes; 0 < u; ) {
            var p = 31 - bi(u)
              , y = 1 << p;
            l[p] = -1,
            u &= ~y
        }
    }
    function X1(l) {
        if (Mt & 6)
            throw Error(o(327));
        Lo();
        var u = If(l, 0);
        if (!(u & 1))
            return _i(l, bn()),
            null;
        var p = _h(l, u);
        if (l.tag !== 0 && p === 2) {
            var y = Am(l);
            y !== 0 && (u = y,
            p = Mg(l, y))
        }
        if (p === 1)
            throw p = Ru,
            bo(l, 0),
            Us(l, u),
            _i(l, bn()),
            p;
        if (p === 6)
            throw Error(o(345));
        return l.finishedWork = l.current.alternate,
        l.finishedLanes = u,
        Po(l, yi),
        _i(l, bn()),
        null
    }
    function Y1(l) {
        Ns !== null && Ns.tag === 0 && !(Mt & 6) && Lo();
        var u = Mt;
        Mt |= 1;
        var p = cn.transition
          , y = Pt;
        try {
            if (cn.transition = null,
            Pt = 1,
            l)
                return l()
        } finally {
            Pt = y,
            cn.transition = p,
            Mt = u,
            !(Mt & 6) && Dr()
        }
    }
    function Eg() {
        Ni = Ba.current,
        it(Ba)
    }
    function bo(l, u) {
        l.finishedWork = null,
        l.finishedLanes = 0;
        var p = l.timeoutHandle;
        if (p !== ze && (l.timeoutHandle = ze,
        Xe(p)),
        gn !== null)
            for (p = gn.return; p !== null; ) {
                var y = p;
                switch (Hm(y),
                y.tag) {
                case 1:
                    y = y.type.childContextTypes,
                    y != null && un();
                    break;
                case 3:
                    ka(),
                    it(rn),
                    it(vt),
                    qm();
                    break;
                case 5:
                    Ym(y);
                    break;
                case 4:
                    ka();
                    break;
                case 13:
                    it(Jt);
                    break;
                case 19:
                    it(Jt);
                    break;
                case 10:
                    Um(y.type._context);
                    break;
                case 22:
                case 23:
                    Eg()
                }
                p = p.return
            }
        if (mn = l,
        gn = l = Os(l.current, null),
        zn = Ni = u,
        xn = 0,
        Ru = null,
        vg = hh = Ha = 0,
        yi = bu = null,
        Ur !== null) {
            for (u = 0; u < Ur.length; u++)
                if (p = Ur[u],
                y = p.interleaved,
                y !== null) {
                    p.interleaved = null;
                    var E = y.next
                      , A = p.pending;
                    if (A !== null) {
                        var k = A.next;
                        A.next = E,
                        y.next = k
                    }
                    p.pending = y
                }
            Ur = null
        }
        return l
    }
    function j1(l, u) {
        do {
            var p = gn;
            try {
                if (Dm(),
                Xf.current = Kf,
                Yf) {
                    for (var y = sn.memoizedState; y !== null; ) {
                        var E = y.queue;
                        E !== null && (E.pending = null),
                        y = y.next
                    }
                    Yf = !1
                }
                if (za = 0,
                Pn = Wn = sn = null,
                _u = !1,
                xu = 0,
                gg.current = null,
                p === null || p.return === null) {
                    xn = 1,
                    Ru = u,
                    gn = null;
                    break
                }
                e: {
                    var A = l
                      , k = p.return
                      , W = p
                      , ae = u;
                    if (u = zn,
                    W.flags |= 32768,
                    ae !== null && typeof ae == "object" && typeof ae.then == "function") {
                        var xe = ae
                          , Ve = W
                          , dt = Ve.tag;
                        if (!(Ve.mode & 1) && (dt === 0 || dt === 11 || dt === 15)) {
                            var Qe = Ve.alternate;
                            Qe ? (Ve.updateQueue = Qe.updateQueue,
                            Ve.memoizedState = Qe.memoizedState,
                            Ve.lanes = Qe.lanes) : (Ve.updateQueue = null,
                            Ve.memoizedState = null)
                        }
                        var kt = p1(k);
                        if (kt !== null) {
                            kt.flags &= -257,
                            m1(kt, k, W, A, u),
                            kt.mode & 1 && d1(A, xe, u),
                            u = kt,
                            ae = xe;
                            var Je = u.updateQueue;
                            if (Je === null) {
                                var jn = new Set;
                                jn.add(ae),
                                u.updateQueue = jn
                            } else
                                Je.add(ae);
                            break e
                        } else {
                            if (!(u & 1)) {
                                d1(A, xe, u),
                                Tg();
                                break e
                            }
                            ae = Error(o(426))
                        }
                    } else if (Yt && W.mode & 1) {
                        var tr = p1(k);
                        if (tr !== null) {
                            !(tr.flags & 65536) && (tr.flags |= 256),
                            m1(tr, k, W, A, u),
                            Wm(ae);
                            break e
                        }
                    }
                    A = ae,
                    xn !== 4 && (xn = 2),
                    bu === null ? bu = [A] : bu.push(A),
                    ae = tg(ae, W),
                    W = k;
                    do {
                        switch (W.tag) {
                        case 3:
                            W.flags |= 65536,
                            u &= -u,
                            W.lanes |= u;
                            var Q = f1(W, ae, u);
                            Nx(W, Q);
                            break e;
                        case 1:
                            A = ae;
                            var Y = W.type
                              , re = W.stateNode;
                            if (!(W.flags & 128) && (typeof Y.getDerivedStateFromError == "function" || re !== null && typeof re.componentDidCatch == "function" && (Is === null || !Is.has(re)))) {
                                W.flags |= 65536,
                                u &= -u,
                                W.lanes |= u;
                                var Ie = h1(W, A, u);
                                Nx(W, Ie);
                                break e
                            }
                        }
                        W = W.return
                    } while (W !== null)
                }
                J1(p)
            } catch (qe) {
                u = qe,
                gn === p && p !== null && (gn = p = p.return);
                continue
            }
            break
        } while (!0)
    }
    function q1() {
        var l = fh.current;
        return fh.current = Kf,
        l === null ? Kf : l
    }
    function Tg() {
        (xn === 0 || xn === 3 || xn === 2) && (xn = 4),
        mn === null || !(Ha & 268435455) && !(hh & 268435455) || Us(mn, zn)
    }
    function _h(l, u) {
        var p = Mt;
        Mt |= 2;
        var y = q1();
        mn === l && zn === u || bo(l, u);
        do
            try {
                xb();
                break
            } catch (E) {
                j1(l, E)
            }
        while (!0);
        if (Dm(),
        Mt = p,
        fh.current = y,
        gn !== null)
            throw Error(o(261));
        return mn = null,
        zn = 0,
        xn
    }
    function xb() {
        for (; gn !== null; )
            Z1(gn)
    }
    function Sb() {
        for (; gn !== null && !jR(); )
            Z1(gn)
    }
    function Z1(l) {
        var u = $1(l.alternate, l, Ni);
        l.memoizedProps = l.pendingProps,
        u === null ? J1(l) : gn = u,
        gg.current = null
    }
    function J1(l) {
        var u = l;
        do {
            var p = u.alternate;
            if (l = u.return,
            u.flags & 32768) {
                if (p = db(p, u),
                p !== null) {
                    p.flags &= 32767,
                    gn = p;
                    return
                }
                if (l !== null)
                    l.flags |= 32768,
                    l.subtreeFlags = 0,
                    l.deletions = null;
                else {
                    xn = 6,
                    gn = null;
                    return
                }
            } else if (p = cb(p, u, Ni),
            p !== null) {
                gn = p;
                return
            }
            if (u = u.sibling,
            u !== null) {
                gn = u;
                return
            }
            gn = u = l
        } while (u !== null);
        xn === 0 && (xn = 5)
    }
    function Po(l, u) {
        var p = Pt
          , y = cn.transition;
        try {
            cn.transition = null,
            Pt = 1,
            Mb(l, u, p)
        } finally {
            cn.transition = y,
            Pt = p
        }
        return null
    }
    function Mb(l, u, p) {
        do
            Lo();
        while (Ns !== null);
        if (Mt & 6)
            throw Error(o(327));
        var y = l.finishedWork
          , E = l.finishedLanes;
        if (y === null)
            return null;
        if (l.finishedWork = null,
        l.finishedLanes = 0,
        y === l.current)
            throw Error(o(177));
        l.callbackNode = null,
        l.callbackPriority = 0;
        var A = y.lanes | y.childLanes;
        if (YR(l, A),
        l === mn && (gn = mn = null,
        zn = 0),
        !(y.subtreeFlags & 2064) && !(y.flags & 2064) || ph || (ph = !0,
        eS(Lm, function() {
            return Lo(),
            null
        })),
        A = (y.flags & 15990) !== 0,
        y.subtreeFlags & 15990 || A) {
            A = cn.transition,
            cn.transition = null;
            var k = Pt;
            Pt = 1;
            var W = Mt;
            Mt |= 4,
            gg.current = null,
            mb(l, y),
            gb(l, y),
            V(l.containerInfo),
            l.current = y,
            vb(y),
            qR(),
            Mt = W,
            Pt = k,
            cn.transition = A
        } else
            l.current = y;
        if (ph && (ph = !1,
        Ns = l,
        mh = E),
        A = l.pendingLanes,
        A === 0 && (Is = null),
        KR(y.stateNode),
        _i(l, bn()),
        u !== null)
            for (p = l.onRecoverableError,
            y = 0; y < u.length; y++)
                p(u[y]);
        if (dh)
            throw dh = !1,
            l = xg,
            xg = null,
            l;
        return mh & 1 && l.tag !== 0 && Lo(),
        A = l.pendingLanes,
        A & 1 ? l === Sg ? Pu++ : (Pu = 0,
        Sg = l) : Pu = 0,
        Dr(),
        null
    }
    function Lo() {
        if (Ns !== null) {
            var l = Rx(mh)
              , u = cn.transition
              , p = Pt;
            try {
                if (cn.transition = null,
                Pt = 16 > l ? 16 : l,
                Ns === null)
                    var y = !1;
                else {
                    if (l = Ns,
                    Ns = null,
                    mh = 0,
                    Mt & 6)
                        throw Error(o(331));
                    var E = Mt;
                    for (Mt |= 4,
                    Le = l.current; Le !== null; ) {
                        var A = Le
                          , k = A.child;
                        if (Le.flags & 16) {
                            var W = A.deletions;
                            if (W !== null) {
                                for (var ae = 0; ae < W.length; ae++) {
                                    var xe = W[ae];
                                    for (Le = xe; Le !== null; ) {
                                        var Ve = Le;
                                        switch (Ve.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Ro(8, Ve, A)
                                        }
                                        var dt = Ve.child;
                                        if (dt !== null)
                                            dt.return = Ve,
                                            Le = dt;
                                        else
                                            for (; Le !== null; ) {
                                                Ve = Le;
                                                var Qe = Ve.sibling
                                                  , kt = Ve.return;
                                                if (D1(Ve),
                                                Ve === xe) {
                                                    Le = null;
                                                    break
                                                }
                                                if (Qe !== null) {
                                                    Qe.return = kt,
                                                    Le = Qe;
                                                    break
                                                }
                                                Le = kt
                                            }
                                    }
                                }
                                var Je = A.alternate;
                                if (Je !== null) {
                                    var jn = Je.child;
                                    if (jn !== null) {
                                        Je.child = null;
                                        do {
                                            var tr = jn.sibling;
                                            jn.sibling = null,
                                            jn = tr
                                        } while (jn !== null)
                                    }
                                }
                                Le = A
                            }
                        }
                        if (A.subtreeFlags & 2064 && k !== null)
                            k.return = A,
                            Le = k;
                        else
                            e: for (; Le !== null; ) {
                                if (A = Le,
                                A.flags & 2048)
                                    switch (A.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Ro(9, A, A.return)
                                    }
                                var Q = A.sibling;
                                if (Q !== null) {
                                    Q.return = A.return,
                                    Le = Q;
                                    break e
                                }
                                Le = A.return
                            }
                    }
                    var Y = l.current;
                    for (Le = Y; Le !== null; ) {
                        k = Le;
                        var re = k.child;
                        if (k.subtreeFlags & 2064 && re !== null)
                            re.return = k,
                            Le = re;
                        else
                            e: for (k = Y; Le !== null; ) {
                                if (W = Le,
                                W.flags & 2048)
                                    try {
                                        switch (W.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Au(9, W)
                                        }
                                    } catch (qe) {
                                        xi(W, W.return, qe)
                                    }
                                if (W === k) {
                                    Le = null;
                                    break e
                                }
                                var Ie = W.sibling;
                                if (Ie !== null) {
                                    Ie.return = W.return,
                                    Le = Ie;
                                    break e
                                }
                                Le = W.return
                            }
                    }
                    if (Mt = E,
                    Dr(),
                    Ir && typeof Ir.onPostCommitFiberRoot == "function")
                        try {
                            Ir.onPostCommitFiberRoot(Nf, l)
                        } catch {}
                    y = !0
                }
                return y
            } finally {
                Pt = p,
                cn.transition = u
            }
        }
        return !1
    }
    function K1(l, u, p) {
        u = tg(p, u),
        u = f1(l, u, 1),
        Ls(l, u),
        u = oi(),
        l = yh(l, 1),
        l !== null && (du(l, 1, u),
        _i(l, u))
    }
    function xi(l, u, p) {
        if (l.tag === 3)
            K1(l, l, p);
        else
            for (; u !== null; ) {
                if (u.tag === 3) {
                    K1(u, l, p);
                    break
                } else if (u.tag === 1) {
                    var y = u.stateNode;
                    if (typeof u.type.getDerivedStateFromError == "function" || typeof y.componentDidCatch == "function" && (Is === null || !Is.has(y))) {
                        l = tg(p, l),
                        l = h1(u, l, 1),
                        Ls(u, l),
                        l = oi(),
                        u = yh(u, 1),
                        u !== null && (du(u, 1, l),
                        _i(u, l));
                        break
                    }
                }
                u = u.return
            }
    }
    function wb(l, u, p) {
        var y = l.pingCache;
        y !== null && y.delete(u),
        u = oi(),
        l.pingedLanes |= l.suspendedLanes & p,
        mn === l && (zn & p) === p && (xn === 4 || xn === 3 && (zn & 130023424) === zn && 500 > bn() - yg ? bo(l, 0) : vg |= p),
        _i(l, u)
    }
    function Q1(l, u) {
        u === 0 && (l.mode & 1 ? (u = Lf,
        Lf <<= 1,
        !(Lf & 130023424) && (Lf = 4194304)) : u = 1);
        var p = oi();
        l = yh(l, u),
        l !== null && (du(l, u, p),
        _i(l, p))
    }
    function Eb(l) {
        var u = l.memoizedState
          , p = 0;
        u !== null && (p = u.retryLane),
        Q1(l, p)
    }
    function Tb(l, u) {
        var p = 0;
        switch (l.tag) {
        case 13:
            var y = l.stateNode
              , E = l.memoizedState;
            E !== null && (p = E.retryLane);
            break;
        case 19:
            y = l.stateNode;
            break;
        default:
            throw Error(o(314))
        }
        y !== null && y.delete(u),
        Q1(l, p)
    }
    var $1;
    $1 = function(l, u, p) {
        if (l !== null)
            if (l.memoizedProps !== u.pendingProps || rn.current)
                Ii = !0;
            else {
                if (!(l.lanes & p) && !(u.flags & 128))
                    return Ii = !1,
                    hb(l, u, p);
                Ii = !!(l.flags & 131072)
            }
        else
            Ii = !1,
            Yt && u.flags & 1048576 && zx(u, Vf, u.index);
        switch (u.lanes = 0,
        u.tag) {
        case 2:
            var y = u.type;
            l !== null && (l.alternate = null,
            u.alternate = null,
            u.flags |= 2),
            l = u.pendingProps;
            var E = ji(u, vt.current);
            Ia(u, p),
            E = Jm(null, u, y, l, E, p);
            var A = Km();
            return u.flags |= 1,
            typeof E == "object" && E !== null && typeof E.render == "function" && E.$$typeof === void 0 ? (u.tag = 1,
            u.memoizedState = null,
            u.updateQueue = null,
            Rn(y) ? (A = !0,
            kn(u)) : A = !1,
            u.memoizedState = E.state !== null && E.state !== void 0 ? E.state : null,
            Fm(u),
            E.updater = Bf,
            u.stateNode = E,
            E._reactInternals = u,
            zm(u, y, l, p),
            u = rg(null, u, y, !0, A, p)) : (u.tag = 0,
            Yt && A && Bm(u),
            si(null, u, E, p),
            u = u.child),
            u;
        case 16:
            y = u.elementType;
            e: {
                switch (l !== null && (l.alternate = null,
                u.alternate = null,
                u.flags |= 2),
                l = u.pendingProps,
                E = y._init,
                y = E(y._payload),
                u.type = y,
                E = u.tag = Cb(y),
                l = hr(y, l),
                E) {
                case 0:
                    u = ig(null, u, y, l, p);
                    break e;
                case 1:
                    u = w1(null, u, y, l, p);
                    break e;
                case 11:
                    u = y1(null, u, y, l, p);
                    break e;
                case 14:
                    u = _1(null, u, y, hr(y.type, l), p);
                    break e
                }
                throw Error(o(306, y, ""))
            }
            return u;
        case 0:
            return y = u.type,
            E = u.pendingProps,
            E = u.elementType === y ? E : hr(y, E),
            ig(l, u, y, E, p);
        case 1:
            return y = u.type,
            E = u.pendingProps,
            E = u.elementType === y ? E : hr(y, E),
            w1(l, u, y, E, p);
        case 3:
            e: {
                if (E1(u),
                l === null)
                    throw Error(o(387));
                y = u.pendingProps,
                A = u.memoizedState,
                E = A.element,
                Ix(l, u),
                zf(u, y, null, p);
                var k = u.memoizedState;
                if (y = k.element,
                ge && A.isDehydrated)
                    if (A = {
                        element: y,
                        isDehydrated: !1,
                        cache: k.cache,
                        transitions: k.transitions
                    },
                    u.updateQueue.baseState = A,
                    u.memoizedState = A,
                    u.flags & 256) {
                        E = Error(o(423)),
                        u = T1(l, u, y, p, E);
                        break e
                    } else if (y !== E) {
                        E = Error(o(424)),
                        u = T1(l, u, y, p, E);
                        break e
                    } else
                        for (ge && (Li = Cf(u.stateNode.containerInfo),
                        Pi = u,
                        Yt = !0,
                        dr = null,
                        pu = !1),
                        p = Xx(u, null, y, p),
                        u.child = p; p; )
                            p.flags = p.flags & -3 | 4096,
                            p = p.sibling;
                else {
                    if (Ua(),
                    y === E) {
                        u = is(l, u, p);
                        break e
                    }
                    si(l, u, y, p)
                }
                u = u.child
            }
            return u;
        case 5:
            return Yx(u),
            l === null && Gm(u),
            y = u.type,
            E = u.pendingProps,
            A = l !== null ? l.memoizedProps : null,
            k = E.children,
            de(y, E) ? k = null : A !== null && de(y, A) && (u.flags |= 32),
            M1(l, u),
            si(l, u, k, p),
            u.child;
        case 6:
            return l === null && Gm(u),
            null;
        case 13:
            return A1(l, u, p);
        case 4:
            return Xm(u, u.stateNode.containerInfo),
            y = u.pendingProps,
            l === null ? u.child = Oa(u, null, y, p) : si(l, u, y, p),
            u.child;
        case 11:
            return y = u.type,
            E = u.pendingProps,
            E = u.elementType === y ? E : hr(y, E),
            y1(l, u, y, E, p);
        case 7:
            return si(l, u, u.pendingProps, p),
            u.child;
        case 8:
            return si(l, u, u.pendingProps.children, p),
            u.child;
        case 12:
            return si(l, u, u.pendingProps.children, p),
            u.child;
        case 10:
            e: {
                if (y = u.type._context,
                E = u.pendingProps,
                A = u.memoizedProps,
                k = E.value,
                Lx(u, y, k),
                A !== null)
                    if (Nr(A.value, k)) {
                        if (A.children === E.children && !rn.current) {
                            u = is(l, u, p);
                            break e
                        }
                    } else
                        for (A = u.child,
                        A !== null && (A.return = u); A !== null; ) {
                            var W = A.dependencies;
                            if (W !== null) {
                                k = A.child;
                                for (var ae = W.firstContext; ae !== null; ) {
                                    if (ae.context === y) {
                                        if (A.tag === 1) {
                                            ae = $r(-1, p & -p),
                                            ae.tag = 2;
                                            var xe = A.updateQueue;
                                            if (xe !== null) {
                                                xe = xe.shared;
                                                var Ve = xe.pending;
                                                Ve === null ? ae.next = ae : (ae.next = Ve.next,
                                                Ve.next = ae),
                                                xe.pending = ae
                                            }
                                        }
                                        A.lanes |= p,
                                        ae = A.alternate,
                                        ae !== null && (ae.lanes |= p),
                                        Om(A.return, p, u),
                                        W.lanes |= p;
                                        break
                                    }
                                    ae = ae.next
                                }
                            } else if (A.tag === 10)
                                k = A.type === u.type ? null : A.child;
                            else if (A.tag === 18) {
                                if (k = A.return,
                                k === null)
                                    throw Error(o(341));
                                k.lanes |= p,
                                W = k.alternate,
                                W !== null && (W.lanes |= p),
                                Om(k, p, u),
                                k = A.sibling
                            } else
                                k = A.child;
                            if (k !== null)
                                k.return = A;
                            else
                                for (k = A; k !== null; ) {
                                    if (k === u) {
                                        k = null;
                                        break
                                    }
                                    if (A = k.sibling,
                                    A !== null) {
                                        A.return = k.return,
                                        k = A;
                                        break
                                    }
                                    k = k.return
                                }
                            A = k
                        }
                si(l, u, E.children, p),
                u = u.child
            }
            return u;
        case 9:
            return E = u.type,
            y = u.pendingProps.children,
            Ia(u, p),
            E = qi(E),
            y = y(E),
            u.flags |= 1,
            si(l, u, y, p),
            u.child;
        case 14:
            return y = u.type,
            E = hr(y, u.pendingProps),
            E = hr(y.type, E),
            _1(l, u, y, E, p);
        case 15:
            return x1(l, u, u.type, u.pendingProps, p);
        case 17:
            return y = u.type,
            E = u.pendingProps,
            E = u.elementType === y ? E : hr(y, E),
            l !== null && (l.alternate = null,
            u.alternate = null,
            u.flags |= 2),
            u.tag = 1,
            Rn(y) ? (l = !0,
            kn(u)) : l = !1,
            Ia(u, p),
            Fx(u, y, E),
            zm(u, y, E, p),
            rg(null, u, y, !0, l, p);
        case 19:
            return P1(l, u, p);
        case 22:
            return S1(l, u, p)
        }
        throw Error(o(156, u.tag))
    }
    ;
    function eS(l, u) {
        return bm(l, u)
    }
    function Ab(l, u, p, y) {
        this.tag = l,
        this.key = p,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.ref = null,
        this.pendingProps = u,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = y,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function er(l, u, p, y) {
        return new Ab(l,u,p,y)
    }
    function Ag(l) {
        return l = l.prototype,
        !(!l || !l.isReactComponent)
    }
    function Cb(l) {
        if (typeof l == "function")
            return Ag(l) ? 1 : 0;
        if (l != null) {
            if (l = l.$$typeof,
            l === w)
                return 11;
            if (l === S)
                return 14
        }
        return 2
    }
    function Os(l, u) {
        var p = l.alternate;
        return p === null ? (p = er(l.tag, u, l.key, l.mode),
        p.elementType = l.elementType,
        p.type = l.type,
        p.stateNode = l.stateNode,
        p.alternate = l,
        l.alternate = p) : (p.pendingProps = u,
        p.type = l.type,
        p.flags = 0,
        p.subtreeFlags = 0,
        p.deletions = null),
        p.flags = l.flags & 14680064,
        p.childLanes = l.childLanes,
        p.lanes = l.lanes,
        p.child = l.child,
        p.memoizedProps = l.memoizedProps,
        p.memoizedState = l.memoizedState,
        p.updateQueue = l.updateQueue,
        u = l.dependencies,
        p.dependencies = u === null ? null : {
            lanes: u.lanes,
            firstContext: u.firstContext
        },
        p.sibling = l.sibling,
        p.index = l.index,
        p.ref = l.ref,
        p
    }
    function xh(l, u, p, y, E, A) {
        var k = 2;
        if (y = l,
        typeof l == "function")
            Ag(l) && (k = 1);
        else if (typeof l == "string")
            k = 5;
        else
            e: switch (l) {
            case h:
                return Io(p.children, E, A, u);
            case d:
                k = 8,
                E |= 8;
                break;
            case m:
                return l = er(12, p, u, E | 2),
                l.elementType = m,
                l.lanes = A,
                l;
            case x:
                return l = er(13, p, u, E),
                l.elementType = x,
                l.lanes = A,
                l;
            case g:
                return l = er(19, p, u, E),
                l.elementType = g,
                l.lanes = A,
                l;
            case T:
                return Sh(p, E, A, u);
            default:
                if (typeof l == "object" && l !== null)
                    switch (l.$$typeof) {
                    case v:
                        k = 10;
                        break e;
                    case _:
                        k = 9;
                        break e;
                    case w:
                        k = 11;
                        break e;
                    case S:
                        k = 14;
                        break e;
                    case M:
                        k = 16,
                        y = null;
                        break e
                    }
                throw Error(o(130, l == null ? l : typeof l, ""))
            }
        return u = er(k, p, u, E),
        u.elementType = l,
        u.type = y,
        u.lanes = A,
        u
    }
    function Io(l, u, p, y) {
        return l = er(7, l, y, u),
        l.lanes = p,
        l
    }
    function Sh(l, u, p, y) {
        return l = er(22, l, y, u),
        l.elementType = T,
        l.lanes = p,
        l.stateNode = {},
        l
    }
    function Cg(l, u, p) {
        return l = er(6, l, null, u),
        l.lanes = p,
        l
    }
    function Rg(l, u, p) {
        return u = er(4, l.children !== null ? l.children : [], l.key, u),
        u.lanes = p,
        u.stateNode = {
            containerInfo: l.containerInfo,
            pendingChildren: null,
            implementation: l.implementation
        },
        u
    }
    function Rb(l, u, p, y, E) {
        this.tag = u,
        this.containerInfo = l,
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = ze,
        this.callbackNode = this.pendingContext = this.context = null,
        this.callbackPriority = 0,
        this.eventTimes = Cm(0),
        this.expirationTimes = Cm(-1),
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = Cm(0),
        this.identifierPrefix = y,
        this.onRecoverableError = E,
        ge && (this.mutableSourceEagerHydrationData = null)
    }
    function tS(l, u, p, y, E, A, k, W, ae) {
        return l = new Rb(l,u,p,W,ae),
        u === 1 ? (u = 1,
        A === !0 && (u |= 8)) : u = 0,
        A = er(3, null, null, u),
        l.current = A,
        A.stateNode = l,
        A.memoizedState = {
            element: y,
            isDehydrated: p,
            cache: null,
            transitions: null
        },
        Fm(A),
        l
    }
    function nS(l) {
        if (!l)
            return Yi;
        l = l._reactInternals;
        e: {
            if (G(l) !== l || l.tag !== 1)
                throw Error(o(170));
            var u = l;
            do {
                switch (u.tag) {
                case 3:
                    u = u.stateNode.context;
                    break e;
                case 1:
                    if (Rn(u.type)) {
                        u = u.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
                }
                u = u.return
            } while (u !== null);
            throw Error(o(171))
        }
        if (l.tag === 1) {
            var p = l.type;
            if (Rn(p))
                return ba(l, p, u)
        }
        return u
    }
    function iS(l) {
        var u = l._reactInternals;
        if (u === void 0)
            throw typeof l.render == "function" ? Error(o(188)) : (l = Object.keys(l).join(","),
            Error(o(268, l)));
        return l = K(u),
        l === null ? null : l.stateNode
    }
    function rS(l, u) {
        if (l = l.memoizedState,
        l !== null && l.dehydrated !== null) {
            var p = l.retryLane;
            l.retryLane = p !== 0 && p < u ? p : u
        }
    }
    function bg(l, u) {
        rS(l, u),
        (l = l.alternate) && rS(l, u)
    }
    function bb(l) {
        return l = K(l),
        l === null ? null : l.stateNode
    }
    function Pb() {
        return null
    }
    return t.attemptContinuousHydration = function(l) {
        if (l.tag === 13) {
            var u = oi();
            $i(l, 134217728, u),
            bg(l, 134217728)
        }
    }
    ,
    t.attemptHydrationAtCurrentPriority = function(l) {
        if (l.tag === 13) {
            var u = oi()
              , p = Ds(l);
            $i(l, p, u),
            bg(l, p)
        }
    }
    ,
    t.attemptSynchronousHydration = function(l) {
        switch (l.tag) {
        case 3:
            var u = l.stateNode;
            if (u.current.memoizedState.isDehydrated) {
                var p = hu(u.pendingLanes);
                p !== 0 && (Rm(u, p | 1),
                _i(u, bn()),
                !(Mt & 6) && (Va(),
                Dr()))
            }
            break;
        case 13:
            var y = oi();
            Y1(function() {
                return $i(l, 1, y)
            }),
            bg(l, 1)
        }
    }
    ,
    t.batchedUpdates = function(l, u) {
        var p = Mt;
        Mt |= 1;
        try {
            return l(u)
        } finally {
            Mt = p,
            Mt === 0 && (Va(),
            Df && Dr())
        }
    }
    ,
    t.createComponentSelector = function(l) {
        return {
            $$typeof: oh,
            value: l
        }
    }
    ,
    t.createContainer = function(l, u, p, y, E, A, k) {
        return tS(l, u, !1, null, p, y, E, A, k)
    }
    ,
    t.createHasPseudoClassSelector = function(l) {
        return {
            $$typeof: ah,
            value: l
        }
    }
    ,
    t.createHydrationContainer = function(l, u, p, y, E, A, k, W, ae) {
        return l = tS(p, y, !0, l, E, A, k, W, ae),
        l.context = nS(null),
        p = l.current,
        y = oi(),
        E = Ds(p),
        A = $r(y, E),
        A.callback = u ?? null,
        Ls(p, A),
        l.current.lanes = E,
        du(l, E, y),
        _i(l, y),
        l
    }
    ,
    t.createPortal = function(l, u, p) {
        var y = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: f,
            key: y == null ? null : "" + y,
            children: l,
            containerInfo: u,
            implementation: p
        }
    }
    ,
    t.createRoleSelector = function(l) {
        return {
            $$typeof: lh,
            value: l
        }
    }
    ,
    t.createTestNameSelector = function(l) {
        return {
            $$typeof: uh,
            value: l
        }
    }
    ,
    t.createTextSelector = function(l) {
        return {
            $$typeof: ch,
            value: l
        }
    }
    ,
    t.deferredUpdates = function(l) {
        var u = Pt
          , p = cn.transition;
        try {
            return cn.transition = null,
            Pt = 16,
            l()
        } finally {
            Pt = u,
            cn.transition = p
        }
    }
    ,
    t.discreteUpdates = function(l, u, p, y, E) {
        var A = Pt
          , k = cn.transition;
        try {
            return cn.transition = null,
            Pt = 1,
            l(u, p, y, E)
        } finally {
            Pt = A,
            cn.transition = k,
            Mt === 0 && Va()
        }
    }
    ,
    t.findAllNodes = mg,
    t.findBoundingRects = function(l, u) {
        if (!ft)
            throw Error(o(363));
        u = mg(l, u),
        l = [];
        for (var p = 0; p < u.length; p++)
            l.push(L(u[p]));
        for (u = l.length - 1; 0 < u; u--) {
            p = l[u];
            for (var y = p.x, E = y + p.width, A = p.y, k = A + p.height, W = u - 1; 0 <= W; W--)
                if (u !== W) {
                    var ae = l[W]
                      , xe = ae.x
                      , Ve = xe + ae.width
                      , dt = ae.y
                      , Qe = dt + ae.height;
                    if (y >= xe && A >= dt && E <= Ve && k <= Qe) {
                        l.splice(u, 1);
                        break
                    } else if (y !== xe || p.width !== ae.width || Qe < A || dt > k) {
                        if (!(A !== dt || p.height !== ae.height || Ve < y || xe > E)) {
                            xe > y && (ae.width += xe - y,
                            ae.x = y),
                            Ve < E && (ae.width = E - xe),
                            l.splice(u, 1);
                            break
                        }
                    } else {
                        dt > A && (ae.height += dt - A,
                        ae.y = A),
                        Qe < k && (ae.height = k - dt),
                        l.splice(u, 1);
                        break
                    }
                }
        }
        return l
    }
    ,
    t.findHostInstance = iS,
    t.findHostInstanceWithNoPortals = function(l) {
        return l = I(l),
        l = l !== null ? B(l) : null,
        l === null ? null : l.stateNode
    }
    ,
    t.findHostInstanceWithWarning = function(l) {
        return iS(l)
    }
    ,
    t.flushControlled = function(l) {
        var u = Mt;
        Mt |= 1;
        var p = cn.transition
          , y = Pt;
        try {
            cn.transition = null,
            Pt = 1,
            l()
        } finally {
            Pt = y,
            cn.transition = p,
            Mt = u,
            Mt === 0 && (Va(),
            Dr())
        }
    }
    ,
    t.flushPassiveEffects = Lo,
    t.flushSync = Y1,
    t.focusWithin = function(l, u) {
        if (!ft)
            throw Error(o(363));
        for (l = hg(l),
        u = G1(l, u),
        u = Array.from(u),
        l = 0; l < u.length; ) {
            var p = u[l++];
            if (!le(p)) {
                if (p.tag === 5 && me(p.stateNode))
                    return !0;
                for (p = p.child; p !== null; )
                    u.push(p),
                    p = p.sibling
            }
        }
        return !1
    }
    ,
    t.getCurrentUpdatePriority = function() {
        return Pt
    }
    ,
    t.getFindAllNodesFailureDescription = function(l, u) {
        if (!ft)
            throw Error(o(363));
        var p = 0
          , y = [];
        l = [hg(l), 0];
        for (var E = 0; E < l.length; ) {
            var A = l[E++]
              , k = l[E++]
              , W = u[k];
            if ((A.tag !== 5 || !le(A)) && (dg(A, W) && (y.push(pg(W)),
            k++,
            k > p && (p = k)),
            k < u.length))
                for (A = A.child; A !== null; )
                    l.push(A, k),
                    A = A.sibling
        }
        if (p < u.length) {
            for (l = []; p < u.length; p++)
                l.push(pg(u[p]));
            return `findAllNodes was able to match part of the selector:
  ` + (y.join(" > ") + `

No matching component was found for:
  `) + l.join(" > ")
        }
        return null
    }
    ,
    t.getPublicRootInstance = function(l) {
        if (l = l.current,
        !l.child)
            return null;
        switch (l.child.tag) {
        case 5:
            return J(l.child.stateNode);
        default:
            return l.child.stateNode
        }
    }
    ,
    t.injectIntoDevTools = function(l) {
        if (l = {
            bundleType: l.bundleType,
            version: l.version,
            rendererPackageName: l.rendererPackageName,
            rendererConfig: l.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: a.ReactCurrentDispatcher,
            findHostInstanceByFiber: bb,
            findFiberByHostInstance: l.findFiberByHostInstance || Pb,
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: "18.0.0-fc46dba67-20220329"
        },
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
            l = !1;
        else {
            var u = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (u.isDisabled || !u.supportsFiber)
                l = !0;
            else {
                try {
                    Nf = u.inject(l),
                    Ir = u
                } catch {}
                l = !!u.checkDCE
            }
        }
        return l
    }
    ,
    t.isAlreadyRendering = function() {
        return !1
    }
    ,
    t.observeVisibleRects = function(l, u, p, y) {
        if (!ft)
            throw Error(o(363));
        l = mg(l, u);
        var E = st(l, p, y).disconnect;
        return {
            disconnect: function() {
                E()
            }
        }
    }
    ,
    t.registerMutableSourceForHydration = function(l, u) {
        var p = u._getVersion;
        p = p(u._source),
        l.mutableSourceEagerHydrationData == null ? l.mutableSourceEagerHydrationData = [u, p] : l.mutableSourceEagerHydrationData.push(u, p)
    }
    ,
    t.runWithPriority = function(l, u) {
        var p = Pt;
        try {
            return Pt = l,
            u()
        } finally {
            Pt = p
        }
    }
    ,
    t.shouldError = function() {
        return null
    }
    ,
    t.shouldSuspend = function() {
        return !1
    }
    ,
    t.updateContainer = function(l, u, p, y) {
        var E = u.current
          , A = oi()
          , k = Ds(E);
        return p = nS(p),
        u.context === null ? u.context = p : u.pendingContext = p,
        u = $r(A, k),
        u.payload = {
            element: l
        },
        y = y === void 0 ? null : y,
        y !== null && (u.callback = y),
        Ls(E, u),
        l = $i(E, k, A),
        l !== null && kf(l, E, k),
        k
    }
    ,
    t
};
yR.exports = az;
var lz = yR.exports;
const uz = zy(lz)
  , cz = n=>typeof n == "object" && typeof n.then == "function"
  , sa = [];
function SR(n, e, t=(i,r)=>i === r) {
    if (n === e)
        return !0;
    if (!n || !e)
        return !1;
    const i = n.length;
    if (e.length !== i)
        return !1;
    for (let r = 0; r < i; r++)
        if (!t(n[r], e[r]))
            return !1;
    return !0
}
function MR(n, e=null, t=!1, i={}) {
    e === null && (e = [n]);
    for (const s of sa)
        if (SR(e, s.keys, s.equal)) {
            if (t)
                return;
            if (Object.prototype.hasOwnProperty.call(s, "error"))
                throw s.error;
            if (Object.prototype.hasOwnProperty.call(s, "response"))
                return i.lifespan && i.lifespan > 0 && (s.timeout && clearTimeout(s.timeout),
                s.timeout = setTimeout(s.remove, i.lifespan)),
                s.response;
            if (!t)
                throw s.promise
        }
    const r = {
        keys: e,
        equal: i.equal,
        remove: ()=>{
            const s = sa.indexOf(r);
            s !== -1 && sa.splice(s, 1)
        }
        ,
        promise: (cz(n) ? n : n(...e)).then(s=>{
            r.response = s,
            i.lifespan && i.lifespan > 0 && (r.timeout = setTimeout(r.remove, i.lifespan))
        }
        ).catch(s=>r.error = s)
    };
    if (sa.push(r),
    !t)
        throw r.promise
}
const fz = (n,e,t)=>MR(n, e, !1, t)
  , hz = (n,e,t)=>void MR(n, e, !0, t)
  , dz = n=>{
    if (n === void 0 || n.length === 0)
        sa.splice(0, sa.length);
    else {
        const e = sa.find(t=>SR(n, t.keys, t.equal));
        e && e.remove()
    }
}
  , Sx = {}
  , Mx = n=>void Object.assign(Sx, n);
function pz(n, e) {
    function t(h, {args: d=[], attach: m, ...v}, _) {
        let w = `${h[0].toUpperCase()}${h.slice(1)}`, x;
        if (h === "primitive") {
            if (v.object === void 0)
                throw new Error("R3F: Primitives without 'object' are invalid!");
            const g = v.object;
            x = ml(g, {
                type: h,
                root: _,
                attach: m,
                primitive: !0
            })
        } else {
            const g = Sx[w];
            if (!g)
                throw new Error(`R3F: ${w} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
            if (!Array.isArray(d))
                throw new Error("R3F: The args prop must be an array!");
            x = ml(new g(...d), {
                type: h,
                root: _,
                attach: m,
                memoizedProps: {
                    args: d
                }
            })
        }
        return x.__r3f.attach === void 0 && (x instanceof _t ? x.__r3f.attach = "geometry" : x instanceof Gn && (x.__r3f.attach = "material")),
        w !== "inject" && G0(x, v),
        x
    }
    function i(h, d) {
        let m = !1;
        if (d) {
            var v, _;
            (v = d.__r3f) != null && v.attach ? V0(h, d, d.__r3f.attach) : d.isObject3D && h.isObject3D && (h.add(d),
            m = !0),
            m || (_ = h.__r3f) == null || _.objects.push(d),
            d.__r3f || ml(d, {}),
            d.__r3f.parent = h,
            Uy(d),
            gl(d)
        }
    }
    function r(h, d, m) {
        let v = !1;
        if (d) {
            var _, w;
            if ((_ = d.__r3f) != null && _.attach)
                V0(h, d, d.__r3f.attach);
            else if (d.isObject3D && h.isObject3D) {
                d.parent = h,
                d.dispatchEvent({
                    type: "added"
                }),
                h.dispatchEvent({
                    type: "childadded",
                    child: d
                });
                const x = h.children.filter(S=>S !== d)
                  , g = x.indexOf(m);
                h.children = [...x.slice(0, g), d, ...x.slice(g)],
                v = !0
            }
            v || (w = h.__r3f) == null || w.objects.push(d),
            d.__r3f || ml(d, {}),
            d.__r3f.parent = h,
            Uy(d),
            gl(d)
        }
    }
    function s(h, d, m=!1) {
        h && [...h].forEach(v=>o(d, v, m))
    }
    function o(h, d, m) {
        if (d) {
            var v, _, w;
            if (d.__r3f && (d.__r3f.parent = null),
            (v = h.__r3f) != null && v.objects && (h.__r3f.objects = h.__r3f.objects.filter(T=>T !== d)),
            (_ = d.__r3f) != null && _.attach)
                Kw(h, d, d.__r3f.attach);
            else if (d.isObject3D && h.isObject3D) {
                var x;
                h.remove(d),
                (x = d.__r3f) != null && x.root && Mz(Qd(d), d)
            }
            const S = (w = d.__r3f) == null ? void 0 : w.primitive
              , M = !S && (m === void 0 ? d.dispose !== null : m);
            if (!S) {
                var g;
                s((g = d.__r3f) == null ? void 0 : g.objects, d, M),
                s(d.children, d, M)
            }
            if (delete d.__r3f,
            M && d.dispose && d.type !== "Scene") {
                const T = ()=>{
                    try {
                        d.dispose()
                    } catch {}
                }
                ;
                typeof IS_REACT_ACT_ENVIRONMENT > "u" ? Ny.unstable_scheduleCallback(Ny.unstable_IdlePriority, T) : T()
            }
            gl(h)
        }
    }
    function a(h, d, m, v) {
        var _;
        const w = (_ = h.__r3f) == null ? void 0 : _.parent;
        if (!w)
            return;
        const x = t(d, m, h.__r3f.root);
        if (h.children) {
            for (const g of h.children)
                g.__r3f && i(x, g);
            h.children = h.children.filter(g=>!g.__r3f)
        }
        h.__r3f.objects.forEach(g=>i(x, g)),
        h.__r3f.objects = [],
        h.__r3f.autoRemovedBeforeAppend || o(w, h),
        x.parent && (x.__r3f.autoRemovedBeforeAppend = !0),
        i(w, x),
        x.raycast && x.__r3f.eventCount && Qd(x).getState().internal.interaction.push(x),
        [v, v.alternate].forEach(g=>{
            g !== null && (g.stateNode = x,
            g.ref && (typeof g.ref == "function" ? g.ref(x) : g.ref.current = x))
        }
        )
    }
    const c = ()=>console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
    return {
        reconciler: uz({
            createInstance: t,
            removeChild: o,
            appendChild: i,
            appendInitialChild: i,
            insertBefore: r,
            supportsMutation: !0,
            isPrimaryRenderer: !1,
            supportsPersistence: !1,
            supportsHydration: !1,
            noTimeout: -1,
            appendChildToContainer: (h,d)=>{
                if (!d)
                    return;
                const m = h.getState().scene;
                m.__r3f && (m.__r3f.root = h,
                i(m, d))
            }
            ,
            removeChildFromContainer: (h,d)=>{
                d && o(h.getState().scene, d)
            }
            ,
            insertInContainerBefore: (h,d,m)=>{
                if (!d || !m)
                    return;
                const v = h.getState().scene;
                v.__r3f && r(v, d, m)
            }
            ,
            getRootHostContext: ()=>null,
            getChildHostContext: h=>h,
            finalizeInitialChildren(h) {
                var d;
                return !!((d = h == null ? void 0 : h.__r3f) != null ? d : {}).handlers
            },
            prepareUpdate(h, d, m, v) {
                var _;
                if (((_ = h == null ? void 0 : h.__r3f) != null ? _ : {}).primitive && v.object && v.object !== h)
                    return [!0];
                {
                    const {args: x=[], children: g, ...S} = v
                      , {args: M=[], children: T, ...P} = m;
                    if (!Array.isArray(x))
                        throw new Error("R3F: the args prop must be an array!");
                    if (x.some((b,N)=>b !== M[N]))
                        return [!0];
                    const R = bR(h, S, P, !0);
                    return R.changes.length ? [!1, R] : null
                }
            },
            commitUpdate(h, [d,m], v, _, w, x) {
                d ? a(h, v, w, x) : G0(h, m)
            },
            commitMount(h, d, m, v) {
                var _;
                const w = (_ = h.__r3f) != null ? _ : {};
                h.raycast && w.handlers && w.eventCount && Qd(h).getState().internal.interaction.push(h)
            },
            getPublicInstance: h=>h,
            prepareForCommit: ()=>null,
            preparePortalMount: h=>ml(h.getState().scene),
            resetAfterCommit: ()=>{}
            ,
            shouldSetTextContent: ()=>!1,
            clearContainer: ()=>!1,
            hideInstance(h) {
                var d;
                const {attach: m, parent: v} = (d = h.__r3f) != null ? d : {};
                m && v && Kw(v, h, m),
                h.isObject3D && (h.visible = !1),
                gl(h)
            },
            unhideInstance(h, d) {
                var m;
                const {attach: v, parent: _} = (m = h.__r3f) != null ? m : {};
                v && _ && V0(_, h, v),
                (h.isObject3D && d.visible == null || d.visible) && (h.visible = !0),
                gl(h)
            },
            createTextInstance: c,
            hideTextInstance: c,
            unhideTextInstance: c,
            getCurrentEventPriority: ()=>e ? e() : Dl.DefaultEventPriority,
            beforeActiveInstanceBlur: ()=>{}
            ,
            afterActiveInstanceBlur: ()=>{}
            ,
            detachDeletedInstance: ()=>{}
            ,
            now: typeof performance < "u" && jt.fun(performance.now) ? performance.now : jt.fun(Date.now) ? Date.now : ()=>0,
            scheduleTimeout: jt.fun(setTimeout) ? setTimeout : void 0,
            cancelTimeout: jt.fun(clearTimeout) ? clearTimeout : void 0
        }),
        applyProps: G0
    }
}
var jw, qw;
const H0 = n=>"colorSpace"in n || "outputColorSpace"in n
  , wR = ()=>{
    var n;
    return (n = Sx.ColorManagement) != null ? n : null
}
  , ER = n=>n && n.isOrthographicCamera
  , mz = n=>n && n.hasOwnProperty("current")
  , Af = typeof window < "u" && ((jw = window.document) != null && jw.createElement || ((qw = window.navigator) == null ? void 0 : qw.product) === "ReactNative") ? ve.useLayoutEffect : ve.useEffect;
function TR(n) {
    const e = ve.useRef(n);
    return Af(()=>void (e.current = n), [n]),
    e
}
function gz({set: n}) {
    return Af(()=>(n(new Promise(()=>null)),
    ()=>n(!1)), [n]),
    null
}
class AR extends ve.Component {
    constructor(...e) {
        super(...e),
        this.state = {
            error: !1
        }
    }
    componentDidCatch(e) {
        this.props.set(e)
    }
    render() {
        return this.state.error ? null : this.props.children
    }
}
AR.getDerivedStateFromError = ()=>({
    error: !0
});
const CR = "__default"
  , Zw = new Map
  , vz = n=>n && !!n.memoized && !!n.changes;
function RR(n) {
    var e;
    const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
    return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n
}
const Ju = n=>{
    var e;
    return (e = n.__r3f) == null ? void 0 : e.root.getState()
}
;
function Qd(n) {
    let e = n.__r3f.root;
    for (; e.getState().previousRoot; )
        e = e.getState().previousRoot;
    return e
}
const jt = {
    obj: n=>n === Object(n) && !jt.arr(n) && typeof n != "function",
    fun: n=>typeof n == "function",
    str: n=>typeof n == "string",
    num: n=>typeof n == "number",
    boo: n=>typeof n == "boolean",
    und: n=>n === void 0,
    arr: n=>Array.isArray(n),
    equ(n, e, {arrays: t="shallow", objects: i="reference", strict: r=!0}={}) {
        if (typeof n != typeof e || !!n != !!e)
            return !1;
        if (jt.str(n) || jt.num(n))
            return n === e;
        const s = jt.obj(n);
        if (s && i === "reference")
            return n === e;
        const o = jt.arr(n);
        if (o && t === "reference")
            return n === e;
        if ((o || s) && n === e)
            return !0;
        let a;
        for (a in n)
            if (!(a in e))
                return !1;
        if (s && t === "shallow" && i === "shallow") {
            for (a in r ? e : n)
                if (!jt.equ(n[a], e[a], {
                    strict: r,
                    objects: "reference"
                }))
                    return !1
        } else
            for (a in r ? e : n)
                if (n[a] !== e[a])
                    return !1;
        if (jt.und(a)) {
            if (o && n.length === 0 && e.length === 0 || s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
                return !0;
            if (n !== e)
                return !1
        }
        return !0
    }
};
function yz(n) {
    n.dispose && n.type !== "Scene" && n.dispose();
    for (const e in n)
        e.dispose == null || e.dispose(),
        delete n[e]
}
function ml(n, e) {
    const t = n;
    return t.__r3f = {
        type: "",
        root: null,
        previousAttach: null,
        memoizedProps: {},
        eventCount: 0,
        handlers: {},
        objects: [],
        parent: null,
        ...e
    },
    n
}
function Dy(n, e) {
    let t = n;
    if (e.includes("-")) {
        const i = e.split("-")
          , r = i.pop();
        return t = i.reduce((s,o)=>s[o], n),
        {
            target: t,
            key: r
        }
    } else
        return {
            target: t,
            key: e
        }
}
const Jw = /-\d+$/;
function V0(n, e, t) {
    if (jt.str(t)) {
        if (Jw.test(t)) {
            const s = t.replace(Jw, "")
              , {target: o, key: a} = Dy(n, s);
            Array.isArray(o[a]) || (o[a] = [])
        }
        const {target: i, key: r} = Dy(n, t);
        e.__r3f.previousAttach = i[r],
        i[r] = e
    } else
        e.__r3f.previousAttach = t(n, e)
}
function Kw(n, e, t) {
    var i, r;
    if (jt.str(t)) {
        const {target: s, key: o} = Dy(n, t)
          , a = e.__r3f.previousAttach;
        a === void 0 ? delete s[o] : s[o] = a
    } else
        (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e);
    (r = e.__r3f) == null || delete r.previousAttach
}
function bR(n, {children: e, key: t, ref: i, ...r}, {children: s, key: o, ref: a, ...c}={}, f=!1) {
    var h;
    const d = (h = n == null ? void 0 : n.__r3f) != null ? h : {}
      , m = Object.entries(r)
      , v = [];
    if (f) {
        const w = Object.keys(c);
        for (let x = 0; x < w.length; x++)
            r.hasOwnProperty(w[x]) || m.unshift([w[x], CR + "remove"])
    }
    m.forEach(([w,x])=>{
        var g;
        if ((g = n.__r3f) != null && g.primitive && w === "object" || jt.equ(x, c[w]))
            return;
        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(w))
            return v.push([w, x, !0, []]);
        let S = [];
        w.includes("-") && (S = w.split("-")),
        v.push([w, x, !1, S]);
        for (const M in r) {
            const T = r[M];
            M.startsWith(`${w}-`) && v.push([M, T, !1, M.split("-")])
        }
    }
    );
    const _ = {
        ...r
    };
    return d.memoizedProps && d.memoizedProps.args && (_.args = d.memoizedProps.args),
    d.memoizedProps && d.memoizedProps.attach && (_.attach = d.memoizedProps.attach),
    {
        memoized: _,
        changes: v
    }
}
const _z = typeof process < "u" && !1;
function G0(n, e) {
    var t, i, r;
    const s = (t = n.__r3f) != null ? t : {}
      , o = s.root
      , a = (i = o == null || o.getState == null ? void 0 : o.getState()) != null ? i : {}
      , {memoized: c, changes: f} = vz(e) ? e : bR(n, e)
      , h = s.eventCount;
    n.__r3f && (n.__r3f.memoizedProps = c);
    for (let m = 0; m < f.length; m++) {
        let[v,_,w,x] = f[m];
        if (H0(n)) {
            const T = "srgb"
              , P = "srgb-linear";
            v === "encoding" ? (v = "colorSpace",
            _ = _ === 3001 ? T : P) : v === "outputEncoding" && (v = "outputColorSpace",
            _ = _ === 3001 ? T : P)
        }
        let g = n
          , S = g[v];
        if (x.length && (S = x.reduce((M,T)=>M[T], n),
        !(S && S.set))) {
            const [M,...T] = x.reverse();
            g = T.reverse().reduce((P,R)=>P[R], n),
            v = M
        }
        if (_ === CR + "remove")
            if (g.constructor) {
                let M = Zw.get(g.constructor);
                M || (M = new g.constructor,
                Zw.set(g.constructor, M)),
                _ = M[v]
            } else
                _ = 0;
        if (w)
            _ ? s.handlers[v] = _ : delete s.handlers[v],
            s.eventCount = Object.keys(s.handlers).length;
        else if (S && S.set && (S.copy || S instanceof ca)) {
            if (Array.isArray(_))
                S.fromArray ? S.fromArray(_) : S.set(..._);
            else if (S.copy && _ && _.constructor && (_z ? S.constructor.name === _.constructor.name : S.constructor === _.constructor))
                S.copy(_);
            else if (_ !== void 0) {
                const M = S instanceof Ne;
                !M && S.setScalar ? S.setScalar(_) : S instanceof ca && _ instanceof ca ? S.mask = _.mask : S.set(_),
                !wR() && !a.linear && M && S.convertSRGBToLinear()
            }
        } else if (g[v] = _,
        g[v]instanceof en && g[v].format === ci && g[v].type === jr) {
            const M = g[v];
            H0(M) && H0(a.gl) ? M.colorSpace = a.gl.outputColorSpace : M.encoding = a.gl.outputEncoding
        }
        gl(n)
    }
    if (s.parent && n.raycast && h !== s.eventCount) {
        const m = Qd(n).getState().internal
          , v = m.interaction.indexOf(n);
        v > -1 && m.interaction.splice(v, 1),
        s.eventCount && m.interaction.push(n)
    }
    return !(f.length === 1 && f[0][0] === "onUpdate") && f.length && (r = n.__r3f) != null && r.parent && Uy(n),
    n
}
function gl(n) {
    var e, t;
    const i = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
    i && i.internal.frames === 0 && i.invalidate()
}
function Uy(n) {
    n.onUpdate == null || n.onUpdate(n)
}
function xz(n, e) {
    n.manual || (ER(n) ? (n.left = e.width / -2,
    n.right = e.width / 2,
    n.top = e.height / 2,
    n.bottom = e.height / -2) : n.aspect = e.width / e.height,
    n.updateProjectionMatrix(),
    n.updateMatrixWorld())
}
function Pd(n) {
    return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId
}
function Sz() {
    var n;
    const e = typeof self < "u" && self || typeof window < "u" && window;
    if (!e)
        return Dl.DefaultEventPriority;
    switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
        return Dl.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
        return Dl.ContinuousEventPriority;
    default:
        return Dl.DefaultEventPriority
    }
}
function PR(n, e, t, i) {
    const r = t.get(e);
    r && (t.delete(e),
    t.size === 0 && (n.delete(i),
    r.target.releasePointerCapture(i)))
}
function Mz(n, e) {
    const {internal: t} = n.getState();
    t.interaction = t.interaction.filter(i=>i !== e),
    t.initialHits = t.initialHits.filter(i=>i !== e),
    t.hovered.forEach((i,r)=>{
        (i.eventObject === e || i.object === e) && t.hovered.delete(r)
    }
    ),
    t.capturedMap.forEach((i,r)=>{
        PR(t.capturedMap, e, i, r)
    }
    )
}
function wz(n) {
    function e(c) {
        const {internal: f} = n.getState()
          , h = c.offsetX - f.initialClick[0]
          , d = c.offsetY - f.initialClick[1];
        return Math.round(Math.sqrt(h * h + d * d))
    }
    function t(c) {
        return c.filter(f=>["Move", "Over", "Enter", "Out", "Leave"].some(h=>{
            var d;
            return (d = f.__r3f) == null ? void 0 : d.handlers["onPointer" + h]
        }
        ))
    }
    function i(c, f) {
        const h = n.getState()
          , d = new Set
          , m = []
          , v = f ? f(h.internal.interaction) : h.internal.interaction;
        for (let g = 0; g < v.length; g++) {
            const S = Ju(v[g]);
            S && (S.raycaster.camera = void 0)
        }
        h.previousRoot || h.events.compute == null || h.events.compute(c, h);
        function _(g) {
            const S = Ju(g);
            if (!S || !S.events.enabled || S.raycaster.camera === null)
                return [];
            if (S.raycaster.camera === void 0) {
                var M;
                S.events.compute == null || S.events.compute(c, S, (M = S.previousRoot) == null ? void 0 : M.getState()),
                S.raycaster.camera === void 0 && (S.raycaster.camera = null)
            }
            return S.raycaster.camera ? S.raycaster.intersectObject(g, !0) : []
        }
        let w = v.flatMap(_).sort((g,S)=>{
            const M = Ju(g.object)
              , T = Ju(S.object);
            return !M || !T ? g.distance - S.distance : T.events.priority - M.events.priority || g.distance - S.distance
        }
        ).filter(g=>{
            const S = Pd(g);
            return d.has(S) ? !1 : (d.add(S),
            !0)
        }
        );
        h.events.filter && (w = h.events.filter(w, h));
        for (const g of w) {
            let S = g.object;
            for (; S; ) {
                var x;
                (x = S.__r3f) != null && x.eventCount && m.push({
                    ...g,
                    eventObject: S
                }),
                S = S.parent
            }
        }
        if ("pointerId"in c && h.internal.capturedMap.has(c.pointerId))
            for (let g of h.internal.capturedMap.get(c.pointerId).values())
                d.has(Pd(g.intersection)) || m.push(g.intersection);
        return m
    }
    function r(c, f, h, d) {
        const m = n.getState();
        if (c.length) {
            const v = {
                stopped: !1
            };
            for (const _ of c) {
                const w = Ju(_.object) || m
                  , {raycaster: x, pointer: g, camera: S, internal: M} = w
                  , T = new U(g.x,g.y,0).unproject(S)
                  , P = C=>{
                    var I, K;
                    return (I = (K = M.capturedMap.get(C)) == null ? void 0 : K.has(_.eventObject)) != null ? I : !1
                }
                  , R = C=>{
                    const I = {
                        intersection: _,
                        target: f.target
                    };
                    M.capturedMap.has(C) ? M.capturedMap.get(C).set(_.eventObject, I) : M.capturedMap.set(C, new Map([[_.eventObject, I]])),
                    f.target.setPointerCapture(C)
                }
                  , b = C=>{
                    const I = M.capturedMap.get(C);
                    I && PR(M.capturedMap, _.eventObject, I, C)
                }
                ;
                let N = {};
                for (let C in f) {
                    let I = f[C];
                    typeof I != "function" && (N[C] = I)
                }
                let G = {
                    ..._,
                    ...N,
                    pointer: g,
                    intersections: c,
                    stopped: v.stopped,
                    delta: h,
                    unprojectedPoint: T,
                    ray: x.ray,
                    camera: S,
                    stopPropagation() {
                        const C = "pointerId"in f && M.capturedMap.get(f.pointerId);
                        if ((!C || C.has(_.eventObject)) && (G.stopped = v.stopped = !0,
                        M.hovered.size && Array.from(M.hovered.values()).find(I=>I.eventObject === _.eventObject))) {
                            const I = c.slice(0, c.indexOf(_));
                            s([...I, _])
                        }
                    },
                    target: {
                        hasPointerCapture: P,
                        setPointerCapture: R,
                        releasePointerCapture: b
                    },
                    currentTarget: {
                        hasPointerCapture: P,
                        setPointerCapture: R,
                        releasePointerCapture: b
                    },
                    nativeEvent: f
                };
                if (d(G),
                v.stopped === !0)
                    break
            }
        }
        return c
    }
    function s(c) {
        const {internal: f} = n.getState();
        for (const h of f.hovered.values())
            if (!c.length || !c.find(d=>d.object === h.object && d.index === h.index && d.instanceId === h.instanceId)) {
                const m = h.eventObject.__r3f
                  , v = m == null ? void 0 : m.handlers;
                if (f.hovered.delete(Pd(h)),
                m != null && m.eventCount) {
                    const _ = {
                        ...h,
                        intersections: c
                    };
                    v.onPointerOut == null || v.onPointerOut(_),
                    v.onPointerLeave == null || v.onPointerLeave(_)
                }
            }
    }
    function o(c, f) {
        for (let h = 0; h < f.length; h++) {
            const d = f[h].__r3f;
            d == null || d.handlers.onPointerMissed == null || d.handlers.onPointerMissed(c)
        }
    }
    function a(c) {
        switch (c) {
        case "onPointerLeave":
        case "onPointerCancel":
            return ()=>s([]);
        case "onLostPointerCapture":
            return f=>{
                const {internal: h} = n.getState();
                "pointerId"in f && h.capturedMap.has(f.pointerId) && requestAnimationFrame(()=>{
                    h.capturedMap.has(f.pointerId) && (h.capturedMap.delete(f.pointerId),
                    s([]))
                }
                )
            }
        }
        return function(h) {
            const {onPointerMissed: d, internal: m} = n.getState();
            m.lastEvent.current = h;
            const v = c === "onPointerMove"
              , _ = c === "onClick" || c === "onContextMenu" || c === "onDoubleClick"
              , x = i(h, v ? t : void 0)
              , g = _ ? e(h) : 0;
            c === "onPointerDown" && (m.initialClick = [h.offsetX, h.offsetY],
            m.initialHits = x.map(M=>M.eventObject)),
            _ && !x.length && g <= 2 && (o(h, m.interaction),
            d && d(h)),
            v && s(x);
            function S(M) {
                const T = M.eventObject
                  , P = T.__r3f
                  , R = P == null ? void 0 : P.handlers;
                if (P != null && P.eventCount)
                    if (v) {
                        if (R.onPointerOver || R.onPointerEnter || R.onPointerOut || R.onPointerLeave) {
                            const b = Pd(M)
                              , N = m.hovered.get(b);
                            N ? N.stopped && M.stopPropagation() : (m.hovered.set(b, M),
                            R.onPointerOver == null || R.onPointerOver(M),
                            R.onPointerEnter == null || R.onPointerEnter(M))
                        }
                        R.onPointerMove == null || R.onPointerMove(M)
                    } else {
                        const b = R[c];
                        b ? (!_ || m.initialHits.includes(T)) && (o(h, m.interaction.filter(N=>!m.initialHits.includes(N))),
                        b(M)) : _ && m.initialHits.includes(T) && o(h, m.interaction.filter(N=>!m.initialHits.includes(N)))
                    }
            }
            r(x, h, g, S)
        }
    }
    return {
        handlePointer: a
    }
}
const LR = n=>!!(n != null && n.render)
  , IR = ve.createContext(null)
  , Ez = (n,e)=>{
    const t = oz((a,c)=>{
        const f = new U
          , h = new U
          , d = new U;
        function m(g=c().camera, S=h, M=c().size) {
            const {width: T, height: P, top: R, left: b} = M
              , N = T / P;
            S instanceof U ? d.copy(S) : d.set(...S);
            const G = g.getWorldPosition(f).distanceTo(d);
            if (ER(g))
                return {
                    width: T / g.zoom,
                    height: P / g.zoom,
                    top: R,
                    left: b,
                    factor: 1,
                    distance: G,
                    aspect: N
                };
            {
                const C = g.fov * Math.PI / 180
                  , I = 2 * Math.tan(C / 2) * G
                  , K = I * (T / P);
                return {
                    width: K,
                    height: I,
                    top: R,
                    left: b,
                    factor: T / K,
                    distance: G,
                    aspect: N
                }
            }
        }
        let v;
        const _ = g=>a(S=>({
            performance: {
                ...S.performance,
                current: g
            }
        }))
          , w = new he;
        return {
            set: a,
            get: c,
            gl: null,
            camera: null,
            raycaster: null,
            events: {
                priority: 1,
                enabled: !0,
                connected: !1
            },
            xr: null,
            scene: null,
            invalidate: (g=1)=>n(c(), g),
            advance: (g,S)=>e(g, S, c()),
            legacy: !1,
            linear: !1,
            flat: !1,
            controls: null,
            clock: new vx,
            pointer: w,
            mouse: w,
            frameloop: "always",
            onPointerMissed: void 0,
            performance: {
                current: 1,
                min: .5,
                max: 1,
                debounce: 200,
                regress: ()=>{
                    const g = c();
                    v && clearTimeout(v),
                    g.performance.current !== g.performance.min && _(g.performance.min),
                    v = setTimeout(()=>_(c().performance.max), g.performance.debounce)
                }
            },
            size: {
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                updateStyle: !1
            },
            viewport: {
                initialDpr: 0,
                dpr: 0,
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                aspect: 0,
                distance: 0,
                factor: 0,
                getCurrentViewport: m
            },
            setEvents: g=>a(S=>({
                ...S,
                events: {
                    ...S.events,
                    ...g
                }
            })),
            setSize: (g,S,M,T,P)=>{
                const R = c().camera
                  , b = {
                    width: g,
                    height: S,
                    top: T || 0,
                    left: P || 0,
                    updateStyle: M
                };
                a(N=>({
                    size: b,
                    viewport: {
                        ...N.viewport,
                        ...m(R, h, b)
                    }
                }))
            }
            ,
            setDpr: g=>a(S=>{
                const M = RR(g);
                return {
                    viewport: {
                        ...S.viewport,
                        dpr: M,
                        initialDpr: S.viewport.initialDpr || M
                    }
                }
            }
            ),
            setFrameloop: (g="always")=>{
                const S = c().clock;
                S.stop(),
                S.elapsedTime = 0,
                g !== "never" && (S.start(),
                S.elapsedTime = 0),
                a(()=>({
                    frameloop: g
                }))
            }
            ,
            previousRoot: void 0,
            internal: {
                active: !1,
                priority: 0,
                frames: 0,
                lastEvent: ve.createRef(),
                interaction: [],
                hovered: new Map,
                subscribers: [],
                initialClick: [0, 0],
                initialHits: [],
                capturedMap: new Map,
                subscribe: (g,S,M)=>{
                    const T = c().internal;
                    return T.priority = T.priority + (S > 0 ? 1 : 0),
                    T.subscribers.push({
                        ref: g,
                        priority: S,
                        store: M
                    }),
                    T.subscribers = T.subscribers.sort((P,R)=>P.priority - R.priority),
                    ()=>{
                        const P = c().internal;
                        P != null && P.subscribers && (P.priority = P.priority - (S > 0 ? 1 : 0),
                        P.subscribers = P.subscribers.filter(R=>R.ref !== g))
                    }
                }
            }
        }
    }
    )
      , i = t.getState();
    let r = i.size
      , s = i.viewport.dpr
      , o = i.camera;
    return t.subscribe(()=>{
        const {camera: a, size: c, viewport: f, gl: h, set: d} = t.getState();
        if (c.width !== r.width || c.height !== r.height || f.dpr !== s) {
            var m;
            r = c,
            s = f.dpr,
            xz(a, c),
            h.setPixelRatio(f.dpr);
            const v = (m = c.updateStyle) != null ? m : typeof HTMLCanvasElement < "u" && h.domElement instanceof HTMLCanvasElement;
            h.setSize(c.width, c.height, v)
        }
        a !== o && (o = a,
        d(v=>({
            viewport: {
                ...v.viewport,
                ...v.viewport.getCurrentViewport(a)
            }
        })))
    }
    ),
    t.subscribe(a=>n(a)),
    t
}
;
let Ld, Tz = new Set, Az = new Set, Cz = new Set;
function W0(n, e) {
    if (n.size)
        for (const {callback: t} of n.values())
            t(e)
}
function Ku(n, e) {
    switch (n) {
    case "before":
        return W0(Tz, e);
    case "after":
        return W0(Az, e);
    case "tail":
        return W0(Cz, e)
    }
}
let X0, Y0;
function j0(n, e, t) {
    let i = e.clock.getDelta();
    for (e.frameloop === "never" && typeof n == "number" && (i = n - e.clock.elapsedTime,
    e.clock.oldTime = e.clock.elapsedTime,
    e.clock.elapsedTime = n),
    X0 = e.internal.subscribers,
    Ld = 0; Ld < X0.length; Ld++)
        Y0 = X0[Ld],
        Y0.ref.current(Y0.store.getState(), i, t);
    return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    e.internal.frames = Math.max(0, e.internal.frames - 1),
    e.frameloop === "always" ? 1 : e.internal.frames
}
function Rz(n) {
    let e = !1, t = !1, i, r, s;
    function o(f) {
        r = requestAnimationFrame(o),
        e = !0,
        i = 0,
        Ku("before", f),
        t = !0;
        for (const d of n.values()) {
            var h;
            s = d.store.getState(),
            s.internal.active && (s.frameloop === "always" || s.internal.frames > 0) && !((h = s.gl.xr) != null && h.isPresenting) && (i += j0(f, s))
        }
        if (t = !1,
        Ku("after", f),
        i === 0)
            return Ku("tail", f),
            e = !1,
            cancelAnimationFrame(r)
    }
    function a(f, h=1) {
        var d;
        if (!f)
            return n.forEach(m=>a(m.store.getState(), h));
        (d = f.gl.xr) != null && d.isPresenting || !f.internal.active || f.frameloop === "never" || (h > 1 ? f.internal.frames = Math.min(60, f.internal.frames + h) : t ? f.internal.frames = 2 : f.internal.frames = 1,
        e || (e = !0,
        requestAnimationFrame(o)))
    }
    function c(f, h=!0, d, m) {
        if (h && Ku("before", f),
        d)
            j0(f, d, m);
        else
            for (const v of n.values())
                j0(f, v.store.getState());
        h && Ku("after", f)
    }
    return {
        loop: o,
        invalidate: a,
        advance: c
    }
}
function NR() {
    const n = ve.useContext(IR);
    if (!n)
        throw new Error("R3F: Hooks can only be used within the Canvas component!");
    return n
}
function Qw(n=t=>t, e) {
    return NR()(n, e)
}
function wx(n, e=0) {
    const t = NR()
      , i = t.getState().internal.subscribe
      , r = TR(n);
    return Af(()=>i(r, e, t), [e, i, t]),
    null
}
const $l = new Map
  , {invalidate: $w, advance: eE} = Rz($l)
  , {reconciler: Pp, applyProps: fl} = pz($l, Sz)
  , hl = {
    objects: "shallow",
    strict: !1
}
  , bz = (n,e)=>{
    const t = typeof n == "function" ? n(e) : n;
    return LR(t) ? t : new $_({
        powerPreference: "high-performance",
        canvas: e,
        antialias: !0,
        alpha: !0,
        ...n
    })
}
;
function Pz(n, e) {
    const t = typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement;
    if (e) {
        const {width: i, height: r, top: s, left: o, updateStyle: a=t} = e;
        return {
            width: i,
            height: r,
            top: s,
            left: o,
            updateStyle: a
        }
    } else if (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement && n.parentElement) {
        const {width: i, height: r, top: s, left: o} = n.parentElement.getBoundingClientRect();
        return {
            width: i,
            height: r,
            top: s,
            left: o,
            updateStyle: t
        }
    } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
        return {
            width: n.width,
            height: n.height,
            top: 0,
            left: 0,
            updateStyle: t
        };
    return {
        width: 0,
        height: 0,
        top: 0,
        left: 0
    }
}
function Lz(n) {
    const e = $l.get(n)
      , t = e == null ? void 0 : e.fiber
      , i = e == null ? void 0 : e.store;
    e && console.warn("R3F.createRoot should only be called once!");
    const r = typeof reportError == "function" ? reportError : console.error
      , s = i || Ez($w, eE)
      , o = t || Pp.createContainer(s, Dl.ConcurrentRoot, null, !1, null, "", r, null);
    e || $l.set(n, {
        fiber: o,
        store: s
    });
    let a, c = !1, f;
    return {
        configure(h={}) {
            let {gl: d, size: m, scene: v, events: _, onCreated: w, shadows: x=!1, linear: g=!1, flat: S=!1, legacy: M=!1, orthographic: T=!1, frameloop: P="always", dpr: R=[1, 2], performance: b, raycaster: N, camera: G, onPointerMissed: C} = h
              , I = s.getState()
              , K = I.gl;
            I.gl || I.set({
                gl: K = bz(d, n)
            });
            let se = I.raycaster;
            se || I.set({
                raycaster: se = new dR
            });
            const {params: B, ...ie} = N || {};
            if (jt.equ(ie, se, hl) || fl(se, {
                ...ie
            }),
            jt.equ(B, se.params, hl) || fl(se, {
                params: {
                    ...se.params,
                    ...B
                }
            }),
            !I.camera || I.camera === f && !jt.equ(f, G, hl)) {
                f = G;
                const V = G instanceof vf
                  , q = V ? G : T ? new xf(0,0,0,0,.1,1e3) : new Dn(75,0,.1,1e3);
                V || (q.position.z = 5,
                G && (fl(q, G),
                ("aspect"in G || "left"in G || "right"in G || "bottom"in G || "top"in G) && (q.manual = !0,
                q.updateProjectionMatrix())),
                !I.camera && !(G != null && G.rotation) && q.lookAt(0, 0, 0)),
                I.set({
                    camera: q
                }),
                se.camera = q
            }
            if (!I.scene) {
                let V;
                v instanceof Rp ? V = v : (V = new Rp,
                v && fl(V, v)),
                I.set({
                    scene: ml(V)
                })
            }
            if (!I.xr) {
                var J;
                const V = (Ce,Z)=>{
                    const de = s.getState();
                    de.frameloop !== "never" && eE(Ce, !0, de, Z)
                }
                  , q = ()=>{
                    const Ce = s.getState();
                    Ce.gl.xr.enabled = Ce.gl.xr.isPresenting,
                    Ce.gl.xr.setAnimationLoop(Ce.gl.xr.isPresenting ? V : null),
                    Ce.gl.xr.isPresenting || $w(Ce)
                }
                  , ce = {
                    connect() {
                        const Ce = s.getState().gl;
                        Ce.xr.addEventListener("sessionstart", q),
                        Ce.xr.addEventListener("sessionend", q)
                    },
                    disconnect() {
                        const Ce = s.getState().gl;
                        Ce.xr.removeEventListener("sessionstart", q),
                        Ce.xr.removeEventListener("sessionend", q)
                    }
                };
                typeof ((J = K.xr) == null ? void 0 : J.addEventListener) == "function" && ce.connect(),
                I.set({
                    xr: ce
                })
            }
            if (K.shadowMap) {
                const V = K.shadowMap.enabled
                  , q = K.shadowMap.type;
                if (K.shadowMap.enabled = !!x,
                jt.boo(x))
                    K.shadowMap.type = yc;
                else if (jt.str(x)) {
                    var ue;
                    const ce = {
                        basic: s2,
                        percentage: Zp,
                        soft: yc,
                        variance: xr
                    };
                    K.shadowMap.type = (ue = ce[x]) != null ? ue : yc
                } else
                    jt.obj(x) && Object.assign(K.shadowMap, x);
                (V !== K.shadowMap.enabled || q !== K.shadowMap.type) && (K.shadowMap.needsUpdate = !0)
            }
            const F = wR();
            F && ("enabled"in F ? F.enabled = !M : "legacyMode"in F && (F.legacyMode = M)),
            c || fl(K, {
                outputEncoding: g ? 3e3 : 3001,
                toneMapping: S ? Ar : Jp
            }),
            I.legacy !== M && I.set(()=>({
                legacy: M
            })),
            I.linear !== g && I.set(()=>({
                linear: g
            })),
            I.flat !== S && I.set(()=>({
                flat: S
            })),
            d && !jt.fun(d) && !LR(d) && !jt.equ(d, K, hl) && fl(K, d),
            _ && !I.events.handlers && I.set({
                events: _(s)
            });
            const H = Pz(n, m);
            return jt.equ(H, I.size, hl) || I.setSize(H.width, H.height, H.updateStyle, H.top, H.left),
            R && I.viewport.dpr !== RR(R) && I.setDpr(R),
            I.frameloop !== P && I.setFrameloop(P),
            I.onPointerMissed || I.set({
                onPointerMissed: C
            }),
            b && !jt.equ(b, I.performance, hl) && I.set(V=>({
                performance: {
                    ...V.performance,
                    ...b
                }
            })),
            a = w,
            c = !0,
            this
        },
        render(h) {
            return c || this.configure(),
            Pp.updateContainer(ve.createElement(Iz, {
                store: s,
                children: h,
                onCreated: a,
                rootElement: n
            }), o, null, ()=>{}
            ),
            s
        },
        unmount() {
            DR(n)
        }
    }
}
function Iz({store: n, children: e, onCreated: t, rootElement: i}) {
    return Af(()=>{
        const r = n.getState();
        r.set(s=>({
            internal: {
                ...s.internal,
                active: !0
            }
        })),
        t && t(r),
        n.getState().events.connected || r.events.connect == null || r.events.connect(i)
    }
    , []),
    ve.createElement(IR.Provider, {
        value: n
    }, e)
}
function DR(n, e) {
    const t = $l.get(n)
      , i = t == null ? void 0 : t.fiber;
    if (i) {
        const r = t == null ? void 0 : t.store.getState();
        r && (r.internal.active = !1),
        Pp.updateContainer(null, i, null, ()=>{
            r && setTimeout(()=>{
                try {
                    var s, o, a, c;
                    r.events.disconnect == null || r.events.disconnect(),
                    (s = r.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(),
                    (a = r.gl) == null || a.forceContextLoss == null || a.forceContextLoss(),
                    (c = r.gl) != null && c.xr && r.xr.disconnect(),
                    yz(r),
                    $l.delete(n)
                } catch {}
            }
            , 500)
        }
        )
    }
}
Pp.injectIntoDevTools({
    bundleType: 0,
    rendererPackageName: "@react-three/fiber",
    version: ve.version
});
function eu() {
    return eu = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    eu.apply(this, arguments)
}
function Oy(n, e, t) {
    var i, r, s, o, a;
    e == null && (e = 100);
    function c() {
        var h = Date.now() - o;
        h < e && h >= 0 ? i = setTimeout(c, e - h) : (i = null,
        t || (a = n.apply(s, r),
        s = r = null))
    }
    var f = function() {
        s = this,
        r = arguments,
        o = Date.now();
        var h = t && !i;
        return i || (i = setTimeout(c, e)),
        h && (a = n.apply(s, r),
        s = r = null),
        a
    };
    return f.clear = function() {
        i && (clearTimeout(i),
        i = null)
    }
    ,
    f.flush = function() {
        i && (a = n.apply(s, r),
        s = r = null,
        clearTimeout(i),
        i = null)
    }
    ,
    f
}
Oy.debounce = Oy;
var Nz = Oy;
const tE = zy(Nz);
function Dz(n) {
    let {debounce: e, scroll: t, polyfill: i, offsetSize: r} = n === void 0 ? {
        debounce: 0,
        scroll: !1,
        offsetSize: !1
    } : n;
    const s = i || (typeof window > "u" ? class {
    }
    : window.ResizeObserver);
    if (!s)
        throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
    const [o,a] = ve.useState({
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        bottom: 0,
        right: 0,
        x: 0,
        y: 0
    })
      , c = ve.useRef({
        element: null,
        scrollContainers: null,
        resizeObserver: null,
        lastBounds: o
    })
      , f = e ? typeof e == "number" ? e : e.scroll : null
      , h = e ? typeof e == "number" ? e : e.resize : null
      , d = ve.useRef(!1);
    ve.useEffect(()=>(d.current = !0,
    ()=>void (d.current = !1)));
    const [m,v,_] = ve.useMemo(()=>{
        const S = ()=>{
            if (!c.current.element)
                return;
            const {left: M, top: T, width: P, height: R, bottom: b, right: N, x: G, y: C} = c.current.element.getBoundingClientRect()
              , I = {
                left: M,
                top: T,
                width: P,
                height: R,
                bottom: b,
                right: N,
                x: G,
                y: C
            };
            c.current.element instanceof HTMLElement && r && (I.height = c.current.element.offsetHeight,
            I.width = c.current.element.offsetWidth),
            Object.freeze(I),
            d.current && !kz(c.current.lastBounds, I) && a(c.current.lastBounds = I)
        }
        ;
        return [S, h ? tE(S, h) : S, f ? tE(S, f) : S]
    }
    , [a, r, f, h]);
    function w() {
        c.current.scrollContainers && (c.current.scrollContainers.forEach(S=>S.removeEventListener("scroll", _, !0)),
        c.current.scrollContainers = null),
        c.current.resizeObserver && (c.current.resizeObserver.disconnect(),
        c.current.resizeObserver = null)
    }
    function x() {
        c.current.element && (c.current.resizeObserver = new s(_),
        c.current.resizeObserver.observe(c.current.element),
        t && c.current.scrollContainers && c.current.scrollContainers.forEach(S=>S.addEventListener("scroll", _, {
            capture: !0,
            passive: !0
        })))
    }
    const g = S=>{
        !S || S === c.current.element || (w(),
        c.current.element = S,
        c.current.scrollContainers = UR(S),
        x())
    }
    ;
    return Oz(_, !!t),
    Uz(v),
    ve.useEffect(()=>{
        w(),
        x()
    }
    , [t, _, v]),
    ve.useEffect(()=>w, []),
    [g, o, m]
}
function Uz(n) {
    ve.useEffect(()=>{
        const e = n;
        return window.addEventListener("resize", e),
        ()=>void window.removeEventListener("resize", e)
    }
    , [n])
}
function Oz(n, e) {
    ve.useEffect(()=>{
        if (e) {
            const t = n;
            return window.addEventListener("scroll", t, {
                capture: !0,
                passive: !0
            }),
            ()=>void window.removeEventListener("scroll", t, !0)
        }
    }
    , [n, e])
}
function UR(n) {
    const e = [];
    if (!n || n === document.body)
        return e;
    const {overflow: t, overflowX: i, overflowY: r} = window.getComputedStyle(n);
    return [t, i, r].some(s=>s === "auto" || s === "scroll") && e.push(n),
    [...e, ...UR(n.parentElement)]
}
const Fz = ["x", "y", "top", "bottom", "left", "right", "width", "height"]
  , kz = (n,e)=>Fz.every(t=>n[t] === e[t]);
var zz = Object.defineProperty, Bz = Object.defineProperties, Hz = Object.getOwnPropertyDescriptors, nE = Object.getOwnPropertySymbols, Vz = Object.prototype.hasOwnProperty, Gz = Object.prototype.propertyIsEnumerable, iE = (n,e,t)=>e in n ? zz(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t, rE = (n,e)=>{
    for (var t in e || (e = {}))
        Vz.call(e, t) && iE(n, t, e[t]);
    if (nE)
        for (var t of nE(e))
            Gz.call(e, t) && iE(n, t, e[t]);
    return n
}
, Wz = (n,e)=>Bz(n, Hz(e)), sE, oE;
typeof window < "u" && ((sE = window.document) != null && sE.createElement || ((oE = window.navigator) == null ? void 0 : oE.product) === "ReactNative") ? ve.useLayoutEffect : ve.useEffect;
function OR(n, e, t) {
    if (!n)
        return;
    if (t(n) === !0)
        return n;
    let i = n.child;
    for (; i; ) {
        const r = OR(i, e, t);
        if (r)
            return r;
        i = i.sibling
    }
}
function FR(n) {
    try {
        return Object.defineProperties(n, {
            _currentRenderer: {
                get() {
                    return null
                },
                set() {}
            },
            _currentRenderer2: {
                get() {
                    return null
                },
                set() {}
            }
        })
    } catch {
        return n
    }
}
const aE = console.error;
console.error = function() {
    const n = [...arguments].join("");
    if (n != null && n.startsWith("Warning:") && n.includes("useContext")) {
        console.error = aE;
        return
    }
    return aE.apply(this, arguments)
}
;
const Ex = FR(ve.createContext(null));
class kR extends ve.Component {
    render() {
        return ve.createElement(Ex.Provider, {
            value: this._reactInternals
        }, this.props.children)
    }
}
function Xz() {
    const n = ve.useContext(Ex);
    if (n === null)
        throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
    const e = ve.useId();
    return ve.useMemo(()=>{
        for (const i of [n, n == null ? void 0 : n.alternate]) {
            if (!i)
                continue;
            const r = OR(i, !1, s=>{
                let o = s.memoizedState;
                for (; o; ) {
                    if (o.memoizedState === e)
                        return !0;
                    o = o.next
                }
            }
            );
            if (r)
                return r
        }
    }
    , [n, e])
}
function Yz() {
    const n = Xz()
      , [e] = ve.useState(()=>new Map);
    e.clear();
    let t = n;
    for (; t; ) {
        if (t.type && typeof t.type == "object") {
            const r = t.type._context === void 0 && t.type.Provider === t.type ? t.type : t.type._context;
            r && r !== Ex && !e.has(r) && e.set(r, ve.useContext(FR(r)))
        }
        t = t.return
    }
    return e
}
function jz() {
    const n = Yz();
    return ve.useMemo(()=>Array.from(n.keys()).reduce((e,t)=>i=>ve.createElement(e, null, ve.createElement(t.Provider, Wz(rE({}, i), {
        value: n.get(t)
    }))), e=>ve.createElement(kR, rE({}, e))), [n])
}
const q0 = {
    onClick: ["click", !1],
    onContextMenu: ["contextmenu", !1],
    onDoubleClick: ["dblclick", !1],
    onWheel: ["wheel", !0],
    onPointerDown: ["pointerdown", !0],
    onPointerUp: ["pointerup", !0],
    onPointerLeave: ["pointerleave", !0],
    onPointerMove: ["pointermove", !0],
    onPointerCancel: ["pointercancel", !0],
    onLostPointerCapture: ["lostpointercapture", !0]
};
function qz(n) {
    const {handlePointer: e} = wz(n);
    return {
        priority: 1,
        enabled: !0,
        compute(t, i, r) {
            i.pointer.set(t.offsetX / i.size.width * 2 - 1, -(t.offsetY / i.size.height) * 2 + 1),
            i.raycaster.setFromCamera(i.pointer, i.camera)
        },
        connected: void 0,
        handlers: Object.keys(q0).reduce((t,i)=>({
            ...t,
            [i]: e(i)
        }), {}),
        update: ()=>{
            var t;
            const {events: i, internal: r} = n.getState();
            (t = r.lastEvent) != null && t.current && i.handlers && i.handlers.onPointerMove(r.lastEvent.current)
        }
        ,
        connect: t=>{
            var i;
            const {set: r, events: s} = n.getState();
            s.disconnect == null || s.disconnect(),
            r(o=>({
                events: {
                    ...o.events,
                    connected: t
                }
            })),
            Object.entries((i = s.handlers) != null ? i : []).forEach(([o,a])=>{
                const [c,f] = q0[o];
                t.addEventListener(c, a, {
                    passive: f
                })
            }
            )
        }
        ,
        disconnect: ()=>{
            const {set: t, events: i} = n.getState();
            if (i.connected) {
                var r;
                Object.entries((r = i.handlers) != null ? r : []).forEach(([s,o])=>{
                    if (i && i.connected instanceof HTMLElement) {
                        const [a] = q0[s];
                        i.connected.removeEventListener(a, o)
                    }
                }
                ),
                t(s=>({
                    events: {
                        ...s.events,
                        connected: void 0
                    }
                }))
            }
        }
    }
}
const Zz = ve.forwardRef(function({children: e, fallback: t, resize: i, style: r, gl: s, events: o=qz, eventSource: a, eventPrefix: c, shadows: f, linear: h, flat: d, legacy: m, orthographic: v, frameloop: _, dpr: w, performance: x, raycaster: g, camera: S, scene: M, onPointerMissed: T, onCreated: P, ...R}, b) {
    ve.useMemo(()=>Mx(tz), []);
    const N = jz()
      , [G,C] = Dz({
        scroll: !0,
        debounce: {
            scroll: 50,
            resize: 0
        },
        ...i
    })
      , I = ve.useRef(null)
      , K = ve.useRef(null);
    ve.useImperativeHandle(b, ()=>I.current);
    const se = TR(T)
      , [B,ie] = ve.useState(!1)
      , [J,ue] = ve.useState(!1);
    if (B)
        throw B;
    if (J)
        throw J;
    const F = ve.useRef(null);
    Af(()=>{
        const V = I.current;
        C.width > 0 && C.height > 0 && V && (F.current || (F.current = Lz(V)),
        F.current.configure({
            gl: s,
            events: o,
            shadows: f,
            linear: h,
            flat: d,
            legacy: m,
            orthographic: v,
            frameloop: _,
            dpr: w,
            performance: x,
            raycaster: g,
            camera: S,
            scene: M,
            size: C,
            onPointerMissed: (...q)=>se.current == null ? void 0 : se.current(...q),
            onCreated: q=>{
                q.events.connect == null || q.events.connect(a ? mz(a) ? a.current : a : K.current),
                c && q.setEvents({
                    compute: (ce,Ce)=>{
                        const Z = ce[c + "X"]
                          , de = ce[c + "Y"];
                        Ce.pointer.set(Z / Ce.size.width * 2 - 1, -(de / Ce.size.height) * 2 + 1),
                        Ce.raycaster.setFromCamera(Ce.pointer, Ce.camera)
                    }
                }),
                P == null || P(q)
            }
        }),
        F.current.render(ve.createElement(N, null, ve.createElement(AR, {
            set: ue
        }, ve.createElement(ve.Suspense, {
            fallback: ve.createElement(gz, {
                set: ie
            })
        }, e)))))
    }
    ),
    ve.useEffect(()=>{
        const V = I.current;
        if (V)
            return ()=>DR(V)
    }
    , []);
    const H = a ? "none" : "auto";
    return ve.createElement("div", eu({
        ref: K,
        style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: H,
            ...r
        }
    }, R), ve.createElement("div", {
        ref: G,
        style: {
            width: "100%",
            height: "100%"
        }
    }, ve.createElement("canvas", {
        ref: I,
        style: {
            display: "block"
        }
    }, t)))
})
  , Jz = ve.forwardRef(function(e, t) {
    return ve.createElement(kR, null, ve.createElement(Zz, eu({}, e, {
        ref: t
    })))
});
function wc(n, e, t) {
    return e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
function Fy(n, e) {
    (e == null || e > n.length) && (e = n.length);
    for (var t = 0, i = new Array(e); t < e; t++)
        i[t] = n[t];
    return i
}
function Kz(n, e) {
    if (n) {
        if (typeof n == "string")
            return Fy(n, e);
        var t = Object.prototype.toString.call(n).slice(8, -1);
        if (t === "Object" && n.constructor && (t = n.constructor.name),
        t === "Map" || t === "Set")
            return Array.from(n);
        if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
            return Fy(n, e)
    }
}
function Qz(n) {
    if (Array.isArray(n))
        return Fy(n)
}
function $z(n) {
    if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null)
        return Array.from(n)
}
function e4() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function t4(n) {
    return Qz(n) || $z(n) || Kz(n) || e4()
}
new he;
new he;
function n4(n, e, t) {
    return Math.max(e, Math.min(t, n))
}
function i4(n, e) {
    return n4(n - Math.floor(n / e) * e, 0, e)
}
function r4(n, e) {
    var t = i4(e - n, Math.PI * 2);
    return t > Math.PI && (t -= Math.PI * 2),
    t
}
function zR(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
var ir = function n(e, t, i) {
    var r = this;
    zR(this, n),
    wc(this, "dot2", function(s, o) {
        return r.x * s + r.y * o
    }),
    wc(this, "dot3", function(s, o, a) {
        return r.x * s + r.y * o + r.z * a
    }),
    this.x = e,
    this.y = t,
    this.z = i
}
  , s4 = [new ir(1,1,0), new ir(-1,1,0), new ir(1,-1,0), new ir(-1,-1,0), new ir(1,0,1), new ir(-1,0,1), new ir(1,0,-1), new ir(-1,0,-1), new ir(0,1,1), new ir(0,-1,1), new ir(0,1,-1), new ir(0,-1,-1)]
  , lE = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]
  , uE = new Array(512)
  , cE = new Array(512)
  , o4 = function(e) {
    e > 0 && e < 1 && (e *= 65536),
    e = Math.floor(e),
    e < 256 && (e |= e << 8);
    for (var t = 0; t < 256; t++) {
        var i;
        t & 1 ? i = lE[t] ^ e & 255 : i = lE[t] ^ e >> 8 & 255,
        uE[t] = uE[t + 256] = i,
        cE[t] = cE[t + 256] = s4[i % 12]
    }
};
o4(0);
function a4(n) {
    if (typeof n == "number")
        n = Math.abs(n);
    else if (typeof n == "string") {
        var e = n;
        n = 0;
        for (var t = 0; t < e.length; t++)
            n = (n + (t + 1) * (e.charCodeAt(t) % 96)) % 2147483647
    }
    return n === 0 && (n = 311),
    n
}
function fE(n) {
    var e = a4(n);
    return function() {
        var t = e * 48271 % 2147483647;
        return e = t,
        t / 2147483647
    }
}
var l4 = function n(e) {
    var t = this;
    zR(this, n),
    wc(this, "seed", 0),
    wc(this, "init", function(i) {
        t.seed = i,
        t.value = fE(i)
    }),
    wc(this, "value", fE(this.seed)),
    this.init(e)
};
new l4(Math.random());
var u4 = function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : .01
      , i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
      , r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1 / (2 * Math.PI);
    return i / Math.atan(1 / t) * Math.atan(Math.sin(2 * Math.PI * e * r) / t)
}
  , BR = function(e) {
    return 1 / (1 + e + .48 * e * e + .235 * e * e * e)
}
  , c4 = function(e) {
    return e
}
  , f4 = {
    in: function(e) {
        return 1 - Math.cos(e * Math.PI / 2)
    },
    out: function(e) {
        return Math.sin(e * Math.PI / 2)
    },
    inOut: function(e) {
        return -(Math.cos(Math.PI * e) - 1) / 2
    }
}
  , h4 = {
    in: function(e) {
        return e * e * e
    },
    out: function(e) {
        return 1 - Math.pow(1 - e, 3)
    },
    inOut: function(e) {
        return e < .5 ? 4 * e * e * e : 1 - Math.pow(-2 * e + 2, 3) / 2
    }
}
  , d4 = {
    in: function(e) {
        return e * e * e * e * e
    },
    out: function(e) {
        return 1 - Math.pow(1 - e, 5)
    },
    inOut: function(e) {
        return e < .5 ? 16 * e * e * e * e * e : 1 - Math.pow(-2 * e + 2, 5) / 2
    }
}
  , p4 = {
    in: function(e) {
        return 1 - Math.sqrt(1 - Math.pow(e, 2))
    },
    out: function(e) {
        return Math.sqrt(1 - Math.pow(e - 1, 2))
    },
    inOut: function(e) {
        return e < .5 ? (1 - Math.sqrt(1 - Math.pow(2 * e, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * e + 2, 2)) + 1) / 2
    }
}
  , m4 = {
    in: function(e) {
        return e * e * e * e
    },
    out: function(e) {
        return 1 - --e * e * e * e
    },
    inOut: function(e) {
        return e < .5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e
    }
}
  , g4 = {
    in: function(e) {
        return e === 0 ? 0 : Math.pow(2, 10 * e - 10)
    },
    out: function(e) {
        return e === 1 ? 1 : 1 - Math.pow(2, -10 * e)
    },
    inOut: function(e) {
        return e === 0 ? 0 : e === 1 ? 1 : e < .5 ? Math.pow(2, 20 * e - 10) / 2 : (2 - Math.pow(2, -20 * e + 10)) / 2
    }
};
function wn(n, e, t) {
    var i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : .25
      , r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : .01
      , s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1 / 0
      , o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : BR
      , a = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : .001
      , c = "velocity_" + e;
    if (n.__damp === void 0 && (n.__damp = {}),
    n.__damp[c] === void 0 && (n.__damp[c] = 0),
    Math.abs(n[e] - t) <= a)
        return n[e] = t,
        !1;
    i = Math.max(1e-4, i);
    var f = 2 / i
      , h = o(f * r)
      , d = n[e] - t
      , m = t
      , v = s * i;
    d = Math.min(Math.max(d, -v), v),
    t = n[e] - d;
    var _ = (n.__damp[c] + f * d) * r;
    n.__damp[c] = (n.__damp[c] - f * _) * h;
    var w = t + (d + _) * h;
    return m - n[e] > 0 == w > m && (w = m,
    n.__damp[c] = (w - m) / r),
    n[e] = w,
    !0
}
var v4 = function(e) {
    return e && e.isCamera
}
  , y4 = function(e) {
    return e && e.isLight
}
  , Qu = new U
  , hE = new En
  , dE = new En
  , $u = new $e
  , Z0 = new U;
function _4(n, e, t, i, r, s, o) {
    typeof e == "number" ? Qu.setScalar(e) : Array.isArray(e) ? Qu.set(e[0], e[1], e[2]) : Qu.copy(e);
    var a = n.parent;
    n.updateWorldMatrix(!0, !1),
    Z0.setFromMatrixPosition(n.matrixWorld),
    v4(n) || y4(n) ? $u.lookAt(Z0, Qu, n.up) : $u.lookAt(Qu, Z0, n.up),
    Lp(n.quaternion, dE.setFromRotationMatrix($u), t, i, r, s, o),
    a && ($u.extractRotation(a.matrixWorld),
    hE.setFromRotationMatrix($u),
    Lp(n.quaternion, dE.copy(n.quaternion).premultiply(hE.invert()), t, i, r, s, o))
}
function Vl(n, e, t, i, r, s, o, a) {
    return wn(n, e, n[e] + r4(n[e], t), i, r, s, o, a)
}
var ec = new he, pE, mE;
function x4(n, e, t, i, r, s, o) {
    return typeof e == "number" ? ec.setScalar(e) : Array.isArray(e) ? ec.set(e[0], e[1]) : ec.copy(e),
    pE = wn(n, "x", ec.x, t, i, r, s, o),
    mE = wn(n, "y", ec.y, t, i, r, s, o),
    pE || mE
}
var dl = new U, gE, vE, yE;
function ky(n, e, t, i, r, s, o) {
    return typeof e == "number" ? dl.setScalar(e) : Array.isArray(e) ? dl.set(e[0], e[1], e[2]) : dl.copy(e),
    gE = wn(n, "x", dl.x, t, i, r, s, o),
    vE = wn(n, "y", dl.y, t, i, r, s, o),
    yE = wn(n, "z", dl.z, t, i, r, s, o),
    gE || vE || yE
}
var Xo = new Ct, _E, xE, SE, ME;
function S4(n, e, t, i, r, s, o) {
    return typeof e == "number" ? Xo.setScalar(e) : Array.isArray(e) ? Xo.set(e[0], e[1], e[2], e[3]) : Xo.copy(e),
    _E = wn(n, "x", Xo.x, t, i, r, s, o),
    xE = wn(n, "y", Xo.y, t, i, r, s, o),
    SE = wn(n, "z", Xo.z, t, i, r, s, o),
    ME = wn(n, "w", Xo.w, t, i, r, s, o),
    _E || xE || SE || ME
}
var tc = new Ri, wE, EE, TE;
function M4(n, e, t, i, r, s, o) {
    return Array.isArray(e) ? tc.set(e[0], e[1], e[2], e[3]) : tc.copy(e),
    wE = Vl(n, "x", tc.x, t, i, r, s, o),
    EE = Vl(n, "y", tc.y, t, i, r, s, o),
    TE = Vl(n, "z", tc.z, t, i, r, s, o),
    wE || EE || TE
}
var pl = new Ne, AE, CE, RE;
function w4(n, e, t, i, r, s, o) {
    return e instanceof Ne ? pl.copy(e) : Array.isArray(e) ? pl.setRGB(e[0], e[1], e[2]) : pl.set(e),
    AE = wn(n, "r", pl.r, t, i, r, s, o),
    CE = wn(n, "g", pl.g, t, i, r, s, o),
    RE = wn(n, "b", pl.b, t, i, r, s, o),
    AE || CE || RE
}
var yr = new En, cs = new Ct, bE = new Ct, nc = new Ct, PE, LE, IE, NE;
function Lp(n, e, t, i, r, s, o) {
    var a = n;
    Array.isArray(e) ? yr.set(e[0], e[1], e[2], e[3]) : yr.copy(e);
    var c = n.dot(yr) > 0 ? 1 : -1;
    return yr.x *= c,
    yr.y *= c,
    yr.z *= c,
    yr.w *= c,
    PE = wn(n, "x", yr.x, t, i, r, s, o),
    LE = wn(n, "y", yr.y, t, i, r, s, o),
    IE = wn(n, "z", yr.z, t, i, r, s, o),
    NE = wn(n, "w", yr.w, t, i, r, s, o),
    cs.set(n.x, n.y, n.z, n.w).normalize(),
    bE.set(a.__damp.velocity_x, a.__damp.velocity_y, a.__damp.velocity_z, a.__damp.velocity_w),
    nc.copy(cs).multiplyScalar(bE.dot(cs) / cs.dot(cs)),
    a.__damp.velocity_x -= nc.x,
    a.__damp.velocity_y -= nc.y,
    a.__damp.velocity_z -= nc.z,
    a.__damp.velocity_w -= nc.w,
    n.set(cs.x, cs.y, cs.z, cs.w),
    PE || LE || IE || NE
}
var ic = new pR, DE, UE, OE;
function E4(n, e, t, i, r, s, o) {
    return Array.isArray(e) ? ic.set(e[0], e[1], e[2]) : ic.copy(e),
    DE = wn(n, "radius", ic.radius, t, i, r, s, o),
    UE = Vl(n, "phi", ic.phi, t, i, r, s, o),
    OE = Vl(n, "theta", ic.theta, t, i, r, s, o),
    DE || UE || OE
}
var Id = new $e, FE = new U, kE = new En, zE = new U, BE, HE, VE;
function T4(n, e, t, i, r, s, o) {
    var a = n;
    return a.__damp === void 0 && (a.__damp = {
        position: new U,
        rotation: new En,
        scale: new U
    },
    n.decompose(a.__damp.position, a.__damp.rotation, a.__damp.scale)),
    Array.isArray(e) ? Id.set.apply(Id, t4(e)) : Id.copy(e),
    Id.decompose(FE, kE, zE),
    BE = ky(a.__damp.position, FE, t, i, r, s, o),
    HE = Lp(a.__damp.rotation, kE, t, i, r, s, o),
    VE = ky(a.__damp.scale, zE, t, i, r, s, o),
    n.compose(a.__damp.position, a.__damp.rotation, a.__damp.scale),
    BE || HE || VE
}
var A4 = Object.freeze({
    __proto__: null,
    rsqw: u4,
    exp: BR,
    linear: c4,
    sine: f4,
    cubic: h4,
    quint: d4,
    circ: p4,
    quart: m4,
    expo: g4,
    damp: wn,
    dampLookAt: _4,
    dampAngle: Vl,
    damp2: x4,
    damp3: ky,
    damp4: S4,
    dampE: M4,
    dampC: w4,
    dampQ: Lp,
    dampS: E4,
    dampM: T4
});
function C4(n, e=1e-4) {
    e = Math.max(e, Number.EPSILON);
    const t = {}
      , i = n.getIndex()
      , r = n.getAttribute("position")
      , s = i ? i.count : r.count;
    let o = 0;
    const a = Object.keys(n.attributes)
      , c = {}
      , f = {}
      , h = []
      , d = ["getX", "getY", "getZ", "getW"];
    for (let w = 0, x = a.length; w < x; w++) {
        const g = a[w];
        c[g] = [];
        const S = n.morphAttributes[g];
        S && (f[g] = new Array(S.length).fill(0).map(()=>[]))
    }
    const m = Math.log10(1 / e)
      , v = Math.pow(10, m);
    for (let w = 0; w < s; w++) {
        const x = i ? i.getX(w) : w;
        let g = "";
        for (let S = 0, M = a.length; S < M; S++) {
            const T = a[S]
              , P = n.getAttribute(T)
              , R = P.itemSize;
            for (let b = 0; b < R; b++)
                g += `${~~(P[d[b]](x) * v)},`
        }
        if (g in t)
            h.push(t[g]);
        else {
            for (let S = 0, M = a.length; S < M; S++) {
                const T = a[S]
                  , P = n.getAttribute(T)
                  , R = n.morphAttributes[T]
                  , b = P.itemSize
                  , N = c[T]
                  , G = f[T];
                for (let C = 0; C < b; C++) {
                    const I = d[C];
                    if (N.push(P[I](x)),
                    R)
                        for (let K = 0, se = R.length; K < se; K++)
                            G[K].push(R[K][I](x))
                }
            }
            t[g] = o,
            h.push(o),
            o++
        }
    }
    const _ = n.clone();
    for (let w = 0, x = a.length; w < x; w++) {
        const g = a[w]
          , S = n.getAttribute(g)
          , M = new S.array.constructor(c[g])
          , T = new Nt(M,S.itemSize,S.normalized);
        if (_.setAttribute(g, T),
        g in f)
            for (let P = 0; P < f[g].length; P++) {
                const R = n.morphAttributes[g][P]
                  , b = new R.array.constructor(f[g][P])
                  , N = new Nt(b,R.itemSize,R.normalized);
                _.morphAttributes[g][P] = N
            }
    }
    return _.setIndex(h),
    _
}
class R4 extends Mf {
    constructor(e, t={}) {
        const {bevelEnabled: i=!1, bevelSize: r=8, bevelThickness: s=10, font: o, height: a=50, size: c=100, lineHeight: f=1, letterSpacing: h=0, ...d} = t;
        if (o === void 0)
            super();
        else {
            const m = o.generateShapes(e, c, {
                lineHeight: f,
                letterSpacing: h
            });
            super(m, {
                ...d,
                bevelEnabled: i,
                bevelSize: r,
                bevelThickness: s,
                depth: a
            })
        }
        this.type = "TextGeometry"
    }
}
var b4 = Object.defineProperty
  , P4 = (n,e,t)=>e in n ? b4(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Tx = (n,e,t)=>(P4(n, typeof e != "symbol" ? e + "" : e, t),
t);
class L4 extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new Jr(this.manager);
        s.setPath(this.path),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials),
        s.load(e, o=>{
            if (typeof o != "string")
                throw new Error("unsupported data type");
            const a = JSON.parse(o)
              , c = this.parse(a);
            t && t(c)
        }
        , i, r)
    }
    loadAsync(e, t) {
        return super.loadAsync(e, t)
    }
    parse(e) {
        return new Ax(e)
    }
}
class Ax {
    constructor(e) {
        Tx(this, "data"),
        this.data = e
    }
    generateShapes(e, t=100, i) {
        const r = []
          , s = {
            letterSpacing: 0,
            lineHeight: 1,
            ...i
        }
          , o = I4(e, t, this.data, s);
        for (let a = 0, c = o.length; a < c; a++)
            Array.prototype.push.apply(r, o[a].toShapes(!1));
        return r
    }
}
Tx(Ax, "isFont");
Tx(Ax, "type");
function I4(n, e, t, i) {
    const r = Array.from(n)
      , s = e / t.resolution
      , o = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * s
      , a = [];
    let c = 0
      , f = 0;
    for (let h = 0; h < r.length; h++) {
        const d = r[h];
        if (d === `
`)
            c = 0,
            f -= o * i.lineHeight;
        else {
            const m = N4(d, s, c, f, t);
            m && (c += m.offsetX + i.letterSpacing,
            a.push(m.path))
        }
    }
    return a
}
function N4(n, e, t, i, r) {
    const s = r.glyphs[n] || r.glyphs["?"];
    if (!s) {
        console.error('THREE.Font: character "' + n + '" does not exists in font family ' + r.familyName + ".");
        return
    }
    const o = new gR;
    let a, c, f, h, d, m, v, _;
    if (s.o) {
        const w = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
        for (let x = 0, g = w.length; x < g; )
            switch (w[x++]) {
            case "m":
                a = parseInt(w[x++]) * e + t,
                c = parseInt(w[x++]) * e + i,
                o.moveTo(a, c);
                break;
            case "l":
                a = parseInt(w[x++]) * e + t,
                c = parseInt(w[x++]) * e + i,
                o.lineTo(a, c);
                break;
            case "q":
                f = parseInt(w[x++]) * e + t,
                h = parseInt(w[x++]) * e + i,
                d = parseInt(w[x++]) * e + t,
                m = parseInt(w[x++]) * e + i,
                o.quadraticCurveTo(d, m, f, h);
                break;
            case "b":
                f = parseInt(w[x++]) * e + t,
                h = parseInt(w[x++]) * e + i,
                d = parseInt(w[x++]) * e + t,
                m = parseInt(w[x++]) * e + i,
                v = parseInt(w[x++]) * e + t,
                _ = parseInt(w[x++]) * e + i,
                o.bezierCurveTo(d, m, v, _, f, h);
                break
            }
    }
    return {
        offsetX: s.ha * e,
        path: o
    }
}
let J0 = null;
async function D4(n) {
    return typeof n == "string" ? await (await fetch(n)).json() : n
}
function U4(n) {
    return J0 || (J0 = new L4),
    J0.parse(n)
}
async function HR(n) {
    const e = await D4(n);
    return U4(e)
}
function Cx(n) {
    return fz(HR, [n])
}
Cx.preload = n=>hz(HR, [n]);
Cx.clear = n=>dz([n]);
const O4 = ["string", "number"]
  , F4 = n=>{
    let e = "";
    const t = [];
    return ve.Children.forEach(n, i=>{
        O4.includes(typeof i) ? e += i + "" : t.push(i)
    }
    ),
    [e, ...t]
}
  , GE = ve.forwardRef(({font: n, letterSpacing: e=0, lineHeight: t=1, size: i=1, height: r=.2, bevelThickness: s=.1, bevelSize: o=.01, bevelEnabled: a=!1, bevelOffset: c=0, bevelSegments: f=4, curveSegments: h=8, smooth: d, children: m, ...v},_)=>{
    ve.useMemo(()=>Mx({
        RenamedTextGeometry: R4
    }), []);
    const w = ve.useRef(null)
      , x = Cx(n)
      , g = ve.useMemo(()=>({
        font: x,
        size: i,
        height: r,
        bevelThickness: s,
        bevelSize: o,
        bevelEnabled: a,
        bevelSegments: f,
        bevelOffset: c,
        curveSegments: h,
        letterSpacing: e,
        lineHeight: t
    }), [x, i, r, s, o, a, f, c, h, e, t])
      , [S,...M] = ve.useMemo(()=>F4(m), [m])
      , T = ve.useMemo(()=>[S, g], [S, g]);
    return ve.useLayoutEffect(()=>{
        d && (w.current.geometry = C4(w.current.geometry, d),
        w.current.geometry.computeVertexNormals())
    }
    , [T, d]),
    ve.useImperativeHandle(_, ()=>w.current, []),
    ve.createElement("mesh", eu({}, v, {
        ref: w
    }), ve.createElement("renamedTextGeometry", {
        args: T
    }), M)
}
);
function k4(n, e, t, i) {
    const r = class extends fr {
        constructor(o={}) {
            const a = Object.entries(n);
            super({
                uniforms: a.reduce((c,[f,h])=>{
                    const d = Z_.clone({
                        [f]: {
                            value: h
                        }
                    });
                    return {
                        ...c,
                        ...d
                    }
                }
                , {}),
                vertexShader: e,
                fragmentShader: t
            }),
            this.key = "",
            a.forEach(([c])=>Object.defineProperty(this, c, {
                get: ()=>this.uniforms[c].value,
                set: f=>this.uniforms[c].value = f
            })),
            Object.assign(this, o)
        }
    }
    ;
    return r.key = rC.generateUUID(),
    r
}
function WE(n, e, t) {
    const i = Qw(m=>m.size)
      , r = Qw(m=>m.viewport)
      , s = typeof n == "number" ? n : i.width * r.dpr
      , o = i.height * r.dpr
      , a = (typeof n == "number" ? t : n) || {}
      , {samples: c=0, depth: f, ...h} = a
      , d = ve.useMemo(()=>{
        const m = new cr(s,o,{
            minFilter: Wt,
            magFilter: Wt,
            type: va,
            ...h
        });
        return f && (m.depthTexture = new nm(s,o,wi)),
        m.samples = c,
        m
    }
    , []);
    return ve.useLayoutEffect(()=>{
        d.setSize(s, o),
        c && (d.samples = c)
    }
    , [c, d, s, o]),
    ve.useEffect(()=>()=>d.dispose(), []),
    d
}
const z4 = k4({}, "void main() { }", "void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }");
class B4 extends cx {
    constructor(e=6, t=!1) {
        super(),
        this.uniforms = {
            chromaticAberration: {
                value: .05
            },
            transmission: {
                value: 0
            },
            _transmission: {
                value: 1
            },
            transmissionMap: {
                value: null
            },
            roughness: {
                value: 0
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            attenuationDistance: {
                value: 1 / 0
            },
            attenuationColor: {
                value: new Ne("white")
            },
            anisotropicBlur: {
                value: .1
            },
            time: {
                value: 0
            },
            distortion: {
                value: 0
            },
            distortionScale: {
                value: .5
            },
            temporalDistortion: {
                value: 0
            },
            buffer: {
                value: null
            }
        },
        this.onBeforeCompile = i=>{
            i.uniforms = {
                ...i.uniforms,
                ...this.uniforms
            },
            this.anisotropy > 0 && (i.defines.USE_ANISOTROPY = ""),
            t ? i.defines.USE_SAMPLER = "" : i.defines.USE_TRANSMISSION = "",
            i.fragmentShader = `
      uniform float chromaticAberration;
      uniform float anisotropicBlur;
      uniform float time;
      uniform float distortion;
      uniform float distortionScale;
      uniform float temporalDistortion;
      uniform sampler2D buffer;

      vec3 random3(vec3 c) {
        float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
        vec3 r;
        r.z = fract(512.0*j);
        j *= .125;
        r.x = fract(512.0*j);
        j *= .125;
        r.y = fract(512.0*j);
        return r-0.5;
      }

      uint hash( uint x ) {
        x += ( x << 10u );
        x ^= ( x >>  6u );
        x += ( x <<  3u );
        x ^= ( x >> 11u );
        x += ( x << 15u );
        return x;
      }

      // Compound versions of the hashing algorithm I whipped together.
      uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }
      uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }
      uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }

      // Construct a float with half-open range [0:1] using low 23 bits.
      // All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
      float floatConstruct( uint m ) {
        const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
        const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32
        m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
        m |= ieeeOne;                          // Add fractional part to 1.0
        float  f = uintBitsToFloat( m );       // Range [1:2]
        return f - 1.0;                        // Range [0:1]
      }

      // Pseudo-random value in half-open range [0:1].
      float randomBase( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }
      float randomBase( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
      float randomBase( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
      float randomBase( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
      float rand(float seed) {
        float result = randomBase(vec3(gl_FragCoord.xy, seed));
        return result;
      }

      const float F3 =  0.3333333;
      const float G3 =  0.1666667;

      float snoise(vec3 p) {
        vec3 s = floor(p + dot(p, vec3(F3)));
        vec3 x = p - s + dot(s, vec3(G3));
        vec3 e = step(vec3(0.0), x - x.yzx);
        vec3 i1 = e*(1.0 - e.zxy);
        vec3 i2 = 1.0 - e.zxy*(1.0 - e);
        vec3 x1 = x - i1 + G3;
        vec3 x2 = x - i2 + 2.0*G3;
        vec3 x3 = x - 1.0 + 3.0*G3;
        vec4 w, d;
        w.x = dot(x, x);
        w.y = dot(x1, x1);
        w.z = dot(x2, x2);
        w.w = dot(x3, x3);
        w = max(0.6 - w, 0.0);
        d.x = dot(random3(s), x);
        d.y = dot(random3(s + i1), x1);
        d.z = dot(random3(s + i2), x2);
        d.w = dot(random3(s + 1.0), x3);
        w *= w;
        w *= w;
        d *= w;
        return dot(d, vec4(52.0));
      }

      float snoiseFractal(vec3 m) {
        return 0.5333333* snoise(m)
              +0.2666667* snoise(2.0*m)
              +0.1333333* snoise(4.0*m)
              +0.0666667* snoise(8.0*m);
      }
` + i.fragmentShader,
            i.fragmentShader = i.fragmentShader.replace("#include <transmission_pars_fragment>", `
        #ifdef USE_TRANSMISSION
          // Transmission code is based on glTF-Sampler-Viewer
          // https://github.com/KhronosGroup/glTF-Sample-Viewer
          uniform float _transmission;
          uniform float thickness;
          uniform float attenuationDistance;
          uniform vec3 attenuationColor;
          #ifdef USE_TRANSMISSIONMAP
            uniform sampler2D transmissionMap;
          #endif
          #ifdef USE_THICKNESSMAP
            uniform sampler2D thicknessMap;
          #endif
          uniform vec2 transmissionSamplerSize;
          uniform sampler2D transmissionSamplerMap;
          uniform mat4 modelMatrix;
          uniform mat4 projectionMatrix;
          varying vec3 vWorldPosition;
          vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
            // Direction of refracted light.
            vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
            // Compute rotation-independant scaling of the model matrix.
            vec3 modelScale;
            modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
            modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
            modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
            // The thickness is specified in local space.
            return normalize( refractionVector ) * thickness * modelScale;
          }
          float applyIorToRoughness( const in float roughness, const in float ior ) {
            // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
            // an IOR of 1.5 results in the default amount of microfacet refraction.
            return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
          }
          vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
            float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
            #ifdef USE_SAMPLER
              #ifdef texture2DLodEXT
                return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);
              #else
                return texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);
              #endif
            #else
              return texture2D(buffer, fragCoord.xy);
            #endif
          }
          vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
            if ( isinf( attenuationDistance ) ) {
              // Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.
              return radiance;
            } else {
              // Compute light attenuation using Beer's law.
              vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
              vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law
              return transmittance * radiance;
            }
          }
          vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
            const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
            const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
            const in vec3 attenuationColor, const in float attenuationDistance ) {
            vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
            vec3 refractedRayExit = position + transmissionRay;
            // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
            vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
            vec2 refractionCoords = ndcPos.xy / ndcPos.w;
            refractionCoords += 1.0;
            refractionCoords /= 2.0;
            // Sample framebuffer to get pixel the refracted ray hits.
            vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
            vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
            // Get the specular component.
            vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
            return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
          }
        #endif
`),
            i.fragmentShader = i.fragmentShader.replace("#include <transmission_fragment>", `
        // Improve the refraction to use the world pos
        material.transmission = _transmission;
        material.transmissionAlpha = 1.0;
        material.thickness = thickness;
        material.attenuationDistance = attenuationDistance;
        material.attenuationColor = attenuationColor;
        #ifdef USE_TRANSMISSIONMAP
          material.transmission *= texture2D( transmissionMap, vUv ).r;
        #endif
        #ifdef USE_THICKNESSMAP
          material.thickness *= texture2D( thicknessMap, vUv ).g;
        #endif

        vec3 pos = vWorldPosition;
        float runningSeed = 0.0;
        vec3 v = normalize( cameraPosition - pos );
        vec3 n = inverseTransformDirection( normal, viewMatrix );
        vec3 transmission = vec3(0.0);
        float transmissionR, transmissionB, transmissionG;
        float randomCoords = rand(runningSeed++);
        float thickness_smear = thickness * max(pow(roughnessFactor, 0.33), anisotropicBlur);
        vec3 distortionNormal = vec3(0.0);
        vec3 temporalOffset = vec3(time, -time, -time) * temporalDistortion;
        if (distortion > 0.0) {
          distortionNormal = distortion * vec3(snoiseFractal(vec3((pos * distortionScale + temporalOffset))), snoiseFractal(vec3(pos.zxy * distortionScale - temporalOffset)), snoiseFractal(vec3(pos.yxz * distortionScale + temporalOffset)));
        }
        for (float i = 0.0; i < ${e}.0; i ++) {
          vec3 sampleNorm = normalize(n + roughnessFactor * roughnessFactor * 2.0 * normalize(vec3(rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5)) * pow(rand(runningSeed++), 0.33) + distortionNormal);
          transmissionR = getIBLVolumeRefraction(
            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness  + thickness_smear * (i + randomCoords) / float(${e}),
            material.attenuationColor, material.attenuationDistance
          ).r;
          transmissionG = getIBLVolumeRefraction(
            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior  * (1.0 + chromaticAberration * (i + randomCoords) / float(${e})) , material.thickness + thickness_smear * (i + randomCoords) / float(${e}),
            material.attenuationColor, material.attenuationDistance
          ).g;
          transmissionB = getIBLVolumeRefraction(
            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior * (1.0 + 2.0 * chromaticAberration * (i + randomCoords) / float(${e})), material.thickness + thickness_smear * (i + randomCoords) / float(${e}),
            material.attenuationColor, material.attenuationDistance
          ).b;
          transmission.r += transmissionR;
          transmission.g += transmissionG;
          transmission.b += transmissionB;
        }
        transmission /= ${e}.0;
        totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
`)
        }
        ,
        Object.keys(this.uniforms).forEach(i=>Object.defineProperty(this, i, {
            get: ()=>this.uniforms[i].value,
            set: r=>this.uniforms[i].value = r
        }))
    }
}
const H4 = ve.forwardRef(({buffer: n, transmissionSampler: e=!1, backside: t=!1, side: i=Zr, transmission: r=1, thickness: s=0, backsideThickness: o=0, backsideEnvMapIntensity: a=1, samples: c=10, resolution: f, backsideResolution: h, background: d, anisotropy: m, anisotropicBlur: v, ..._},w)=>{
    Mx({
        MeshTransmissionMaterial: B4
    });
    const x = ve.useRef(null)
      , [g] = ve.useState(()=>new z4)
      , S = WE(h || f)
      , M = WE(f);
    let T, P, R, b;
    return wx(N=>{
        x.current.time = N.clock.getElapsedTime(),
        x.current.buffer === M.texture && !e && (b = x.current.__r3f.parent,
        b && (R = N.gl.toneMapping,
        T = N.scene.background,
        P = x.current.envMapIntensity,
        N.gl.toneMapping = Ar,
        d && (N.scene.background = d),
        b.material = g,
        t && (N.gl.setRenderTarget(S),
        N.gl.render(N.scene, N.camera),
        b.material = x.current,
        b.material.buffer = S.texture,
        b.material.thickness = o,
        b.material.side = ti,
        b.material.envMapIntensity = a),
        N.gl.setRenderTarget(M),
        N.gl.render(N.scene, N.camera),
        b.material = x.current,
        b.material.thickness = s,
        b.material.side = i,
        b.material.buffer = M.texture,
        b.material.envMapIntensity = P,
        N.scene.background = T,
        N.gl.setRenderTarget(null),
        N.gl.toneMapping = R))
    }
    ),
    ve.useImperativeHandle(w, ()=>x.current, []),
    ve.createElement("meshTransmissionMaterial", eu({
        args: [c, e],
        ref: x
    }, _, {
        buffer: n || M.texture,
        _transmission: r,
        anisotropicBlur: v ?? m,
        transmission: e ? r : 0,
        thickness: s,
        side: i
    }))
}
);
function V4(n) {
    const e = Math.min(n.dimensions.width / 14e3, n.dimensions.height / 14e3)
      , [t] = ve.useState(()=>new bt)
      , i = ve.useRef(null)
      , r = (s,o)=>{
        i.current.lookAt(s / 2.5, o / 2.5, 1),
        A4.dampQ(i.current.quaternion, t.quaternion, 5)
    }
    ;
    return wx((s,o)=>{
        r(s.pointer.x, s.pointer.y)
    }
    ),
    ct.jsxs("group", {
        ref: i,
        scale: 1.2,
        position: [e, 0, 0],
        children: [ct.jsxs(GE, {
            scale: e,
            position: [-n.dimensions.width / 2400, e * 2, 0],
            rotation: [0, .1, 0],
            font: "/ABC Diatype ExtBd_Bold.json",
            bevelSegments: 12,
            bevelSize: .03,
            lineHeight: .7,
            children: ["Trubinov", `
`, "Timofey ↗", ct.jsx("meshLambertMaterial", {
                opacity: 1,
                color: 16777215
            })]
        }), ct.jsxs(GE, {
            receiveShadow: !0,
            scale: e,
            position: [-n.dimensions.width / 2400, -e * .7, 0],
            rotation: [0, .1, 0],
            font: "/ABC Diatype Med_Italic.json",
            bevelSegments: 12,
            bevelSize: .03,
            lineHeight: .7,
            children: ["SOFTWARE", `
`, "ENGINEER", ct.jsx(H4, {
                transmission: 1,
                chromaticAberration: .1,
                roughness: .07,
                thickness: .7
            })]
        })]
    })
}
const G4 = n=>{
    const e = ve.useRef(null);
    wx(()=>{
        e.current.material.uniforms.uTime.value = new Date().getTime() / 1e3 % 86400
    }
    );
    const t = ve.useMemo(()=>({
        uTime: {
            value: new Date().getTime() / 1e3 % 86400
        },
        iResolution: {
            value: [window.innerWidth, window.innerHeight]
        }
    }), []);
    return ve.useEffect(()=>{
        const i = ()=>{
            e.current.material.uniforms.iResolution.value = [n.dimensions.width, n.dimensions.height],
            e.current.material.needsUpdate = !0
        }
        ;
        return addEventListener("resize", i),
        ()=>{
            removeEventListener("resize", i)
        }
    }
    , []),
    ct.jsxs(ct.Fragment, {
        children: [ct.jsxs("mesh", {
            ref: e,
            position: [0, 0, -1],
            scale: [n.dimensions.width / 1e3, n.dimensions.height / 1e3, 1],
            receiveShadow: !1,
            children: [ct.jsx("planeGeometry", {}), ct.jsx("shaderMaterial", {
                vertexShader: iz,
                fragmentShader: nz,
                uniforms: t,
                transparent: !0
            })]
        }), ct.jsx(V4, {
            dimensions: n.dimensions
        })]
    })
}
  , W4 = n=>ct.jsxs(ct.Fragment, {
    children: [ct.jsx(G4, {
        dimensions: n.dimensions
    }), ct.jsx("ambientLight", {
        intensity: .1
    }), ct.jsx("spotLight", {
        position: [0, .5, 1],
        angle: Math.PI / 2,
        penumbra: 10,
        intensity: 3,
        castShadow: !0,
        "shadow-mapSize": 1024
    })]
})
  , X4 = n=>{
    const [e,t] = ve.useState("")
      , [i,r] = ve.useState("")
      , [s,o] = ve.useState({
        width: window.innerWidth,
        height: window.innerHeight,
        aspectWH: window.innerWidth / window.innerHeight,
        aspectHW: window.innerHeight / window.innerWidth,
        aspect: Math.max(window.innerWidth / window.innerHeight, window.innerHeight / window.innerWidth)
    })
      , a = ve.useRef(!1)
      c = [{
        s: "Trubinov Timofey",
        replace: !0
    }, {
        s: "Trubinov#Timofey",
        replace: !0,
        delay: 50
    }, {
        s: "Trubinov*Tim$fey",
        replace: !0,
        delay: 50
    }, {
        s: "Trubinov*Tim$f#y",
        replace: !0,
        delay: 50
    }, {
        s: "T@ubinov*Tim$f#y",
        replace: !0,
        delay: 50
    }, {
        s: "T@ub*nov*Tim$f#y",
        replace: !0,
        delay: 50
    }, {
        s: "T@ub*nov*Ti&$f#y",
        replace: !0,
        delay: 50
    }, {
        s: "T@ub***v*Ti&$f#",
        replace: !0,
        delay: 50
    }, {
        s: "T@ub***v*Ti&$f#",
        replace: !0,
        delay: 50
    }, {
        s: "***#*v*ch*Ce*hresmann",
        replace: !0,
        delay: 50
    }, {
        s: "*****v*c#*Ce*hresmann",
        replace: !0,
        delay: 50
    }, {
        s: "*****v*c**#e*hresmann",
        replace: !0,
        delay: 50
    }, {
        s: "*****v*#***e*hresmann",
        replace: !0,
        delay: 50
    }, {
        s: "*****#*****e*hresmann",
        replace: !0,
        delay: 50
    }, {
        s: "***********#*hresmann",
        replace: !0,
        delay: 50
    }, {
        s: "*************hresmann#",
        replace: !0,
        delay: 50
    }, {
        s: "*************#**",
        replace: !0,
        delay: 50
    }, {
        s: "****************",
        replace: !0,
        delay: 1e3
    }, {
        s: "*******x*******",
        replace: !0,
        delay: 100
    }, {
        s: "* ****pxp**** *",
        replace: !0,
        delay: 100
    }, {
        s: "*  **ppxpy**  *",
        replace: !0,
        delay: 100
    }, {
        s: "*   cehresmann    *",
        replace: !0,
        delay: 100
    }, {
        s: "cehresmann",
        replace: !0,
        delay: 1e3
    }, {
        s: " ",
        replace: !0,
        delay: 100
    }, {
        s: "cehresmann",
        replace: !0,
        delay: 70
    }, {
        s: " ",
        replace: !0,
        delay: 70
    }, {
        s: "cehresmann",
        replace: !0,
        delay: 50
    }, {
        s: " ",
        replace: !0,
        delay: 50
    }, {
        s: "cehresmann",
        replace: !0,
        delay: 30
    }, {
        s: " ",
        replace: !0,
        delay: 30
    }, {
        s: "cehresmann",
        replace: !0,
        delay: 10
    }, {
        s: " ",
        replace: !0,
        delay: 1e3
    }, {
        s: "T",
        delay: 100
    }, {
        s: "r",
        delay: 100
    }, {
        s: "u",
        delay: 100
    }, {
        s: "b",
        delay: 100
    }, {
        s: "i",
        delay: 100
    }, {
        s: "n",
        delay: 100
    }, {
        s: "o",
        delay: 100
    }, {
        s: "v",
        delay: 100
    }, {
        s: " ",
        delay: 100
    }, {
        s: "C",
        delay: 100
    }, {
        s: "e",
        delay: 100
    }, {
        s: "h",
        delay: 100
    }, {
        s: "r",
        delay: 100
    },
        {
            s: "e",
            delay: 100
        }, {
            s: "s",
            delay: 100
        }, {
            s: "m",
            delay: 100
        }, {
            s: "a",
            delay: 100
        }, {
            s: "n",
            delay: 100
        }, {
            s: "n",
            delay: 100
        }, {
            s: " ",
            delay: 100
        }, {
            s: "C",
            delay: 100
        }, {
            s: "e",
            delay: 100
        }, {
            s: "h",
            delay: 100
        }, {
            s: "r",
            delay: 100
        }, {
            s: "e",
            delay: 100
        }, {
            s: "s",
            delay: 100
        }, {
            s: "m",
            delay: 100
        }, {
            s: "a",
            delay: 100
        }, {
            s: "n",
            delay: 100
        }, {
            s: "n",
            delay: 2e3
        }], f = h=>{
        let d = c[h % c.length];
        d.replace ? document.title = d.s : document.title += d.s,
        setTimeout(()=>f(h + 1), d.delay ? d.delay : 500)
    }
    ;
    return ve.useEffect(()=>{
        if (a.current)
            return;
        a.current = !0,
        console.log(`

man...`, "background: #fff; padding: 23.5px; color: black; text-align: center; font-size: 20px; font-weight: 200; font-family: 'ABC Diatype', serif", "background: #000; padding: 20px; color: #fff; font-size: 20px; font-weight: 200; font-family: 'ABC Diatype Plus Variable', serif"),
        f(0),
        r(new Date().toLocaleString("en-US", {
            weekday: "long"
        })),
        t(new Date().toLocaleString("en-US", {
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            hour12: !1
        }));
        const h = setInterval(()=>{
            r(new Date().toLocaleString("en-US", {
                weekday: "long"
            })),
            t(new Date().toLocaleString("en-US", {
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                hour12: !1
            }))
        }
        , 500);
        o({
            width: window.innerWidth,
            height: window.innerHeight,
            aspectWH: window.innerWidth / window.innerHeight,
            aspectHW: window.innerHeight / window.innerWidth,
            aspect: Math.max(window.innerWidth / window.innerHeight, window.innerHeight / window.innerWidth)
        });
        const d = ()=>{
            o({
                width: window.innerWidth,
                height: window.innerHeight,
                aspectWH: window.innerWidth / window.innerHeight,
                aspectHW: window.innerHeight / window.innerWidth,
                aspect: Math.max(window.innerWidth / window.innerHeight, window.innerHeight / window.innerWidth)
            })
        }
        ;
        return addEventListener("resize", d),
        ()=>{
            removeEventListener("resize", d),
            clearInterval(h)
        }
    }
    , []),
    ct.jsxs("div", {
        className: "inset-0 fixed overflow-hidden",
        children: [ct.jsx(Jz, {
            className: "fixed inset-0 w-full h-full overflow-hidden touch-auto",
            dpr: [1, 2],
            gl: {
                antialias: !0,
                toneMapping: Jp,
                outputColorSpace: Fi
            },
            orthographic: !0,
            camera: {
                zoom: 1e3,
                position: [0, 0, 5],
                top: s.height / 2,
                bottom: s.height / -2,
                left: s.width / -2,
                right: s.width / 2
            },
            children: ct.jsx(W4, {
                dimensions: s
            })
        }), ct.jsx("main", {
            id: "main",
            className: "absolute inset-0 font-inter font-normal opacity-80 p-6 pointer-events-none",
            children: ct.jsxs("div", {
                className: "relative h-full w-full box-border flex flex-col justify-between",
                children: [ct.jsxs("div", {
                    className: "h-20 hidden absolute my-3 mx-6 top-0 right-0 sm:flex flex-col items-end justify-center",
                    children: [ct.jsx("span", {
                        className: "uppercase font-normal text-lg text-end pointer-events-auto",
                        children: "→2024"
                    }), ct.jsx("span", {
                        className: "uppercase font-normal text-lg text-end pointer-events-auto",
                        children: "https://cehresmann.github.io/"
                    })]
                }), ct.jsxs("div", {
                    className: "h-20 hidden absolute my-3 mx-6 bottom-0 right-0 sm:flex flex-col items-end justify-start",
                    children: [ct.jsx("span", {
                        className: "uppercase font-normal text-lg text-end pointer-events-auto",
                        children: "Personal"
                    }), ct.jsx("span", {
                        className: "uppercase font-normal text-lg text-end pointer-events-auto",
                        children: "Business Card"
                    })]
                }), ct.jsxs("div", {
                    className: "h-20 absolute my-6 sm:my-3 sm:mx-6 bottom-0 left-0 flex flex-col items-start justify-start z-20",
                    children: [ct.jsx("a", {
                        href: "https://cehresmann.github.io/",
                        className: "relative uppercase font-normal text-lg text-start hover:cursor-pointer after:duration-300 after:bg-white after:w-0 after:h-[1.5px] after:absolute after:bottom-[5.5px] after:left-0 hover:after:w-full pointer-events-auto",
                        children: "↗ mail: trubinov04@gmail.com"
                    }), ct.jsx("a", {
                        href: "https://t.me/moy1oldo1",
                        className: "relative uppercase font-normal text-lg text-start hover:cursor-pointer after:duration-300 after:bg-white after:w-0 after:h-[1.5px] after:absolute after:bottom-[5.5px] after:left-0 hover:after:w-full pointer-events-auto",
                        children: "↗ telegram: @moy1oldo1"
                    })]
                }), ct.jsxs("header", {
                    className: "flex flex-col mm:flex-row justify-center items-center h-32 mm:h-10 gap-3 mm:gap-4 sm:gap-10 md:gap-16 select-none",
                    children: [ct.jsxs("div", {
                        className: "flex justify-center mm:justify-between w-min order-2 mm:order-[0] pointer-events-auto",
                        children: [ct.jsx("span", {
                            className: "uppercase font-normal text-lg text-center",
                            children: i
                        }), ct.jsx("span", {
                            className: "uppercase w-20 font-normal text-lg text-center hidden sm:block",
                            children: e
                        })]
                    }), ct.jsx(sL, {
                        size: 40
                    }), ct.jsx("a", {
                        className: "uppercase font-normal text-lg text-center w-40 pointer-events-auto",
                        href: "http://appxpy.com-storage.website.yandexcloud.net",
                        children: "DOWNLOAD CV"
                    })]
                }), ct.jsx("div", {
                    className: "h-10 w-full flex flex-row items-center justify-center",
                    children: ct.jsx("span", {
                        className: "relative uppercase font-normal text-sm opacity-70 md:text-lg text-start pointer-events-auto",
                        children: "© Trubinov Timofey, 2024"
                    })
                })]
            })
        })]
    })
}
;
K0.createRoot(document.getElementById("root")).render(ct.jsx(jb.StrictMode, {
    children: ct.jsx(X4, {})
}));

